<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7-24 洛谷题单之排序</title>
    <url>/2025/07/24/7-24/</url>
    <content><![CDATA[<h1 id="P1116-车厢重组-洛谷"><a href="#P1116-车厢重组-洛谷" class="headerlink" title="P1116 车厢重组 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1116">P1116 车厢重组 - 洛谷</a></h1><p>实际上是个冒泡排序的过程，在这中间记录一下交换的次数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">                sum++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">bubbleSort</span>(arr);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1068-NOIP-2009-普及组-分数线划定-洛谷"><a href="#P1068-NOIP-2009-普及组-分数线划定-洛谷" class="headerlink" title="P1068 [NOIP 2009 普及组] 分数线划定 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1068">P1068 [NOIP 2009 普及组] 分数线划定 - 洛谷</a></h1><p>结构体排序罢了，但是最后记得要处理分数一样的情况。只需要从m* 1.5开始直到第一个不一样的即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">candiate</span>&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> candiate &amp;a, <span class="type">const</span> candiate &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;candiate&gt; <span class="title">vec</span><span class="params">(<span class="number">5001</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; vec[i].name &gt;&gt; vec[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    m = m * <span class="number">1.5</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].score == vec[m - <span class="number">1</span>].score)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m += sum;</span><br><span class="line">    cout &lt;&lt; vec[m<span class="number">-1</span>].score &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cout &lt;&lt; vec[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec[i].score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1012-NOIP-1998-提高组-拼数-洛谷"><a href="#P1012-NOIP-1998-提高组-拼数-洛谷" class="headerlink" title="P1012 [NOIP 1998 提高组] 拼数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1012">P1012 [NOIP 1998 提高组] 拼数 - 洛谷</a></h1><p>具体证明请参照<a href="https://www.luogu.com.cn/problem/solution/P1012">P1012 [NOIP 1998 提高组] 拼数 - 洛谷</a>的第一篇。</p>
<p>对于做出此题而言的关键在于怎么给输入的字符串排序。而且最终的字符串长度是不会有变化的。</p>
<p>一个简单的想法是，<strong>考虑相邻两项是否需要交换</strong></p>
<p><strong>那么就把对字典序贡献最大的放在前面。比较方法只要比较 s1​+s2​ 和 s2​+s1​ 的大小即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vec</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b &gt; b+a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + n, cmp);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans += vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-23 洛谷题单之排序</title>
    <url>/2025/07/23/7-23/</url>
    <content><![CDATA[<h1 id="P1059-NOIP-2006-普及组-明明的随机数-洛谷"><a href="#P1059-NOIP-2006-普及组-明明的随机数-洛谷" class="headerlink" title="P1059 [NOIP 2006 普及组] 明明的随机数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1059">P1059 [NOIP 2006 普及组] 明明的随机数 - 洛谷</a></h1><p>可以直接用sort排序后再去重。</p>
<p>但是考虑到最大只有1000，因此可以用桶排。每个桶只需要记录有没有即可</p>
<p>最后stl库中的set可以同时完成去重和排序的目的。</p>
<p>最终我选择的set。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        s.<span class="built_in">insert</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1093-NOIP-2007-普及组-奖学金-洛谷"><a href="#P1093-NOIP-2007-普及组-奖学金-洛谷" class="headerlink" title="P1093 [NOIP 2007 普及组] 奖学金 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1093">P1093 [NOIP 2007 普及组] 奖学金 - 洛谷</a></h1><p>用结构体存储对应的变量，然后重构cmp即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">score</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> english;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> score &amp;a, <span class="type">const</span> score &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total != b.total) <span class="keyword">return</span> a.total &gt; b.total;</span><br><span class="line">    <span class="keyword">if</span>(a.chinese != b.chinese) <span class="keyword">return</span> a.chinese &gt; b.chinese;</span><br><span class="line">    <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;score&gt; <span class="title">scores</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt;scores[i].chinese &gt;&gt; scores[i].math &gt;&gt; scores[i].english;</span><br><span class="line">        scores[i].total = scores[i].chinese + scores[i].math + scores[i].english;</span><br><span class="line">        scores[i].id = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;s = scores[i];</span><br><span class="line">        cout &lt;&lt; s.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.total &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1781-宇宙总统-洛谷"><a href="#P1781-宇宙总统-洛谷" class="headerlink" title="P1781 宇宙总统 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1781">P1781 宇宙总统 - 洛谷</a></h1><p>这是个大整数，因此不能直接排序。但是考虑到C++字符串提供了比较字典序的方法，因此可以将其作为字符串来比较，当然首先要比较长度</p>
<p>因为只需要最大的，所以不需要全部存储，读一个比一次即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> winner = <span class="number">1</span>;</span><br><span class="line">    string vote;</span><br><span class="line">    cin&gt;&gt;vote;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        string current_vote;</span><br><span class="line">        cin &gt;&gt; current_vote;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(current_vote, vote)) &#123;</span><br><span class="line">            vote = current_vote;</span><br><span class="line">            winner = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; winner &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vote &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-21 代码随想录之数组</title>
    <url>/2025/07/21/day1/</url>
    <content><![CDATA[<h1 id="704-二分查找-力扣（LeetCode）"><a href="#704-二分查找-力扣（LeetCode）" class="headerlink" title="704. 二分查找 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></h1><p>这是二分查找的模版题。二分查找两种思路：左闭右开和左闭右闭。</p>
<p>在进行二分查找的循环中，循环的条件就是查找的区间要是合法的，即区间内至少有1个元素，例如，在左闭右闭的方法中，[1, 1]中至少有“1”这个元素，区间合法；而对于左闭右开，[1, 1)中没有元素，这个区间就是非法的。</p>
<p>在确认区间合法后，才在区间中取中间值</p>
<p>对于左闭右闭：由于每一次查找都需要在合法区间中寻找，且此次循环的合法区间不能包含上一次循环中已经筛除的值，所以在更新左右端点的值时，左端点的下标为中点下标+1，右端点的下标为中点下标-1。</p>
<p>对于左闭右开：与上面一样，但是此时区间的右端点不在区间内，所以在更新左右端点的值时，左端点的下标为中点下标+1，右端点的下标为中点下标。</p>
<p>注意<br>无论是左闭右闭还是左闭右开，在初始化时都必须要让数组中的所有元素都在初始合法区间内，例如数组nums为{1， 2， 3， 4}， 对于左闭右闭，那么初始的合法区间为[0, nums.size() - 1]，而对于左闭右开，初始的合法区间应该为[0, nums.size())</p>
<p>给出代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="27-移除元素-力扣（LeetCode）"><a href="#27-移除元素-力扣（LeetCode）" class="headerlink" title="27. 移除元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a></h1><p>双指针，慢的指向最后一个非val的下一个元素，快的就一直遍历。每遇到一个非val的元素，就把它赋值给慢指针对应的位置</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] == val)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="977-有序数组的平方-力扣（LeetCode）"><a href="#977-有序数组的平方-力扣（LeetCode）" class="headerlink" title="977. 有序数组的平方 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a></h1><p>最开始想的是从数组左右两边遍历，然后将大的放在右边，小的放在左边。但是如果全是负数就会出错，因为不会有任何一个数的绝对值小于数组最右边那个数，则一旦最右边那个数至于最左边后就不会再交换了。</p>
<p>所以初始一个新的数组，然后从后往前填空，但是不改变原数组元素的顺序</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> pos = r;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[r]) &gt; <span class="built_in">abs</span>(nums[l]))&#123;</span><br><span class="line">                result[pos--] = nums[r] * nums[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result[pos--] = nums[l] * nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-21 代码随想录之数组</title>
    <url>/2025/07/21/day2/</url>
    <content><![CDATA[<h1 id="209-长度最小的子数组-力扣（LeetCode）"><a href="#209-长度最小的子数组-力扣（LeetCode）" class="headerlink" title="209. 长度最小的子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></h1><p>双指针维护子数组的左边界和右边界，一个变量记录和。</p>
<p><strong>注意：当和大于等于target时，需要循环减去左边界，因为当新加入的数特别大时，只减一次是不够的</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(f &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, f - s + <span class="number">1</span>);</span><br><span class="line">                    sum -= nums[s];</span><br><span class="line">                    s++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                f++;</span><br><span class="line">                <span class="keyword">if</span>(f &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    sum += nums[f];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX?<span class="number">0</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="58-区间和（第九期模拟笔试）"><a href="#58-区间和（第九期模拟笔试）" class="headerlink" title="58. 区间和（第九期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1070">58. 区间和（第九期模拟笔试）</a></h1><p>可以暴力，但是太慢了。</p>
<p>这里引入前缀和。前缀和可以简单理解为「数列的前n项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。</p>
<p>在这道题目中，计算的是区间内的和(设区间为a、b)，则该区间内的和就是前b项的和减去前a项的和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b))&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prefix[b]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = prefix[b] - prefix[a - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="44-开发商购买土地（第五期模拟笔试）"><a href="#44-开发商购买土地（第五期模拟笔试）" class="headerlink" title="44. 开发商购买土地（第五期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1044">44. 开发商购买土地（第五期模拟笔试）</a></h1><p>其实还是用前缀和的思想，但是这里最好是把整个二维数组观想成一维一维的数组（无论行列）。然后将每一维当作一个元素，去求整体的前缀和。</p>
<p>因为无论怎么分，都是以一行或者一列为单位的，那么这里面所有的元素都会划在同一个区域</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">            sum += vec[i][j];<span class="comment">//计算所有元素的和，因为只有两个区域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; m; j++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j == m - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line">            <span class="comment">//每经过一行，计算所有元素的和，然后计算result</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line">			<span class="comment">//同样作用在列上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-22 洛谷题单之排序</title>
    <url>/2025/07/22/7-22/</url>
    <content><![CDATA[<h1 id="P1177-【模板】排序-洛谷"><a href="#P1177-【模板】排序-洛谷" class="headerlink" title="P1177 【模板】排序 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1177">P1177 【模板】排序 - 洛谷</a></h1><p>主要是练一下手写快排。</p>
<h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p>本部分讲述的是常用的三路快速排序。如果想了解快速排序的更多变种实现方式可以在 <a href="https://oi-wiki.org/basic/quick-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">OI Wiki</a> 中了解。</p>
<p>我们设待排序的序列为一个长度为 n 的序列 a。快速排序的具体原理如下：</p>
<p>首先，在 a 中随机选择一个数 x，之后我们进行如下操作：</p>
<ol>
<li>如果 n&#x3D;0 或 n&#x3D;1，此时根本无需排序，直接退出；</li>
<li>定义三个新的序列 b,c,d；</li>
<li>遍历整个序列 a，将比 x 小的放在 b 内，比 x 大的放在 d 内，和 x 相等的放在 c 内；</li>
<li>将 b,d 按如上过程继续排序。序列 c 中的数由于都相等所以不必排序。</li>
</ol>
<p>可以发现：实际上每一次的排序之后都会通过调用本身来继续排序，这明显就是递归。</p>
<p>通过递归，我们将一个完整的序列经过不断的分解来变成很多个小序列，直到只有一个或没有数为止。<strong>这种排序就是在不断的递归和分解当中来慢慢实现与完成排序</strong></p>
<p>模版代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    T pivot = arr[<span class="built_in">rand</span>() % (right - left + <span class="number">1</span>) + left];</span><br><span class="line">    <span class="type">int</span> i = left, j = left, k = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[k--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, left, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, k + <span class="number">1</span>, right);</span><br><span class="line">	<span class="comment">//j是第一个pivot所在的位置,k是最后一个pivot所在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1923-【深基9-例4】求第-k-小的数-洛谷"><a href="#P1923-【深基9-例4】求第-k-小的数-洛谷" class="headerlink" title="P1923 【深基9.例4】求第 k 小的数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k 小的数 - 洛谷</a></h1><p>通过分治去求。考虑上面的快排，每次分出三个相对有序的序列，可以据此判断出第k小的数在哪个序列中，然后再递归对应的序列即可</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_nth_k</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right,<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> arr[left];</span><br><span class="line">    T pivot = arr[(right-left) / <span class="number">2</span> + left];</span><br><span class="line">    <span class="type">int</span> i = left, j = left, k = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[k--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; j - left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_nth_k</span>(arr, left, j<span class="number">-1</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k - left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_nth_k</span>(arr, k<span class="number">+1</span>, right, pos- (k - left + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-244 代码随想录之链表</title>
    <url>/2025/07/24/day4/</url>
    <content><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点-力扣（LeetCode）"><a href="#19-删除链表的倒数第-N-个结点-力扣（LeetCode）" class="headerlink" title="19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></h1><p>先让cur节点往后跑n-1个，然后一起后移cur和pre。</p>
<p>这样当cur是最后一个节点时，pre就指向的是倒数第n个节点的前一个节点了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        ListNode* pre = dummynode;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> dummynode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="面试题-02-07-链表相交-力扣（LeetCode）"><a href="#面试题-02-07-链表相交-力扣（LeetCode）" class="headerlink" title="面试题 02.07. 链表相交 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></h1><p>设「第一个公共节点」为 node ，「链表 headA」的节点数量为 a ，「链表 headB」的节点数量为 b ，「两链表的公共尾部」的节点数量为 c ，则有：</p>
<p>头节点 headA 到 node 前，共有 a−c 个节点；<br>头节点 headB 到 node 前，共有 b−c 个节点；</p>
<p>那么让两个链表头先遍历完本身，再去从对方的头开始遍历，直到到达公共节点时指针 A , B 重合（如下所示）：<br>$a+(b−c)&#x3D;b+(a−c)$</p>
<p>并有两种情况：</p>
<ul>
<li>若两链表 有 公共尾部 (即 c&gt;0 ) ：指针 A , B 同时指向「第一个公共节点」node 。</li>
<li>若两链表 无 公共尾部 (即 c&#x3D;0 ) ：指针 A , B 同时指向 null 。<br>此时返回A、B均可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A = headA;</span><br><span class="line">        ListNode *B = headB;</span><br><span class="line">        <span class="keyword">while</span>(A != B)&#123;</span><br><span class="line">            A = A != <span class="literal">NULL</span>? A-&gt;next : headB;</span><br><span class="line">            B = B != <span class="literal">NULL</span>? B-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="142-环形链表-II-力扣（LeetCode）"><a href="#142-环形链表-II-力扣（LeetCode）" class="headerlink" title="142. 环形链表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></h1><p>能想到用快慢指针，快指针走2n步，慢指针走n步，通过是否碰撞来检测环的存在。</p>
<p>但是第一次确实没想到要怎么判断环的入口在哪里</p>
<p>借一下灵神的图吧<br> <img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250724/vR3R/986X829/LT142.png" alt="986X829&#x2F;LT142.png"></p>
<blockquote>
<p>[!NOTE] 链接<br><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/1999271/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-nvsq/">142. 环形链表 II - 力扣（LeetCode）</a></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">while</span> (slow != head) &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-23 代码随想录之链表</title>
    <url>/2025/07/23/day3/</url>
    <content><![CDATA[<h1 id="203-移除链表元素-力扣（LeetCode）"><a href="#203-移除链表元素-力扣（LeetCode）" class="headerlink" title="203. 移除链表元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（LeetCode）</a></h1><p>链表的题我个人还是喜欢有一个虚拟的头节点更好。这样便于操作和处理边界情况</p>
<p>在这个题里，维护一个当前节点和当前节点的前一个节点，当前节点值为val时，只需要把前一个节点的next指向当前节点的next即可。</p>
<p><strong>最后返回虚拟头节点的next是因为当链表内全为对应val时，原head节点将被删除</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        ListNode* dumhead = pre;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                ListNode* tmp = cur;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="206-反转链表-力扣（LeetCode）"><a href="#206-反转链表-力扣（LeetCode）" class="headerlink" title="206. 反转链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></h1><p>循环的做法比较简单，不赘述</p>
<p>对于递归，考虑设计一个函数，每次翻转两个节点间的指向关系即可。最后的那个节点就是头节点</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">nullptr</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="24-两两交换链表中的节点-力扣（LeetCode）"><a href="#24-两两交换链表中的节点-力扣（LeetCode）" class="headerlink" title="24. 两两交换链表中的节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></h1><p>依然设置一个虚拟头节点，current指针的下一个节点是需要临时保存的；因为是两两交换  </p>
<p>还有循环停止的条件是current节点和下个节点不能为空</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode* pre = dummyhead;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next; </span><br><span class="line">            cur-&gt;next = temp-&gt;next</span><br><span class="line">            temp-&gt;next = cur;</span><br><span class="line">            pre-&gt;next = temp;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>浅谈协程</title>
    <url>/2024/06/30/%E6%B5%85%E8%B0%88%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>探讨协程的底层实现，剖析开源库 libco 的实现，并在此基础之上实现一个简单的协程</p>
<span id="more"></span>
<h1 id="浅谈协程"><a href="#浅谈协程" class="headerlink" title="浅谈协程"></a>浅谈协程</h1><h2 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h2><p>协程就是用户态的线程，但是上下文切换的时机是靠调用方（写代码的开发人员）自身去控制的。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  <span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单线程中，上述函数的输出为：<code>1 2 3 x y z</code></p>
<p>如果我们用 libco 库将上面程序改造一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   co_yield_ct();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   co_yield_ct();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...  <span class="comment">// 主协程</span></span><br><span class="line">  co_resume(A);  <span class="comment">// 启动协程 A</span></span><br><span class="line">  co_resume(B);  <span class="comment">// 启动协程 B</span></span><br><span class="line">  co_resume(A);  <span class="comment">// 从协程 A 切出处继续执行</span></span><br><span class="line">  co_resume(B);  <span class="comment">// 从协程 B 切出处继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在单线程中，改造后的程序输出如下：<code>1 2 x 3 y z</code></p>
<p>xxxxxxxxxx23 1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3​4vector<string> vec(25);5​6bool cmp(const string &amp;a, const string &amp;b){7    return a+b &gt; b+a;8}9​10int main(){11    int n;12    cin &gt;&gt; n;13    for(int i &#x3D; 0; i &lt; n; i++){14        cin &gt;&gt; vec[i];15    }16    sort(vec.begin(), vec.begin() + n, cmp);17    string ans;18    for(int i &#x3D; 0; i &lt; n; i++){19        ans +&#x3D; vec[i];20    }21    cout &lt;&lt; ans &lt;&lt; endl;22    return 0;23}cpp</string></p>
<p>函数 A() 和 B() 并不是一个执行完才执行另一个，而是产生了 “交叉执行“ 的效果，这就是通过协程实现的</p>
<h2 id="为什么不用线程而用协程"><a href="#为什么不用线程而用协程" class="headerlink" title="为什么不用线程而用协程"></a>为什么不用线程而用协程</h2><p>有些时候我们在执行一些操作（尤其是IO操作）时，不希望去做“创建一个新的线程”这种重量级的操作来异步处理。而是希望：<strong>在当前线程执行中，暂时切换到其他任务中执行，同时在IO真正准备好了之后，再切换回来继续执行！</strong></p>
<p>相比于多开一个线程来操作，使用协程的好处：</p>
<ul>
<li><strong>减少了线程的重复高频创建；</strong></li>
<li><strong>尽量避免线程的阻塞；</strong></li>
<li><strong>提升代码的可维护与可理解性（毕竟不需要考虑多线程那一套东西了）</strong></li>
</ul>
<p>下面是一些协程的特点：</p>
<ul>
<li><strong>协程可以主动让出 CPU 时间片；（注意：不是当前线程让出 CPU 时间片，而是线程内的某个协程让出时间片供同线程内其他协程运行；）</strong></li>
<li><strong>协程可以恢复 CPU 上下文；当另一个协程继续执行时，其需要恢复 CPU 上下文环境；</strong></li>
<li><strong>协程有个管理者，管理者可以选择一个协程来运行，其他协程要么阻塞，要么ready，或者died；</strong></li>
<li><strong>运行中的协程将占有当前线程的所有计算资源；</strong></li>
<li><strong>协程天生有栈属性，而且是 lock free；</strong></li>
</ul>
<h1 id="协程的类别"><a href="#协程的类别" class="headerlink" title="协程的类别"></a>协程的类别</h1><p>根据是否存在<strong>调用栈</strong>，可以分为以下两类</p>
<ul>
<li>有栈协程：类似于内核态线程，不同协程间切换还是要切换上下文，只是不需要陷入内核。例如goroutine、libco</li>
<li>无栈协程：上下文放在公共内存中，切换时使用状态机来切换，而不切换对应的上下文（因为已经在堆里了），更轻量，例如：C++20、Rust、JavaScript 中的协程</li>
</ul>
<p>根据是否存在明显的调用关系，可以分为</p>
<ul>
<li>非对称协程：协程间有明显的调用关系</li>
<li>对称协程：无明显调用关系</li>
</ul>
<h2 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h2><p>开源库 libco 就是通过汇编语言实现的有栈协程库。</p>
<p>通过分析代码可以看到，无论是<code>co_yield</code>还是<code>co_resume</code>，在协程切出和恢复时，都调用了同一个函数<code>co_swap</code>，在这个函数中调用了 <code>coctx_swap</code> 来实现协程的切换，这一函数的原型是<br><code>void coctx_swap( coctx_t *,coctx_t* ) asm(&quot;coctx_swap&quot;);</code></p>
<p>两个参数都是 <code>coctx_t *</code> 指针类型，其中第一个参数表示要切出的协程，第二个参数表示切出后要进入的协程；</p>
<p>并不会像常规被调用函数一样创立新栈帧。而是通过调整 <code>%rsp</code> 的值来恢复新协程的栈，并利用了 <code>ret</code> 语句来实现修改指令寄存器 <code>%rip</code> 的目的，通过修改 <code>%rip</code> 来实现程序运行逻辑跳转；</p>
<blockquote>
<p>[!NOTE] %rip的修改<br>不能直接修改，只能通过call或ret来修改</p>
</blockquote>
<p><strong>整体上看来，协程的切换其实就是： cpu 寄存器内容特别是 <code>%rip</code> 和 <code>%rsp</code> 的写入和恢复，因为 cpu 的寄存器决定了程序从哪里执行（%rip) 和使用哪个地址作为堆栈 （%rsp）；</strong></p>
<h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>无栈协程本质上是一个状态机，从另一个角度上：<strong>同一协程切换的本质不过是指令指针寄存器的改变</strong></p>
<p>先来看一个使用libco的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">test</span><span class="params">(<span class="type">void</span>* para)</span></span>&#123; </span><br><span class="line">	<span class="built_in">co_enable_hook_sys</span>(); </span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">poll</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.</span> <span class="number">1000</span>); <span class="comment">// 协程切换执行权，1000ms后返回 </span></span><br><span class="line">	i++; </span><br><span class="line">	<span class="built_in">poll</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.</span> <span class="number">1000</span>); <span class="comment">// 协程切换执行权，1000ms后返回 </span></span><br><span class="line">	i--; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	stCoRoutine_t* routine; </span><br><span class="line">	<span class="built_in">co_create</span>(&amp;routine, <span class="literal">NULL</span>, test, <span class="number">0</span>); <span class="comment">// 创建一个协程 </span></span><br><span class="line">	<span class="built_in">co_resume</span>(routine); </span><br><span class="line">	<span class="built_in">co_eventloop</span>(<span class="built_in">co_get_epoll_ct</span>(),<span class="number">0</span>,<span class="number">0</span> ); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是无栈协程，实现相同逻辑的代码是怎么样的呢？</p>
<p>其实就是翻译成类似于以下状态机的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_coroutine</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="type">int</span> __state = <span class="number">0</span>; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MoveNext</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">switch</span>(__state) &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">frist</span>(); </span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">second</span>(); </span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">third</span>(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">frist</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i = <span class="number">0</span>; __state = <span class="number">1</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i++; _state = <span class="number">2</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i--; </span><br><span class="line">	&#125; </span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p><strong>把整个协程抽象成一个类，以原本需要执行切换的语句处为界限，把函数划分为几个部分，并在某一个部分执行完以后进行状态转移，在下一次调用此函数的时候就会执行下一部分</strong></p>
<p>这样就完全没有必要像有栈协程那样显式的执行上下文切换了，我们只需要一个简易的调度器来调度这些函数即可；</p>
<p>从执行时栈的角度来看：</p>
<p><strong>其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值；</strong></p>
<p><strong>而且相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别，这样也可以凸显出无栈协程的高效；</strong></p>
<h2 id="对称协程与非对称协程"><a href="#对称协程与非对称协程" class="headerlink" title="对称协程与非对称协程"></a>对称协程与非对称协程</h2><ul>
<li><strong>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移；</strong></li>
<li><strong>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系；</strong></li>
</ul>
<p>非对称协程就是拥有调用栈，而对称协程则是大家都平等，不需要调用栈，只需要一个数据结构存储未执行完的协程即可</p>
<p>我个人认为非对称协程相比之下更为符合认知，因为对称协程目前我不知道如何选择一个合适的协程来获得CPU执行权，正如上面所说，此协程可能正在等待事件；当然如果调度算法足够优秀的话，对称协程也是可取的；</p>
<h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="N-1-N-M-协程"><a href="#N-1-N-M-协程" class="headerlink" title="N:1 &amp; N:M 协程"></a>N:1 &amp; N:M 协程</h2><p>线程绑定的协程只有在对应线程运行的时候才有被执行的可能，如果对应线程中的某一个协程完全占有了当前线程，那么当前线程中的其他所有协程都不会被执行</p>
<p>协程的所有信息都保存在上下文（Contex）对象中，将不同上下文分发给不同的线程就可以实现协程的跨线程执行，如此，协程被阻塞的概率将减小；</p>
<p>借用 <a href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/bthread.md">BRPC</a> 中对 <code>N:M</code> 协程的介绍，来解释下什么是 <code>N:M</code> 协程：</p>
<p>常说的协程是指的N:1协程库，即所有协程运行在一个系统线程中，<strong>计算能力和各类eventloop库等价</strong></p>
<p>由于不跨线程，那么切换也不需要系统调用，受cache一致性的影响也比较小，可以非常快</p>
<p>但是代价是无法高效利用多核，而且代码必须非阻塞，否则所有协程都会卡住</p>
<p><code>bthread</code> 是一个 <code>M:N</code> 线程库，一个<code>bthread</code>被卡住不会影响其他<code>bthread</code>；</p>
<p>其中的关键技术有两点：</p>
<ul>
<li><strong>work stealing 调度；</strong></li>
<li><strong>butex；</strong></li>
</ul>
<p>前者让 bthread 更快地被调度到更多的核心上，后者让 bthread 和 pthread 可以相互等待和唤醒，这两点协程都不需要；</p>
<p>这么看来 貌似 bthread 自己实现了 golang 的 goroutine？</p>
<p>表面看起来的却如此：两者都实现了 M:N 用户态线程；</p>
<p>但是事实上， golang 中的 goroutine 的实现要更为复杂一些：</p>
<p>bthread 的设计比较接近 go 1.0 版本：OS 线程不会动态增加，在有大量的阻塞性 syscall 下，会有影响；</p>
<p>而 go 1.1 之后的设计就是动态增减 OS 线程，而且提供了 LockOSThread，可以让 goroutine 和 OS 线程 1:1；</p>
<h2 id="协程的组成"><a href="#协程的组成" class="headerlink" title="协程的组成"></a>协程的组成</h2><p>N:M模式下的协程其实就是可以由用户来确定调度顺序的用户态线程，对比系统线程可以分为以下几个模块：</p>
<ul>
<li>协程上下文：对应系统中的PCB&#x2F;TCB</li>
<li>保存协程上下文的容器：对应操作系统中保存 PCB&#x2F;TCB 的容器，一般是一个列表（在实际实现时，协程上下文容器可以使用一个也可以使用多个，比如：普通协程队列、定时的协程优先队列等</li>
<li>协程的执行器<ul>
<li>协程的调度器：对应操作系统中的进程、线程调度器</li>
<li>执行协程的worker线程，对应实际进程&#x2F;线程的CPU核心</li>
</ul>
</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>参照进程调度即可</p>
<h2 id="协程相关工具"><a href="#协程相关工具" class="headerlink" title="协程相关工具"></a>协程相关工具</h2><p>系统级线程有锁、条件变量等工具，</p>
<p><strong>系统级线程和协程处于不同的系统层级，所以两者的同步工具不完全通用，如果在协程中使用了线程的锁（例如：<code>std::mutex</code>），则整个线程将会被阻塞，当前线程将不会再调度与执行其他协程；</strong></p>
<h2 id="对CPU-IO的影响"><a href="#对CPU-IO的影响" class="headerlink" title="对CPU&#x2F;IO的影响"></a>对CPU&#x2F;IO的影响</h2><p>目的在于剔除线程的阻塞，提供CPU利用率</p>
<p>很多服务在处理业务时需要请求第三方服务，向第三方服务发起 RPC 调用；RPC 调用的网络耗时一般耗时在毫秒级别，RPC 服务的处理耗时也可能在毫秒级别，如果当前服务使用同步调用，即 RPC 返回后才进行后续逻辑，那么一条线程每秒处理的业务数量是可以估算的；</p>
<p>假设每次业务处理花费在 RPC 调用上的耗时是 20ms，那么一条线程一秒最多处理 50 次请求！</p>
<p>如果在等待 RPC 返回时当前线程没有被系统调度转换为 Ready 状态，那当前 CPU 核心就会空转，浪费了 CPU 资源！通过增加线程数量提高系统吞吐量的效果非常有限，而且创建大量线程也会造成其他问题！</p>
<p>协程虽然不一定能减少一次业务请求的耗时，但一定可以提升系统的吞吐量：</p>
<ul>
<li>当前业务只有一次第三方 RPC 的调用，那么协程不会减少业务处理的耗时，但可以提升 QPS；</li>
<li>当前业务需要多个第三方 RPC 调用，<strong>同时创建多个协程可以让多个 RPC 调用一起执行，则当前业务的 RPC 耗时由耗时最长的 RPC 调用决定；</strong></li>
</ul>
]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>字符串、向量和数组</title>
    <url>/2024/05/31/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>本文为阅读C++ primer第三章的读书笔记，仅作为查找以及防止遗忘对应知识点作用，不可替代原书。</p>
<span id="more"></span>
<h1 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h1><p>可以对单个名字进行独立的using声明</p>
<p>头文件里不应包含 using 声明。因为头文件的内容会拷贝到所有引用它的文件，一旦头文件有using声明，每个引用它的文件都有该声明，可能冲突</p>
<h1 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h1><p>string 表示可变长的字符序列。</p>
<h2 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h2><p>有以下几种方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1; <span class="comment">//将 s1 默认初始化为一个空的 string </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(s2)</span></span>; <span class="comment">//使用拷贝构造函数进行的拷贝初始化。s1 是 s2 的拷贝。 </span></span><br><span class="line">string s1 = s2; <span class="comment">//使用拷贝赋值运算符进行的拷贝初始化。s1 是 s2 的拷贝。 </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>; <span class="comment">//s1 是字面值 &quot;value&quot; 去除最后一个空字符后的拷贝。 </span></span><br><span class="line">string s1 = <span class="string">&quot;value&quot;</span>; <span class="comment">//同上。 </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//s1 初始化为 n 个 &#x27;c&#x27;。</span></span><br></pre></td></tr></table></figure>
<p><strong>使用字符串字面值或字符数组初始化 string 对象时，string 对象中是不包含末尾的空字符的，它会将字符数组中末尾的空字符去掉</strong></p>
<h2 id="string的一些操作"><a href="#string的一些操作" class="headerlink" title="string的一些操作"></a>string的一些操作</h2><p><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250725/QdOG/1040X475/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-07-25_163653.png" alt="1040X475&#x2F;屏幕截图_2025-07-25_163653.png"></p>
<h3 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h3><p>可以使用 cin, cout 来读写 string 对象，也可以使用 stringstream 来读写 string 对象。</p>
<h4 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline 函数"></a>getline 函数</h4><p>getline() 定义在头文件 string 中，以一个 istream 对象和一个 string 对象为输入参数。getline() 读取输入流的内容直到遇到换行符停止，然后将读入的数据存入 string 对象。</p>
<p>注意 getline 会将换行符也读入，但是不将换行符存入 string 对象。即触发 getline() 函数返回的那个换行符实际上被丢弃掉了。</p>
<p>getline() 只要一遇到换行符就结束读取操作并返回结果，即使一开始就是换行符也一样，这种情况下会得到一个空 string。</p>
<p>getline() 与 &lt;&lt; 一样，会返回它的流参数。所以可以用 getline 的结果作为条件。</p>
<h3 id="string-size-type-类型"><a href="#string-size-type-类型" class="headerlink" title="string::size_type 类型"></a>string::size_type 类型</h3><p>string 的 size() 成员函数返回一个 string::size_type 类型的值。</p>
<blockquote>
<p>[!NOTE] 配套类型<br>大多数标准库类型都定义了几种配套的类型，这些配套类型体现了标准库与机器无关的特性。</p>
</blockquote>
<p>在具体使用时，通过作用域操作符来表明 size_type 是在类 string 中定义的。</p>
<p>string::size_type 是无符号值，可以确定的是它足够存放任何 string 对象的大小。</p>
<p>C++11 允许通过 auto 和 decltype 来获得此类型。</p>
<p><code>auto len = s.size();// len 的类型是 string::size_type</code></p>
<p>不要在同一个表达式中混用 size_type 和 int 类型。原因一部分在于无符号数和有符号数转换的问题上</p>
<h2 id="string中的字符"><a href="#string中的字符" class="headerlink" title="string中的字符"></a>string中的字符</h2><p>cctype 头文件中有下列标准库函数来处理 string 中的字符。</p>
<p>下面这些函数的输入和返回值实际都是 int 类型的，且输入的值 c 必须满足 -1&lt;&#x3D;c&lt;&#x3D;255，即输入必须是 ASCII 字符<br><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250725/blbx/1019X636/cctype.png" alt="1019X636&#x2F;cctype.png"></p>
<blockquote>
<p>[!tip] 头文件使用建议<br>使用 c++ 版本的标准库头文件</p>
</blockquote>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str) <span class="comment">// 对于str中的每个字符 </span></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出当前字符，后面紧跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>当要改变 string 对象中的值时，需要把循环变量定义成引用类型。必须通过显示添加 &amp; 符号来声明引用类型。</p>
<p><strong>不能在范围 for 语句中改变所遍历序列的大小。</strong></p>
<p><code>for(auto &amp;c:str) c = toupper(c); // 转换为大写</code></p>
<p>对 string 的最后一个字符进行索引：s[s.size()-1];</p>
<p>索引必须大于等于 0 小于 size，使用索引前最好用 if(!s.empty()) 判断一下字符串是否为空。</p>
<p>任何表达式只要是整型值就可以作为索引。索引是无符号类型 size_type；</p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>7-25 代码随想录之哈希表</title>
    <url>/2025/07/25/day5/</url>
    <content><![CDATA[<h1 id="242-有效的字母异位词-力扣（LeetCode）"><a href="#242-有效的字母异位词-力扣（LeetCode）" class="headerlink" title="242. 有效的字母异位词 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（LeetCode）</a></h1><p>可以用哈希，也可以直接大小为26的数组。如果是unicode字符，那就必须用哈希了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)&#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t)&#123;</span><br><span class="line">            hash[c]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : hash)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="349-两个数组的交集-力扣（LeetCode）"><a href="#349-两个数组的交集-力扣（LeetCode）" class="headerlink" title="349. 两个数组的交集 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></h1><p>维护一个set。前面插入，后面删除。如果删除成功（即之前加入了），就加入结果集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; n1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : nums1)&#123;</span><br><span class="line">            n<span class="number">1.</span><span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n<span class="number">1.</span><span class="built_in">erase</span>(b))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="202-快乐数-力扣（LeetCode）"><a href="#202-快乐数-力扣（LeetCode）" class="headerlink" title="202. 快乐数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></h1><p>既然有可能无限循环，那就说明会遇到重复的数。</p>
<p>简单计算一下，即使是9999计算后也只是324,。因此一个set是够存放的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SumSquare</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            ans = ans + (a * a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">SumSquare</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>变量和基本类型</title>
    <url>/2024/05/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>本文为阅读C++ primer第二章的读书笔记，仅作为查找以及防止遗忘对应知识点作用，不可替代原书。</p>
<span id="more"></span>
<p>C++定义了几种基本内置类型，如字符、整型、浮点数等。</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>基本内置类型包括算数类型和空类型。算术类型包括字符、整数、布尔值和浮点数。void类型没有关联的值，只能在少数情况下使用，最常见的是作为不返回值的函数的返回类型</p>
<h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>算数类型整体分为整型和浮点型两类。字符和布尔值都属于整型。</p>
<p>C++ 定义了各类型的最小尺寸：bool 未定义、char 8位、short 16位、int 16位、long 32位、long long 64位；float 是 32 位 4 字节，包括6位有效数字、double 是 64 位 8 字节，包括10位有效数字。</p>
<blockquote>
<p>[!NOTE] int位数的特别说明<br>int作为一个变长的类型，可能是16位，也可能是32位，取决于编译器。目前多为32位</p>
</blockquote>
<p>int、short、long 都是带符号类型。char 是否有符号由编译器决定。</p>
<p>因为 char 是否有符号并不确定，因此可以使用 signed char 或 unsigned char 来指定是否有符号。</p>
<p>C++ 提供了几种字符类型：</p>
<ol>
<li>char：一个 char 的空间应确保可以存放机器基本字符集中任意字符对于的数字值，即一个 char 的大小和一个机器字节一样。</li>
<li>wchar_t：宽字符，用于扩展字符集，wchar_t 确保可以存放机器最大扩展字符集中的任意一个字符。</li>
<li>char16_t 和 char32_t：为 Unicode 字符集服务。<br>下为书中列出的表格：<br><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250719/ilim/1158X563/C%2B%2B_Arithmetic_Types.png" alt="1158X563&#x2F;C++_Arithmetic_Types.png"></li>
</ol>
<blockquote>
<p>[!NOTE] 类型选择技巧<br>明确知晓数值不可能为负时，选用无符号类型。</p>
<p>整数运算用 int，数值太大时用 long long，不用 short 和 long </p>
<p>浮点数运算用 double。float 和 double 的计算代价相差无几</p>
</blockquote>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="几种类型转换的情况："><a href="#几种类型转换的情况：" class="headerlink" title="几种类型转换的情况："></a>几种类型转换的情况：</h3><ul>
<li>把浮点数赋给整型时，结果仅保留小数点前的部分。</li>
<li>赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如 -1 赋给 8 位 unsigned char 的结果是 255（-1&#x3D;256*(-1)+255）</li>
<li>赋给带符号类型超出范围的值时，结果是未定义的。程序可能工作，可能崩溃。</li>
</ul>
<p>程序尽量避免依赖于实现环境的行为。比如 int 的尺寸在不同环境可能不同。</p>
<h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p>一个表达式中既有无符号数又有int值时，int会被转换成无符号数。</p>
<p>无符号减无符号数，结果还是无符号数，如果是负值就等于该符数加上无符号数的模<br><code>unsigned u = 10; int i = -42; u + i = -32 + 2^32 = 4294967264</code></p>
<h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。</p>
<p>整型字面值的具体数据类型由它的值和符号决定。默认情况下十进制字面值是带符号数，类型是 int, long, long long 中能容纳当前值的尺寸最小的那个。</p>
<p>浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识</p>
<h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><p>单引号括起来的一个字符是 char 型字面值，双引号括起来的 0 个或多个字符则构成字符串型字面值。</p>
<p>字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（’\0’），因此字符串字面值的实际长度要比它的内容多 1。如 “A” 代表了一个长度为 2 的字符数组。</p>
<p><strong>如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string global_str = <span class="string">&quot;A is B&quot;</span>   <span class="string">&quot;and B is A&quot;</span>;</span><br><span class="line">cout &lt;&lt; global_str &lt;&lt; endl; <span class="comment">// 输出: A is Band B is A</span></span><br></pre></td></tr></table></figure>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>建议直接网上查表</p>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>可以通过给字面值增加前缀和后缀来改变字面值的默认类型。<br>下为一些常见的字面量类型指定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;整型字面值&#x27;</span> </span><br><span class="line"><span class="number">12</span> <span class="comment">// 默认类型为 int </span></span><br><span class="line"><span class="number">12u</span> <span class="number">12U</span> <span class="comment">// 最小匹配类型 unsigned </span></span><br><span class="line"><span class="number">12l</span> <span class="number">12L</span> <span class="comment">// 最小匹配类型 long </span></span><br><span class="line"><span class="number">12ul</span> <span class="number">12UL</span> <span class="comment">// 最小匹配类型 unsigned long </span></span><br><span class="line"><span class="number">12ll</span> <span class="number">12LL</span> <span class="comment">// 最小匹配类型 long long </span></span><br><span class="line"><span class="number">12ull</span> <span class="number">12ULL</span> <span class="comment">// 最小匹配类型 unsigned long long </span></span><br><span class="line"><span class="string">&#x27;浮点型字面值&#x27;</span> </span><br><span class="line"><span class="number">3.14</span> <span class="comment">// 默认类型为 double </span></span><br><span class="line"><span class="number">3.14f</span> <span class="number">3.14F</span> <span class="comment">// 类型为 float </span></span><br><span class="line"><span class="number">3.14l</span> <span class="number">3.14L</span> <span class="comment">// 类型为 long double </span></span><br><span class="line"><span class="string">&#x27;字符字符串字面值&#x27;</span> </span><br><span class="line"><span class="string">u&#x27;a&#x27;</span> <span class="string">u&quot;abandon&quot;</span> <span class="comment">// Unicode 16 字符，类型为 char16_t </span></span><br><span class="line"><span class="string">U&#x27;a&#x27;</span> <span class="string">U&quot;abandon&quot;</span> <span class="comment">// Unicode 32 字符，类型为 char32_t </span></span><br><span class="line"><span class="string">L&#x27;a&#x27;</span> <span class="string">L&quot;abandon&quot;</span> <span class="comment">// 宽字符，类型为 wchar_t </span></span><br><span class="line"><span class="string">u8&quot;abandon&quot;</span> <span class="comment">// 类型为 char，u8 的含义是 UTF-8，仅用于字符串字面值。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意 12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f</strong></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>对于c++而言，”变量“和”对象“一般可以互换使用。</p>
<p>c++中，对象通常指一块能存储数据并具有某种类型的内存</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>可以一个一个初始化</p>
<p>也可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。<br><code>double price = 109.99, discount = price * 0.6;</code></p>
<p>初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值擦除并用一个新值来替代。</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>下面四种初始化方式都是可行的，其中使用花括号的方式叫做列表初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>; <span class="type">int</span> i=&#123;<span class="number">0</span>&#125;; <span class="type">int</span> i&#123;<span class="number">0</span>&#125;; <span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>; </span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;, b=&#123;ld&#125;; <span class="comment">//错误，存在信息丢失的风险，转换未执行。 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d</span>=ld; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p><strong>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。</strong></p>
<p>定义于任何函数之外的内置类型则被初始化为0；</p>
<p>类的对象如果没有显式地初始化，则其由类确定。string 默认初始化为一个空串。</p>
<p>不能使用未初始化的变量，否则会引发运行时故障。</p>
<p><strong>建议初始化每一个内置类型的变量。</strong></p>
<h2 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h2><p>声明和定义是严格区分的。</p>
<p>要声明一个变量加 extern，声明变量不能赋值。</p>
<p>任何包含了显式初始化的声明即成为定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// 声明 i </span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">// 定义i； </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 定义 i，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure>
<p>变量只能被定义一次，但是可以多次声明。通过这种方式，一个变量可以在多个文件中使用</p>
<p>声明和定义的区分很重要</p>
<p>c++是静态类型语言，其含义是在编译阶段检查类型。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。</p>
<p>用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。这些是为了确保用户自定义的标识符不会和标准库中的重合</p>
<p>变量命名规范：</p>
<ol>
<li>标识符要体现其实际含义。</li>
<li>变量名一般用小写字母。</li>
<li>用户自定义的类型一般以大写字母开头。</li>
<li>包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。</li>
</ol>
<p>对于嵌套作用域，可以在内层作用域中重新定义外层作用域已有的名字，但是最好不要这样做。</p>
<h2 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h2><p>同一个名字在不同的作用域可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在作用域末端结束</p>
<blockquote>
<p>[!NOTE] 第一次使用变量时定义它<br>有助于更容易找到定义，也可以帮助合理给定初值</p>
</blockquote>
<h3 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h3><p>作用域可以互相包含。</p>
<p>被包含的作用域称为内层作用域（inner scope），包含其他作用域的作用域称为外层作用域（outer scope）。</p>
<p>一旦在作用域中声明了名字，嵌套在该作用域内部的作用域就可以使用该名字。在外层作用域中声明的名称也可以在内层作用域中重新定义。取最近的定义作为访问的对象</p>
<blockquote>
<p>[!NOTE] scope operator<br>:: 可以用于在内层访问全局变量</p>
</blockquote>
<p>下面是一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line">	<span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line">	<span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">	std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p>复合类型就是基于其他类型定义的类型，引用和指针是其中两种</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是给对象起的别名。初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。</p>
<p>引用必须初始化。引用的初始值必须是一个对象，不能是字面值。引用只能绑定同类型对象。</p>
<p>对引用的所有操作都是对与之绑定的对象的操作。</p>
<p>引用非对象。因此不能定义对引用的引用</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在块作用域内，指针如果没有被初始化，值将不确定。</p>
<p>指针必须指向指定的类型，不能指向其他类型。<strong>这是严格的，哪怕是long和int都是不能互相指向的</strong></p>
<p>指针与引用的不同：</p>
<ul>
<li>指针是一个对象而引用不是；</li>
<li>指针可以重新赋值，而引用不行</li>
<li>有指向指针的指针，无引用的引用</li>
<li>指针不需要在定义时赋初值，而引用需要<br>不能定义指向引用的指针。可以定义指向指针的引用。</li>
</ul>
<blockquote>
<p>[!NOTE] 根本原因<br>指针是对象，而引用不是、指针指向的是对象，而引用也只能引用对象</p>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种定义空指针的方式。最好用第一种</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">nullptr</span>;  </span><br><span class="line"><span class="type">int</span> *p = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure>

<p>建议初始化所有指针。</p>
<p>非零指针对应的条件值是 ture，零指针对应的条件值是 false。</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3><p>void* 指针和空指针不是一回事。</p>
<p>void* 指针是特殊的指针类型，可以存放任意对象的地址。</p>
<p>一般来说，使用 void* 指针将内存作为内存来处理，而不是使用指针来访问存储在内存中的对象</p>
<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><p>const 对象必须初始化，因为一旦创建就不能再改变值。</p>
<p>默认情况下，const 对象仅在文件内有效。因此你可以在多个文件中定义多个相同名字的const 对象</p>
<p>如果想在多个文件间共享 const 对象，必须在变量的定义前添加 extern 关键字并在本文件中声明。声明和定义都要加 extern。</p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>常量引用不是说引用是常量，因为引用本来就只能绑定一个对象，而是引用不能改变引用的对象值。</p>
<p>常量引用可以绑定const对象，也可以绑定非常量对象。但是无论哪种，都不能通过引用去修改绑定的对象的值了。</p>
<p><strong>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。</strong></p>
<p>之前我们提到过：引用的类型必须与其所引用对象的类型一致，但是有两个例外。其中一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</p>
<blockquote>
<p>[!NOTE] 原理<br>实际上是创建了一个临时对象让常量引用绑定，也因此不能通过常量引用修改对象的值</p>
</blockquote>
<h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><p>指向常量的指针既可以指向常量也可以指向非常量，和常量引用一样，也不能通过指向常量的指针修改对象的值</p>
<p>至于具体作为常量的指针和指向常量的指针，我们在下一小节介绍</p>
<h2 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h2><p>顶层 const 表示指针本身是个常量，底层 const 表示指针所指的对象是一个常量。顶层 const 对任何数据类型通用，底层 const 只用于引用和指针。</p>
<p>顶层 const 的指针表示该指针是 const 对象，因此必须初始化。底层 const 的指针则不用。</p>
<p>实际上只有指针类型既可以是顶层 const 也可以是底层 const，因为引用实际上只能是底层 const，常量引用即为底层 const，不存在顶层 const 的引用。</p>
<p><strong>从右向左读来判断是顶层 const 还是底层 const。</strong></p>
<p>对于指针和引用而言，顶层 const 在右边，底层 const 在左边。对于其他类型，全都是顶层 const</p>
<p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2 = &amp;c; <span class="comment">// 这是一个底层const，允许改变 p2 的值 </span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">// 这是一个顶层const，不能改变 p1 的值</span></span><br></pre></td></tr></table></figure>

<p>执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。而顶层const会被忽略。</p>
<h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p>字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。</p>
<h3 id="cosntexpr变量"><a href="#cosntexpr变量" class="headerlink" title="cosntexpr变量"></a>cosntexpr变量</h3><p>在实际应用中很难分辨一个初始值是否是常量表达式，通过将变量声明为 constexpr 类型即可由编译器来检查。</p>
<p>由 constexpr 声明的变量必须用常量表达式初始化。</p>
<p>建议：如果认定一个变量是常量表达式，就把它声明为 constexpr 类型。</p>
<p>新标准允许定义 constexpr，这种函数应该足够简单以使得编译时就可以计算其结果。</p>
<p>不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化 constexpr 变量。</p>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>算术类型、引用、指针都属于字面值类型，自定义类则不属于。</p>
<p>cosntexpr 指针的初始值必须是 nullptr 或 0 或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。</p>
<p>注意区分 constexpr 和 const 。constexpr 都是顶层 const，仅对指针本身有效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// p 是一个指向整型常量的指针 </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q 是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h3 id="const和constexpr区别"><a href="#const和constexpr区别" class="headerlink" title="const和constexpr区别"></a>const和constexpr区别</h3><p>constexpr 限定了变量是编译器常量，即变量的值在编译器就可以得到。</p>
<p>const 则并未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只是初始化后就不能再改变了。</p>
<p><strong>constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。</strong></p>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>有以下两种方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">// 使用 typedef 关键字 </span></span><br><span class="line"><span class="keyword">using</span> wages = <span class="type">double</span>; <span class="comment">// 使用 using 关键字进行别名声明</span></span><br></pre></td></tr></table></figure>
<p>和其他声明语句一样，typedef 的声明语句中也可以包含类型修饰符，从而构造复合类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 是 double 的别名，p 是 double* 的别名。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 带有指针的别名<br><code>typedef char* pstring; const pstring cstr = 0;</code><br> 注意：cstr是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr &#x3D; 0，按后者的话，cstr是一个指向常量的指针。这是错误的。</p>
</blockquote>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto 说明符让编译器根据初始值来分析表达式所属的类型。</p>
<p>auto 可以在一条语句中声明多个变量，但是多个变量将会是同一个基本数据类型</p>
<p><strong>编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：</strong></p>
<ol>
<li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li>
<li>auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。</li>
<li>auto 会保留底层 const。</li>
</ol>
<p>下面给出一些例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>, &amp;cr = ci; </span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b 是一个普通的 int。 </span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c 是一个普通的 int。 </span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> d = ci; <span class="comment">// d 是一个 const int </span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">// e 是一个指向常量的引用（常量引用是底层 const）。注意这个微妙的地方。 </span></span><br><span class="line"><span class="keyword">auto</span> f = &amp;ci; <span class="comment">// f 是一个 const int*（位于左边的 const 是底层 const）</span></span><br></pre></td></tr></table></figure>

<p><strong>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用</strong></p>
<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>当希望获得表达式的类型但是不要计算值的时候，可以使用类型说明符 decltype。</p>
<p>如果 decltype 使用的表达式是一个变量，则它返回该变量的类型（包括顶层 const 和引用在内）。</p>
<p>decltype 与 auto 的不同：decltype 不会忽略引用和顶层 const。</p>
<p>注意当获得的类型是引用时，必须初始化。</p>
<h3 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h3><p>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。可以使用这种方式来保证不获取引用类型。</p>
<p>注意解引用指针的结果是一个引用类型。给变量加括号的结果也是引用类型。赋值操作的结果也是引用类型。</p>
<p><strong>decltype((var)) 的结果永远是引用，而 decltype(var) 的结果只有当 var 本身就是引用时才是引用。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, &amp;r = i, *p; </span><br><span class="line"><span class="keyword">decltype</span>(r<span class="number">+0</span>) b; <span class="comment">// b 的类型是 int，因为 r+0 的结果类型是 int。 </span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i; <span class="comment">// c 的类型是 int&amp;。 </span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = i; <span class="comment">// d 的类型是 int&amp;。</span></span><br><span class="line"><span class="keyword">decltype</span>(j = r<span class="number">+0</span>) b = i; <span class="comment">// d 的类型是 int&amp;。</span></span><br></pre></td></tr></table></figure>
<h1 id="自定义数据结构和引用"><a href="#自定义数据结构和引用" class="headerlink" title="自定义数据结构和引用"></a>自定义数据结构和引用</h1><h2 id="定义struct类型"><a href="#定义struct类型" class="headerlink" title="定义struct类型"></a>定义struct类型</h2><p>struct+类名+类体+分号。类体可以为空。</p>
<p><code>struct Sales_data&#123;&#125;; // 注意：结尾加分号</code></p>
<p>定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。</p>
<p>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</p>
<h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</p>
<p>头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。</p>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p>
<p>预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。</p>
<p>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</p>
<p>c++ 中包含三个头文件保护符：</p>
<ol>
<li>#define：把一个名字设定为预处理变量</li>
<li>#ifndef：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #endif 为止</li>
<li>#endif</li>
</ol>
<p>预处理变量无视作用域的规则，作用范围是文件内</p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>表达式</title>
    <url>/2025/06/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>一般二元运算符都要求两个运算对象的类型相同或者可以转换为相同类型</p>
<p>运算符作用于类类型的对象时，用户可以自行定义含义，即重载运算符。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>C++表达式要么是左值，要么是右值</p>
<ul>
<li>左值：当一个对象被用作左值时，用的是对象的身份（即内存中的位置）</li>
<li>右值：当一个对象被用作右值时，用的是对象的值</li>
</ul>
<p>右值可以用左值来代替，但是反过来不行</p>
<p>使用关键字 decltype 时，如果表达式的求值结果是左值，decltype 作用于该表达式（不是变量）得到一个引用类型</p>
<h2 id="优先级和结合律"><a href="#优先级和结合律" class="headerlink" title="优先级和结合律"></a>优先级和结合律</h2><p>左结合律：如果运算符优先级相同，按照从左到右的方式组合运算对象</p>
<p><strong>赋值运算符满足的是右结合律</strong></p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>在一个复合表达式中，各个运算对象的求值顺序是不固定的。</p>
<p><code>cout &lt;&lt; i &lt;&lt; ++i &lt;&lt; end;//错误！未定义的行为，不知道先求 i 还是先求 ++i</code></p>
<p>4种运算符明确规定了运算对象的求值顺序：逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)</p>
<p>处理复合表达式的两个建议：</p>
<ol>
<li>不确定优先级与结合律时使用括号</li>
<li>如果改变了某个运算对象的值，在同一表达式中不要再使用该运算对象。</li>
</ol>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>算术运算符有 3 组，按优先级从高到低依次是</p>
<ol>
<li>+、- ：一元正号与一元负号</li>
<li><ul>
<li>、&#x2F;、% ：乘法、除法、求余</li>
</ul>
</li>
<li>+、- ：加法、减法<br>注意一元正负号的优先级最高，求余也是一种算术运算。</li>
</ol>
<p>整数除法的结果是向零舍入。</p>
<p>求余运算符的运算对象必须是整数，运算结果始终与被除数符号相同</p>
<h1 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h1><ul>
<li>逻辑运算符：！、&amp;&amp;、||。逻辑运算符的作用对象必须是能转换成布尔值的类型</li>
<li>关系运算符：&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, !&#x3D;, &#x3D;&#x3D; ：大于小于的优先级高于等于和不等于</li>
</ul>
<p><strong>&amp;&amp;、||都是短路求值，即先求左值，若无法判定整体布尔值，再求右值</strong></p>
<h2 id="布尔字面值"><a href="#布尔字面值" class="headerlink" title="布尔字面值"></a>布尔字面值</h2><p>使用算术值做条件时直接用，不要与布尔值做比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a);<span class="comment">//正确 </span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="literal">true</span>);<span class="comment">//错误：会将 true 先转换为 int 再比较，比较结果是不相等</span></span><br></pre></td></tr></table></figure>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>赋值运算符的左侧对象必须是一个可修改的左值</p>
<p>C++ 11 允许使用花括号括起来的初始值列表作为右侧运算对象。初始化列表可以为空，此时将进行值初始化。</p>
<p>赋值运算符满足右结合律。同时优先级较低</p>
<p>复合赋值运算符只求值一次，而普通运算符需要两次。(a&#x3D;a+1 要先求一次 a+1，再将结果赋值给 a)</p>
<p><code>+=; -=; *=; /=; %=; &lt;&lt;=; &gt;&gt;=; &amp;=; ^=; |=;</code></p>
<h1 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h1><h2 id="前置版本"><a href="#前置版本" class="headerlink" title="前置版本"></a>前置版本</h2><p>首先将运算对象加1，再将改变后的对象作为求值结果</p>
<h2 id="后置版本"><a href="#后置版本" class="headerlink" title="后置版本"></a>后置版本</h2><p>也是将运算对象加 1，但是求值结果是运算对象改变之前那个值的副本</p>
<blockquote>
<p>[!NOTE] 关键区别<br>前置版本将对象本身作为左值返回，后置版本将对象的原始值的副本返回。</p>
<p>前置版本直接返回改变了的运算对象，后置版本需要将原始值保存下来以便于返回，是一种浪费。</p>
<p>整体而言，后置版本对于整数和指针来说影响不大，但是对于迭代器而言消耗巨大</p>
</blockquote>
<h2 id="在一条语句中混用解引用和递增运算符"><a href="#在一条语句中混用解引用和递增运算符" class="headerlink" title="在一条语句中混用解引用和递增运算符"></a>在一条语句中混用解引用和递增运算符</h2><p><code>*p++</code> ：p++将 p 的值加一，然后返回 p 的初始值的副本作为求值结果用于解引用。(递增运算符优先级高于解引用)</p>
<p>这是一种提倡的写法，更加简洁，应该习惯于这种写法。</p>
<h1 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h1><p>对于一个指针而言，点运算符和箭头运算符都可以用来访问成员。</p>
<p><code>ptr-&gt;mem 等价于 (*ptr)-&gt;mem</code></p>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><p>cond ? expr1 : expr2。</p>
<p>可以嵌套使用<br><code>finalgrade = (grade&gt;90) ? &quot;high pass&quot; : (grade&lt;60) ? &quot;fail&quot; : &quot;pass&quot;;</code></p>
<p>条件运算符优先级非常低，一般都要加括号</p>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算符作用于整数类型的对象。</p>
<p>位运算符有六种：位求反、位与、位或、位异或、左移、右移</p>
<p><code>~a; a&amp;b; a|b; a^b; a&lt;&lt;2; a&gt;&gt;2</code></p>
<p>如果运算对象是个小整型，会被自动提升为较大的整型类型</p>
<p>可以带符号，也可以不带。如果不带，那么运算结果是固定的，否则要看机器</p>
<p><strong>左移操作处理带符号值是未定义行为</strong></p>
<p>在 C++ 中，建议仅用位运算符来处理无符号类型。</p>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>使用移位运算符，移动的位数必须严格小于结果的位数，否则会产生未定义的行为</p>
<p><code>&lt;&lt;</code>运算符在右侧插入 0，左侧移动超出边界的值舍弃掉。</p>
<p><code>&gt;&gt;</code>运算符处理无符号数时在左侧插入 0，右侧移动超出边界的值舍弃掉。</p>
<p><code>&gt;&gt;</code>运算符处理有符号数时可能在左侧插入 0 也可能插入符号位的副本，由机器决定使用哪种方式</p>
<p>标注IO库里重载了这两个运算符，使得可以接受输入输出流。</p>
<p>重载后满足左结合律</p>
<h2 id="位求反、位与、位或、位异或"><a href="#位求反、位与、位或、位异或" class="headerlink" title="位求反、位与、位或、位异或"></a>位求反、位与、位或、位异或</h2><p>这几种运算符处理 char 时，都会把 char 类型的运算对象首先零扩展提升成 int 类型再进行位运算。</p>
<h1 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h1><p>sizeof返回一个表达式或者一个类型名字所占的字节数，值为size_t类型</p>
<p>对数组执行sizeof运算将得到数组所占的空间，这里不会把数组转换为指针进行处理</p>
<p>对指针执行sizeof运算将得到指针类型的大小，8</p>
<p>如果对string或者vector执行sizeof只返回该类型固定部分的大小，不会计算对象中的元素占多少空间</p>
<blockquote>
<p>[!Hint] 可以用 sizeof 获得数组中元素的个数<br><code>sizeof(arr)/sizeof(*arr);//返回的是数组 arr 的元素数量</code></p>
</blockquote>
<h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><p>在 for 循环中可以用逗号分隔两个不同的条件，或者定义多个值（类型完全相同）<br><code>for(int i=0,j = 0; i!=n; i++,j++)</code></p>
<p><strong>注意，如果在条件判断的部分用逗号分割了若干部分，则只会返回最后一个条件判定的布尔值</strong></p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>c++ 不会直接将两个不同类型的值相加，会先通过类型转换把运算对象的类型统一后再求值</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><ul>
<li>比int类型小的整型值转换为int类型或者更大的整数类型</li>
<li>在条件里，把非布尔值转换成布尔值</li>
<li>初始化过程中，初始值转换为变量的类型</li>
<li>赋值时，右侧运算对象转换成左侧类型</li>
<li>算数运算或关系运算的运算对象有多种类型，转换成一种（一般取最宽的那种）</li>
</ul>
<h2 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h2><p>整型提升把小整数类型（包括 char、bool等）转换成较大的整数类型。如果 int 可以就转换成 int，否则提升成 unsigned int 类型</p>
<p>如果一个是无符号一个带符号。如果无符号类型不小于带符号类型（比如都是 4 字节），则带符号转换为无符号</p>
<p>如果无符号类型小于带符号，转换结果依赖机器。尽量避免这种操作。</p>
<h2 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h2><ol>
<li>数组转换为指针：大多数情况下数组自动转换成指向数组首元素的指针。（decltype关键字参数、取地址符(&amp;)、sizeof、typeid都不会发生这种转换）</li>
<li>指针的转换：0 或 nullptr 都能转换成任意指针类型。指向非常量的指针能转换成 void*。指向所有对象的指针都能转换成 const void*</li>
<li>转换成常量：指向非常量的指针转换成指向相应常量类型的指针</li>
<li>类类型的转换：<ol>
<li><code>while(cin&gt;&gt;s);//将 cin 转换为 bool 值</code></li>
<li><code>string s = &quot;value&quot;;//将 c 风格字符串转换为 string</code></li>
</ol>
</li>
</ol>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p>使用强制类型转换，非常危险，一般考虑能否用其他方式避免</p>
<p><code>castname&lt;type&gt;(expression);</code></p>
<p>有以下四种：</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static cast"></a>static cast</h3><p>任何类型转换，只要不包含底层const，都可以用static cast</p>
<p><code>double slope = static_cast&lt;double&gt;(j)/i; //将 j 转换成 double 以便执行浮点数除法</code></p>
<p>当把较大的类型转换为较小的类型时，static_cast 很有用。这时它告诉读者和编译器：我们知道且不在乎精度损失。平时编译器会给警告，显式转换后就不警告了</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const cast"></a>const cast</h3><p>只能改变对象的底层const，可以去掉或增加const性质</p>
<p>只有const cast可以改变表达式的常量属性，其他均不可以</p>
<p>cosnt_cast 常用于有函数重载的上下文中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; s; </span><br><span class="line"><span class="keyword">const_cast</span> &lt;<span class="type">const</span> string&amp;&gt; (s);<span class="comment">// 将 s 转换为常量引用 </span></span><br><span class="line"><span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);<span class="comment">// 将 s 转换回非常量引用</span></span><br></pre></td></tr></table></figure>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>依赖于机器，门槛高而且危险，不要用</p>
<h3 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h3><p>本质上采用 const_cast、static_cast 或 reinterpret_cast 中的一种。</p>
<p>旧式与新式相比没那么清晰明了，如果出现问题，追踪困难</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(a);<span class="comment">// 函数形式的强制类型转换 </span></span><br><span class="line">(<span class="type">int</span>)a;<span class="comment">// c 语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure>
<h1 id="附录：优先级表"><a href="#附录：优先级表" class="headerlink" title="附录：优先级表"></a>附录：优先级表</h1><p><img src="https://tc.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250903/ZzOK/627X605/priority_level_1.png" alt="627X605&#x2F;priority_level_1.png"></p>
<p><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250903/N7CE/631X880/priority_level_2.png" alt="631X880&#x2F;priority_level_2.png"></p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>线程模块-知识储备</title>
    <url>/2024/07/01/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97-%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<p>先做一点基础的线程知识介绍（也算刚考完试做个总结）</p>
<span id="more"></span>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251005/ULgi/1536X1024/memory_level.png" alt="1536X1024&#x2F;memory_level.png"></p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>假设CPU要读取某个内存地址的数据：</p>
<h3 id="寄存器检查"><a href="#寄存器检查" class="headerlink" title="寄存器检查"></a>寄存器检查</h3><ul>
<li>CPU首先查看这个数据是不是已经在<strong>寄存器</strong>里（最快的存储单元）。</li>
<li>若在寄存器中，直接读取，延迟极低（几个时钟周期内）。</li>
</ul>
<h3 id="L1-Cache（一级缓存）"><a href="#L1-Cache（一级缓存）" class="headerlink" title="L1 Cache（一级缓存）"></a>L1 Cache（一级缓存）</h3><ul>
<li>若寄存器没有，CPU从<strong>L1 Cache</strong>中查找。</li>
<li>L1分为两部分：<strong>L1D（数据）</strong> 和 <strong>L1I（指令）</strong></li>
<li>命中（Hit）：直接读取。</li>
<li>未命中（Miss）：进入下一级。</li>
</ul>
<h3 id="L2-Cache（二级缓存）"><a href="#L2-Cache（二级缓存）" class="headerlink" title="L2 Cache（二级缓存）"></a>L2 Cache（二级缓存）</h3><ul>
<li>查找L2 Cache（比L1大、速度稍慢）。</li>
<li>若命中，则把数据传回CPU，并且通常也更新L1。</li>
</ul>
<h3 id="L3-Cache（三级缓存）"><a href="#L3-Cache（三级缓存）" class="headerlink" title="L3 Cache（三级缓存）"></a>L3 Cache（三级缓存）</h3><ul>
<li>若L2未命中，CPU访问共享的<strong>L3 Cache</strong>（多核共享，容量更大）。</li>
<li>命中：把数据拷回L2和L1供CPU使用</li>
</ul>
<h3 id="主存（DRAM）"><a href="#主存（DRAM）" class="headerlink" title="主存（DRAM）"></a>主存（DRAM）</h3><ul>
<li>如果三级缓存都未命中（称为“三次Cache Miss”），CPU才会：<ul>
<li>通过**内存控制器（Memory Controller）**访问主存（DRAM）。</li>
<li>主存的访问延迟可达几百个时钟周期（相对Cache非常慢）。</li>
<li>数据取回后，会先填充到各级Cache，再给CPU使用。</li>
</ul>
</li>
</ul>
<h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>如果内存中也没有，即涉及到键盘等输入或者就是需要从磁盘读取，则需要继续访问SSD</p>
<h3 id="表格所示"><a href="#表格所示" class="headerlink" title="表格所示"></a>表格所示</h3><table>
<thead>
<tr>
<th>层级</th>
<th>访问延迟（时钟周期）</th>
<th>容量</th>
<th>速度</th>
<th>成本</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1</td>
<td>极小</td>
<td>极快</td>
<td>极高</td>
</tr>
<tr>
<td>L1 Cache</td>
<td>2–4</td>
<td>数十 KB</td>
<td>很快</td>
<td>高</td>
</tr>
<tr>
<td>L2 Cache</td>
<td>10–20</td>
<td>数百 KB</td>
<td>快</td>
<td>中高</td>
</tr>
<tr>
<td>L3 Cache</td>
<td>30–60</td>
<td>数 MB</td>
<td>较慢</td>
<td>中</td>
</tr>
<tr>
<td>主存 (DRAM)</td>
<td>100–300</td>
<td>GB级</td>
<td>慢</td>
<td>低</td>
</tr>
<tr>
<td>SSD&#x2F;HDD</td>
<td>10⁵–10⁷</td>
<td>TB级</td>
<td>极慢</td>
<td>极低</td>
</tr>
</tbody></table>
<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><p>CPU时间片是指操作系统调度程序为每个可运行进程分配的一段<strong>固定长度的CPU时间</strong>。</p>
<ul>
<li>当进程在这段时间内<strong>未执行完</strong>，操作系统会<strong>剥夺其CPU使用权</strong>，将其放回就绪队列；</li>
<li>然后CPU切换到下一个进程；</li>
<li>如果进程在时间片内<strong>执行完毕</strong>，则主动释放CPU</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，</p>
<p>然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。<br>这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<h1 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h1><p>只是稍微介绍一下概念以及几种锁的种类，深入了解请移步并发编程的部分</p>
<h2 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h2><p>进程是操作系统分配资源的基本单位，每个进程独享属于自己的文件描述符、存储器资源等等。</p>
<p>线程是操作系统进行调度的基本单位，一个进程可以有多个线程，线程之间是共享所属进程的资源的。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥是进程(线程)之间的间接制约关系。</p>
<p>当一个进程(线程)进入临界区使用临界资源时，另一个进程(线程)必须等待。 只有当使用临界资源的进程(线程)退出临界区后，这个进程(线程)才会解除阻塞状态。</p>
<blockquote>
<p>[!NOTE] 临界资源<br>对于某些资源来说，其在同一时间只能被一个进程所占用。 这些一次只能被一个进程所占用的资源就是所谓的临界资源。</p>
</blockquote>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步是进程(线程)之间的直接制约关系。 </p>
<p>是指多个相互合作的进程(线程)之间互相通信、互相等待，这种相互制约的现象称为进程(线程)的同步</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>我觉得在并发管理中应该认为<code>mutex</code>是互斥量，当上锁后才是互斥锁</p>
<p>这是最基础的锁。<code>std::mutex</code> 保证在任何时刻，只有一个线程能够获得锁，从而进入由它保护的临界区（Critical Section）。</p>
<p><strong>特点</strong>:</p>
<ul>
<li>独占式：一个线程获取锁之后，其他线程必须等待它释放锁。</li>
<li>非递归：同一个线程不能在释放之前再次获取同一个 <code>std::mutex</code>，否则会造成死锁。</li>
</ul>
<p><strong>使用方法</strong>: 直接调用 <code>lock()</code> 和 <code>unlock()</code> 方法。但这种方式很危险，如果在 <code>lock()</code> 和 <code>unlock()</code>  之间发生异常，<code>unlock()</code> 将不会被调用，导致锁无法释放，所有等待该锁的线程都会被永久阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; // 创建一个互斥锁实例</span><br><span class="line">int shared_counter = 0;</span><br><span class="line"></span><br><span class="line">void increment() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">        mtx.lock(); // 获取锁</span><br><span class="line"></span><br><span class="line">        // --- 临界区开始 ---</span><br><span class="line"></span><br><span class="line">        shared_counter++;</span><br><span class="line"></span><br><span class="line">        // --- 临界区结束 ---</span><br><span class="line"></span><br><span class="line">        mtx.unlock(); // 释放锁</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(increment);</span><br><span class="line">    std::thread t2(increment);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Shared counter: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl; // 输出应该是 20000</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><strong>条件变量（Condition Variable）</strong> 是一种<strong>线程间通信机制</strong>，允许一个线程在某个条件不满足时<strong>进入等待状态（阻塞）</strong>，直到另一个线程<strong>通知它条件已满足</strong>。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cv.wait(lock)</code></td>
<td>线程阻塞，并释放锁</td>
</tr>
<tr>
<td><code>cv.notify_one()</code></td>
<td>唤醒一个等待线程</td>
</tr>
<tr>
<td><code>cv.notify_all()</code></td>
<td>唤醒所有等待线程</td>
</tr>
<tr>
<td>必须持有锁</td>
<td>修改条件变量所依赖的共享状态时，必须先加锁</td>
</tr>
<tr>
<td>防止伪唤醒</td>
<td>使用 <code>cv.wait(lock, predicate)</code> 版本更安全</td>
</tr>
<tr>
<td>典型用途</td>
<td>生产者-消费者模型、线程池任务队列等</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件成立</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;条件满足，开始执行任务\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>C++ 标准库<strong>早期（C++11、C++14、C++17）没有内置信号量</strong>，但从 <strong>C++20</strong> 开始，标准库正式引入了 <strong>信号量（<code>std::counting_semaphore</code> 和 <code>std::binary_semaphore</code>）</strong>。</p>
<hr>
<h3 id="标准信号量"><a href="#标准信号量" class="headerlink" title="标准信号量"></a>标准信号量</h3><p>头文件：<code>#include &lt;semaphore&gt;</code></p>
<h4 id="1-std-counting-semaphore"><a href="#1-std-counting-semaphore" class="headerlink" title="1. std::counting_semaphore"></a>1. <code>std::counting_semaphore</code></h4><ul>
<li>是通用的<strong>计数信号量</strong>。</li>
<li>内部有一个整型计数器，控制可用资源数。<br>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span>  </span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;3&gt; <span class="title">sem</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 最大资源数3，初始值3  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;     </span><br><span class="line">	sem.<span class="built_in">acquire</span>(); <span class="comment">// P操作，尝试获取资源    </span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; working\n&quot;</span>;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));     </span><br><span class="line">	sem.<span class="built_in">release</span>(); <span class="comment">// V操作，释放资源 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(task, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(task, <span class="number">2</span>)</span>, <span class="title">t3</span><span class="params">(task, <span class="number">3</span>)</span>, <span class="title">t4</span><span class="params">(task, <span class="number">4</span>)</span></span>;     </span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>(); t<span class="number">3.</span><span class="built_in">join</span>(); t<span class="number">4.</span><span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最多同时有3个线程能执行“工作”，第4个线程会阻塞直到有资源释放。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-std-binary-semaphore"><a href="#2-std-binary-semaphore" class="headerlink" title="2. std::binary_semaphore"></a>2. <code>std::binary_semaphore</code></h4><ul>
<li>相当于最大计数为 1 的信号量，也就是“二元信号量”（互斥信号量）。</li>
<li>类似于互斥锁，但可以手动 release，而不需要RAII封装。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="function">std::binary_semaphore <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;     </span><br><span class="line">	sem.<span class="built_in">acquire</span>();     </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; in critical section\n&quot;</span>;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); </span><br><span class="line">	sem.<span class="built_in">release</span>(); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(work, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(work, <span class="number">2</span>)</span></span>;     </span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁是一对互斥锁，分为读锁和写锁。 </p>
<p>读锁和写锁互斥，让一个线程在进行读操作时，不允许其他线程的写操作，但是不影响其他线程的读操作。 当一个线程在进行写操作时，不允许任何线程进行读操作或者写操作。</p>
<blockquote>
<p>[!NOTE] 使用<br>考虑到RAII，虽然读写锁本身提供了对应的加锁和解锁方式，但是还是用提供的RAII锁类，帮助<br>自动管理锁的获取与释放</p>
</blockquote>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>对应操作</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::unique_lock&lt;std::shared_mutex&gt;</code></td>
<td>写锁</td>
<td>独占修改数据</td>
</tr>
<tr>
<td><code>std::shared_lock&lt;std::shared_mutex&gt;</code></td>
<td>读锁</td>
<td>并发只读访问</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁是一种<strong>忙等待锁（busy waiting lock）</strong>：</p>
<ul>
<li>当线程尝试获取锁时，如果锁已被占用，它<strong>不会挂起（不睡眠）</strong>，<br>  而是一直<strong>在循环中检查锁是否可用</strong>。</li>
<li>直到锁可用时立即获取，从而<strong>避免线程上下文切换</strong>的开销。</li>
</ul>
<p>适合场景：</p>
<ul>
<li>锁持有时间极短；</li>
<li>线程数量少；</li>
<li>临界区工作量小；</li>
<li>不希望发生线程切换。<br>不适合：</li>
<li>临界区耗时较长；</li>
<li>核心数量较少（容易浪费CPU）。</li>
</ul>
<p>没有提供标准库实现，但是可以通过<code>atomic_flag</code>实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果锁被其他线程持有，则等待（自旋）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in the critical section.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.<span class="built_in">clear</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(critical_section)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>线程模块-代码</title>
    <url>/2024/07/04/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="pthread的封装"><a href="#pthread的封装" class="headerlink" title="pthread的封装"></a>pthread的封装</h1><h2 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h2><p>首先我们主要是面向对象编程。面向对象编程有三个特点：【封装】、【继承】、【多态】。</p>
<p>这里封装pthread是为了使用上更方便，因为虽然pthread提供了以下的一些功能：【Thread】,【Semaphore】,【Mutex】,【RWMutex】,【Spinlock】等</p>
<p>但是都是最基本的功能，而我们开发中往往是多个功能相互结合相互配合着来使用的。</p>
<p>这里封装是为了提供一些新的功能接口供方便使用</p>
<h2 id="thread-h"><a href="#thread-h" class="headerlink" title="thread.h"></a>thread.h</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Thread</span>(std::function&lt;<span class="built_in">void</span>()&gt; cb, <span class="type">const</span> std::string&amp; name);</span><br><span class="line">	~<span class="built_in">Thread</span>();</span><br><span class="line">	<span class="function"><span class="type">pid_t</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;<span class="comment">// 线程ID</span></span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;<span class="comment">//线程结合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 获取系统分配的线程id</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">pid_t</span> <span class="title">GetThreadId</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取当前所在线程	</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Thread* <span class="title">GetThis</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取当前线程的名字</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 设置当前线程的名字</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 线程函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">run</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">pid_t</span> m_id = <span class="number">-1</span>;<span class="comment">//进程的id</span></span><br><span class="line">	<span class="type">pthread_t</span> m_thread = <span class="number">0</span>;<span class="comment">//线程</span></span><br><span class="line">	<span class="comment">// 线程需要运行的函数</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; m_cb;</span><br><span class="line">	std::string m_name;<span class="comment">//线程的name</span></span><br><span class="line">	Semaphore m_semaphore;<span class="comment">//引入信号量的类来完成线程的同步创建。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里涉及到的信号量封装会在后面介绍</p>
<h2 id="thread-cpp"><a href="#thread-cpp" class="headerlink" title="thread.cpp"></a>thread.cpp</h2><p>初始化时通过pthread_create()绑定run函数为线程的入口函数。</p>
<p>在这里run方法负责初始化线程和真正调用线程需要运行任务(函数对象cb)，</p>
<p>使用Semaphore类控制线程初始化的同步，保证所有的线程都能初始化，防止未初始化的线程出现，</p>
<p>GetThreadId()主要是使用系统调用获取真实的线程id，和getpid()返回的线程ID是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycoroutine &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程信息</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> Thread* t_thread          = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> std::string t_thread_name = <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Thread::GetThreadId</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">syscall</span>(SYS_gettid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Thread* <span class="title">Thread::GetThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">Thread::GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_thread_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::SetName</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_thread) &#123;</span><br><span class="line">        t_thread-&gt;m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    t_thread_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(std::function&lt;<span class="built_in">void</span>()&gt; cb, <span class="type">const</span> std::string &amp;name): </span><br><span class="line"><span class="built_in">m_cb</span>(cb), <span class="built_in">m_name</span>(name) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将新创建线程的入口函数绑定到run</span></span><br><span class="line">    <span class="type">int</span> rt = <span class="built_in">pthread_create</span>(&amp;m_thread, <span class="literal">nullptr</span>, &amp;Thread::run, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (rt) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;pthread_create thread fail, rt=&quot;</span> &lt;&lt; rt &lt;&lt; <span class="string">&quot; name=&quot;</span> &lt;&lt; name;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程函数完成初始化</span></span><br><span class="line">    m_semaphore.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构时对线程分离以确定会自动销毁</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_thread) &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread);</span><br><span class="line">        m_thread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_thread) &#123;</span><br><span class="line">	    <span class="comment">// 因为不关心返回值去哪，所以直接设置为nullptr</span></span><br><span class="line">        <span class="type">int</span> rt = <span class="built_in">pthread_join</span>(m_thread, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;pthread_join failed, rt = &quot;</span> &lt;&lt; rt &lt;&lt; <span class="string">&quot;, name = &quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;pthread_join error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止后续再次被join</span></span><br><span class="line">        m_thread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Thread::run</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    Thread* thread = (Thread*)arg;</span><br><span class="line"></span><br><span class="line">    t_thread       = thread;</span><br><span class="line">    t_thread_name  = thread-&gt;m_name;</span><br><span class="line">    thread-&gt;m_id   = <span class="built_in">GetThreadId</span>();</span><br><span class="line">    <span class="comment">//pthread_self()获取当前线程的ID，设置m_name是前15个字节取，因为linux设置最多15</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(<span class="built_in">pthread_self</span>(), thread-&gt;m_name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">15</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; cb;</span><br><span class="line">    cb.<span class="built_in">swap</span>(thread-&gt;m_cb); <span class="comment">// swap -&gt; 可以减少m_cb中只能指针的引用计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化完成</span></span><br><span class="line">    thread-&gt;m_semaphore.<span class="built_in">signal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="static-thread-local又是什么意思？"><a href="#static-thread-local又是什么意思？" class="headerlink" title="static thread_local又是什么意思？"></a>static thread_local又是什么意思？</h2><p>static代表生命周期知道程序运行结束时候销毁，<strong>被 <code>thread_local</code> 修饰的变量，在每个线程中都有一个独立的副本</strong>。</p>
<h2 id="对pthread-create、pthread-detch、pthread-join的详解"><a href="#对pthread-create、pthread-detch、pthread-join的详解" class="headerlink" title="对pthread_create、pthread_detch、pthread_join的详解"></a>对pthread_create、pthread_detch、pthread_join的详解</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><p>&#96;int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (<em>start_rtn)(void</em>),void *restrict arg);</p>
<ul>
<li>输入参数： tidp:填入pthread_t类型参数。  </li>
<li>attr:通常设置为NULL，用于定制各种不同的线程属性。  </li>
<li>start_rtn:新创建线程的入口函数由此绑定。无参数把arg设置为NULL即可  </li>
<li>返回值：成功返回0，否则返回错误码。</li>
</ul>
<p>线程的入口函数最开始都要先获取传入的参数:&#96;比如pthread_create(&amp;m_thread, nullptr, &amp;Thread::run, this);</p>
<p>在run函数里先执行&#96;Thread* thread &#x3D; (Thread*)arg;</p>
<h3 id="pthread-detch"><a href="#pthread-detch" class="headerlink" title="pthread_detch"></a>pthread_detch</h3><p>目的是为了确保线程在结束后能够正确的释放资源，而不需要主线程或其他线程进行join操作。一般适用的场景是在子线程要脱离主线程的管理，并且主线程不需要担心其资源的释放，简化了使用的复杂性。  </p>
<p>避免了内存泄漏防止忘记调用join导致的内存泄露  </p>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>pthread_Join是POSIX线程库的一个函数，用于等待一个线程的终止并回收它的资源  </p>
<p>值得说的一点就是一般都可以写nullptr。如果你需要接受某个实际的值，那就写一个实际的指针去接受它。</p>
<h1 id="信号量的封装"><a href="#信号量的封装" class="headerlink" title="信号量的封装"></a>信号量的封装</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;                </span><br><span class="line">    std::condition_variable cv;    </span><br><span class="line">    <span class="type">int</span> count;                   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 信号量初始化为0</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Semaphore</span><span class="params">(<span class="type">int</span> count_ = <span class="number">0</span>)</span> : count(count_) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// P操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123; </span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// wait for signals</span></span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// V操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();  <span class="comment">// signal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>语句</title>
    <url>/2024/06/07/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h1><h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>一个表达式加一个分号就是一个表达式语句，其执行表达式并丢弃掉求值结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ival + <span class="number">3</span>;<span class="comment">//一条没有实际用处的表达式语句 </span></span><br><span class="line">cout &lt;&lt; ival;<span class="comment">//一条有用的表达式语句</span></span><br></pre></td></tr></table></figure>
<h2 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h2><p>空语句是最简单的语句，只有一个分号</p>
<p>用在语法上需要一条语句，但是逻辑上不需要的地方。</p>
<p>使用空语句块最好加注释</p>
<h2 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h2><p>用花括号括起来的语句和声明序列都是复合语句（块），一个复合语句（块）就是一个作用域</p>
<p>空块的作用等价于一个空语句</p>
<h1 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h1><p>可以在 if、switch、while、for 语句的控制结构内定义变量。</p>
<p>这些定义的变量只能在这些语句的复合语句中使用</p>
<p>常见的语句有条件语句、循环语句、跳转语句三种。</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if 语句有两种形式，一种有 else 分支，另一种没有。</p>
<p>c++ 规定 else 与离他<strong>最近的在同一作用域的尚未匹配的</strong> if 匹配</p>
<p>使用 if 语句最好在所有的 if 和 else 之后都用花括号</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch 语句计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。如果没有任何一个 case 标签匹配 switch 表达式的值，就执行 default 分支。</p>
<p>case 关键字和它对应的值一起被称为 case 标签，case 标签必须为<strong>整型常量表达式</strong>。</p>
<p>default 也是一种特殊的 case 标签。</p>
<p>注意：如果switch条件值在某个case标签满足后，程序将从该case标签一直执行到switch末尾或者遇到第一个break。因此一般在每个 case标签后都有一条 break 语句。如果需要两个或多个值共享同一组操作，可以故意省略掉 break 语句</p>
<p>一条switch语句后可以跟多条语句，而不需要花括号</p>
<blockquote>
<p>[!NOTE] 为了代码的可阅读性，一般有以下规范<br>一般不要省略 case 分支最后的 break 语句。如果没有 break 语句，最好注释一下。</p>
<p>即使不准备在 default 下做任何工作，最好也定义一个 default 标签。</p>
<p>如果要在 case 分支定义并初始化变量，应该定义在块内以约束其作用域</p>
</blockquote>
<h1 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h1><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>其条件不能为空，可以是一个表达式或者带初始化的变量声明</p>
<p>定义在条件部分或者循环体内的变量每次迭代都会重新创建和销毁</p>
<p>一般使用于不知道多少次的循环</p>
<h2 id="传统for语句"><a href="#传统for语句" class="headerlink" title="传统for语句"></a>传统for语句</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement; condition; expression) </span><br><span class="line">	statement;</span><br></pre></td></tr></table></figure>
<p>init-statement 可以是声明语句、表达式语句或空语句。init-statement 可以定义多个对象，但是只能有一条声明语句。</p>
<p>expression 在每次循环之后执行。</p>
<p>for 语句头能省略掉三者中的任意一个或全部。</p>
<p>如果省略 condition ，条件恒为 true。</p>
<h2 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h2><p>用来遍历<strong>容器或其他序列</strong>的所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : expression) </span><br><span class="line">	statement;</span><br></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列（可以是用花括号括起来的初始值列表）。共同特点的是都可以返回迭代器的 begin 和 end 成员</p>
<p>declaration定义一个能从序列中元素转换而来的变量（<strong>不是迭代器</strong>），最简单的方法为用auto</p>
<p>如果需要执行写操作，必须将循环变量声明成引用类型。不需要写时最好都声明为常量引用</p>
<p>每次迭代都会重新定义循环控制变量，并将其初始化为序列的下一个值。</p>
<p><strong>绝对不要在范围 for 语句改变序列的元素数量</strong>。因为其预存了 end() 的值，改变元素数量后 end() 的值就可能失效了</p>
<h2 id="dowhile语句"><a href="#dowhile语句" class="headerlink" title="dowhile语句"></a>dowhile语句</h2><p>do while 语句与 while 语句的唯一区别就是它先执行循环体后检查条件。即至少执行一次循环。</p>
<p>注意：do while 后不要忘了加分号。</p>
<p>因为 condition 在循环体后面，所以 condition 使用的变量应该定义在循环体外面。</p>
<h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h1><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>终止离它最近的 while、do while、for 或 switch 语句，并从这些语句之后的第一条语句开始执行。</p>
<p>break 语句只能出现在迭代语句或 switch 内部</p>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>终止最近的循环中的当前迭代并开始下一次迭代。</p>
<p>continue 只能出现在迭代语句内部</p>
<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>作用是从 goto 语句无条件跳转到同一函数内的另一条语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">label: <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>
<p>label 是用于标识一条语句的标示符</p>
<p>标签标示符独立于变量或其他标示符的名字，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</p>
<p>如果 goto 语句跳回了一条变量的定义之前意味着系统将会销毁该变量，然后重新创建它。</p>
<p><strong>不要使用 goto，它会令程序又难理解又难修改</strong></p>
<h1 id="try和异常处理"><a href="#try和异常处理" class="headerlink" title="try和异常处理"></a>try和异常处理</h1><p>异常是指存在于运行时的反常行为，典型的有失去数据库连接和意外输入等等。</p>
<p><strong>处理异常可能是最难的部分</strong></p>
<p>当程序检测到一个无法处理的问题时，就需要异常处理，此时检测到问题的部分应该发出检测信号。</p>
<p>如果程序里有可能引发异常的代码，也应该有专门的代码处理问题</p>
<p>C++的异常处理机制为异常检测和异常处理提供支持。包括：</p>
<ol>
<li>throw表达式：异常检测部分使用throw表达式来表示遇到了无法处理的问题</li>
<li>try语句块：异常处理部分使用try语句块处理异常，以关键字try开始，一个或多个catch结束</li>
<li>一套异常类：用于在 throw 表达式和相关的 catch 子句间传递异常的具体信息</li>
</ol>
<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><p>throw 表达式包含关键字 throw 和紧随其后的一个表达式，表达式的类型就是抛出的异常类型</p>
<p>即 throw 后面跟一个异常类型的对象（必须同时使用 string 或 C 风格字符串对其初始化）</p>
<p><code>throw runtime_error(&quot;Data must be same as size&quot;);//使用 throw 表达式抛出一个运行时错误。</code></p>
<h2 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h2><p>跟在 try 块后面的是一个或多个 catch 子句。catch子句包括三部分：关键字catch、括号内一个异常类型的对象的声明（即异常声明）、一个块</p>
<p>当try语句中抛出了一个异常，如果该异常类型与catch子句中的异常类型相同，就会执行该catch子句</p>
<p>catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句执行</p>
<p>在catch后的括号中使用省略号…可以让catch捕获所有异常</p>
<p>每个标准库异常类都有一个 what 成员函数，它没有参数，返回初始化该对象时所用的 C 风格字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must be same as size&quot;</span>);<span class="comment">//try 语句块抛出了一个异常 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">catch</span>(runtime_error err)<span class="comment">//在 catch 后面的括号中声明了一个“runtime_error”类型的对象，与 try 抛出的异常类型相同，接下来执行此子句。 </span></span><br><span class="line">	&#123; </span><br><span class="line">		cout &lt;&lt; err.<span class="built_in">what</span>();<span class="comment">//输出 &quot;Data must be same as size&quot; </span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 函数在寻找处理代码的过程中退出<br>throw 语句可能出现在嵌套的 try 语句块中或在 try 语句块中调用的某个函数内。</p>
<p>当异常抛出的时候，会从内到外一层层寻找相应类型的catch子句。如果最后还是没找到，会调用terminate函数调用来终止程序</p>
<p>如果 throw 语句外就没有 try 语句块，也会执行 terminate 函数</p>
<p>异常中断了程序的正常流程。当发生异常，程序执行到一半就中断了，可能会存在如资源没有正常释放，对象没有处理完成等情况。异常安全的代码要求在异常发生时能正确执行清理工作。这个非常困难</p>
</blockquote>
<h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++ 标准库定义了一组异常类，用于报告标准库函数遇到的问题。他们定义在 4 个头文件中</p>
<p>定义在stdexcept头文件中的类型必须使用string对象或者C风格字符串来初始化，其他的3个头文件中的类型则只能默认初始化，</p>
<p>异常类型只有一个 what 成员函数，该函数没有参数，返回是一个 C 风格字符串的指针，目的是提供关于异常的文本信息</p>
<p>对于无初始值的异常类型，what 返回的内容由编译器决定，有初始值的返回初始值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exception头文件 </span></span><br><span class="line">exception           <span class="comment">// 异常类 exception 是最通用的异常类。它只报告异常的发生，不提供额外信息。 </span></span><br><span class="line"><span class="comment">//new头文件</span></span><br><span class="line">bad_alloc           <span class="comment">// 异常类 bad_alloc。在使用 new 分配动态内存失败时抛出 </span></span><br><span class="line"><span class="comment">//type_info头文件 </span></span><br><span class="line">bad_cast            <span class="comment">// 异常类型 bad_cast。经常发生在使用 dynamic_cast 时发生。 //stdexcept头文件 </span></span><br><span class="line">exception runtime_error       <span class="comment">// 只有在运行时才能检测出的问题 </span></span><br><span class="line">range_error         <span class="comment">// 运行时错误：生成的结果超出了有意义的值域范围 overflow_error      // 运行时错误：计算上溢 </span></span><br><span class="line">underflow_error     <span class="comment">// 运行时错误：计算下溢 </span></span><br><span class="line">logic_error         <span class="comment">// 程序逻辑错误 </span></span><br><span class="line">domain_error        <span class="comment">// 逻辑错误：参数对象的结果值不存在 </span></span><br><span class="line">invalid_argument    <span class="comment">// 逻辑错误：无效参数 </span></span><br><span class="line">length_error        <span class="comment">// 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range        // 逻辑错误：使用一个超出有效范围的值</span></span><br></pre></td></tr></table></figure>
<p>上述几个类的具体继承关系如下图<br><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250904/pYAn/656X562/exception_inherit.png" alt="656X562&#x2F;exception_inherit.png"></p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>分层结构</title>
    <url>/2025/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>计算机网络的模型主要有OSI模型和TCP&#x2F;IP模型两种，本文将分别介绍对应模型中每一层的功能与最终的对比。</p>
<span id="more"></span>
<h1 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h1><ul>
<li>协议数据单元（PDU）：对等层之间传送的数据单位。第n层的记为n-PDU。各层PDU都分为服务数据单元和协议控制信息</li>
<li>服务数据单元（SDU）：层与层之间交换的数据单位，第n层的SDU记为n-SDU</li>
<li>协议控制信息（PCI）：控制协议操作的信息。第n层的PCI记为n-PCI<br>每层的协议数据单元都有额外名称，如物理层的称为比特流，链路层的称为帧，网络层的称为分组，传输层的称为报文段</li>
</ul>
<p>在各层间传输数据时满足：n-SDU + n-PCI &#x3D; n-PDU &#x3D; (n-1)-SDU</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>为了在网络中进行数据交换而建立的规则、标准或约定称为网络协议，是控制在对等实体间进行通信的规则的集合，是水平的，不对等实体间没有协议。</p>
<p>由以下三部分组成：</p>
<ul>
<li>语法：数据与控制信息的格式</li>
<li>语义：即需要发出何种控制信息、完成何种动作以及做出何种应答</li>
<li>同步：执行各种操作的条件、时序关系等，即事件实现顺序的详细说明</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>同一节点内相邻两层的实体交换信息的逻辑接口称为服务访问点（SAP），每层只能在紧邻的层间定义接口，而不能跨层定义。</p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>指下层为紧邻的上层提供的功能调用，是垂直的。对等实体在协议的控制下，使本层能为上层提供服务。</p>
<p>可以分为以下三种：</p>
<ul>
<li>面向连接和无连接服务：<ul>
<li>面向连接服务中，通信双方必须先建立连接，分配相应的资源，以保证通信正常进行，传输结束后释放连接和占用的资源。</li>
<li>无连接服务中，通信双方不需要提前建立连接，发送数据时直接发送。</li>
</ul>
</li>
<li>可靠服务和不可靠服务<ul>
<li>可靠服务：指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</li>
<li>不可靠服务：指网络只是尽量让数据正确、可靠地传送到目的地</li>
</ul>
</li>
<li>有应答服务和无应答服务<ul>
<li>有应答服务：指接收方在收到数据后向发送方给出相应的应答，由传输系统内部自动实现</li>
<li>无应答服务：接收方收到数据后不自动给出应答。如果需要，由高层实现</li>
</ul>
</li>
</ul>
<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>有七层，分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>传输单位是比特，功能是在物理介质上为数据端设备透明地传输原始比特流。但是注意传输信息所用的物理介质（如光缆、无线信道等等）不在物理层协议内</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>传输单位是帧，功能是将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，同时实现节点间的差错控制和流量控制的功能</p>
<p>广播式网络还要处理如何控制对共享信道的访问</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>传输单位是数据报。主要任务是将网络层的协议数据单元（分组）从源主机传输到目的主机。关键在于对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>负责两个进程间的通信，提供端到端的流量控制、差错控制、连接建立和释放、可靠传输管理等服务。</p>
<p>数据链路层提供点对点通信，可以理解为主机与主机的通信（主机通过硬件地址或IP地址标识）</p>
<p>端到端的通信指运行在不同主机内两个进程间的通信，每个进程都由一个端口来标识</p>
<p>因为一台主机可以运行多个进程，因此传输层具有复用和分用的功能。复用指多个进程可以同时使用传输层的服务，分用指传输层将收到的信息分别交付给上层的对应进程</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>允许不同主机上各个进程进行会话，为进程建立连接，并在连接上有序传输数据，这就是会话。</p>
<p>负责管理主机间的会话进程，包括建立、管理和终止进程间的会话。</p>
<p>包含一种称为检查点的机制来维持可靠会话，使通信会话在通信失效时从检查点继续恢复通信。</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>主要处理不同主机间交换信息的方式，此外数据压缩、加密和解密也是表示层的功能</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>是用户与网络的接口</p>
<h1 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h1><p>分为五层：物理层、链路层、网络层、传输层、应用层</p>
<p>主要内容上面已经有对应的了，只不过应用层整合了会话层、表示层、应用层三层的功能</p>
<h1 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h1><ul>
<li>OSI模型精确定义了服务、协议与接口。但是TCP&#x2F;IP模型没有明确区分</li>
<li>OSI模型先有模型，后有协议规范，通用性好。TCP&#x2F;IP模型先有协议栈后建立模型，不适合其他非TCP&#x2F;IP的网络</li>
<li>OSI模型在网络层支持无连接和面向连接的服务，但是在传输层仅有面向连接的服务。而TCP&#x2F;IP模型认为可靠性是端到端的问题，因此在网络层仅有一种无连接通信模式，但是在传输层支持无连接和面向连接两种模式</li>
<li>OSI模型有七层，而TCP&#x2F;IP模型分为五层。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络复习</category>
      </categories>
  </entry>
  <entry>
    <title>绪论</title>
    <url>/2025/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>本文将介绍计算机网络的概念以及进行信息交换的方式</p>
<span id="more"></span>
<h1 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h1><ul>
<li>当前全球最大的、开放的、由众多网络和路由器互连而成的特定计算机网络，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET</li>
</ul>
<h1 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h1><ul>
<li>组成部分：<ul>
<li>硬件：主要有主机（也被称作端系统）、通信链路（如光纤）、交换设备（如路由器、交换机）和通信处理机（如网卡）等组成</li>
<li>软件：主要包括各种实现资源共享的软件和方便用户使用的各种工具软件</li>
<li>协议：是计算机网络的核心，规定了网络传输数据时所遵循的规范</li>
</ul>
</li>
<li>工作方式：可以分为边缘部分和核心部分<ul>
<li>边缘部分：所有连接到互联网上的供用户直接使用的主机组成，用来进行通信（如传输数据、音频和视频）和资源共享</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务</li>
</ul>
</li>
<li>功能组成<ul>
<li>通信子网：由各种传输介质、通信设备和相应的网络协议组成，使网络具有数据传输、交换、控制和存储的能力，实现联网计算机间的数据通信</li>
<li>资源子网：实现资源共享功能的设备及软件的集合，向网络用户提供共享其他计算机的硬件资源、软件资源和数据资源的服务</li>
</ul>
</li>
</ul>
<h1 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h1><ul>
<li>数据通信：是最基本和最重要的功能，用来实现联网计算机间各种信息的传输。</li>
<li>资源共享：既可以是软件或数据的共享，也可以是硬件的共享。使计算机中的资源互通有无、分工协作，极大提高了硬件资源、软件资源和数据资源的利用率</li>
<li>分布式处理：当某个计算机系统负荷过重时，可将其处理的复杂任务分配给网络中其他计算机系统，从而利用空闲计算机资源提高整个系统的利用率</li>
<li>提高可靠性：计算机网络中各台计算机可以通过网络互为替代机</li>
<li>负载均衡：将工作任务均衡分配给计算机网络中各台计算机</li>
</ul>
<h1 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h1><p>分为三步：</p>
<ul>
<li>建立连接：进行数据传输前，两个用户必须先建立一条专用的物理通信路径，由通信双方之间的交换设备和链路逐段连接而成</li>
<li>传输数据：在数据传输过程中，这一物理通信路径始终被两用户独占</li>
<li>释放连接：通信结束后释放通信资源<br>整个通信阶段，比特流连续地从源节点直达目的节点，好像在一个管道中传送，不存在存储转发所耗费的时间</li>
</ul>
<p>优点：</p>
<ul>
<li>通信时延小：通信线路为通信双方专用，数据直达，传输速率高</li>
<li>有序传输：通信时按发送顺序传输数据，不存在失序问题</li>
<li>没有冲突：不同的通信双方有不同的信道</li>
<li>实时性强：一旦建立连接，可以随时通信<br>缺点：</li>
<li>建立连接时间长</li>
<li>线路利用率低：线路被独占，即使空闲也不能供其他用户使用</li>
<li>灵活性差：物理通路中任何一点出现故障，必须重新建立连接</li>
<li>难以实现差错控制：中间节点不具备存储和检验数据的能力，无法发现并纠正错误<br>计算机间的数据传送往往是突发（高频、少量）的，使用电路交换来传送数据时，被用户占用的通信资源在绝大部分时间是空闲的，利用率往往不到10%乃至1%</li>
</ul>
<h1 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h1><p>数据交换的单位是报文，用户数据+原地址+目的地址等信息封装为报文。</p>
<p>采用存储转发的技术，整个报文先传送到相邻的节点，全部存储后查找转发表，转发到下一个节点，如此重复直到目的节点。每个报文可以单独选择到达目的端的路径</p>
<p>优点：</p>
<ul>
<li>无建立连接时延：通信前无需建立连接，用户可以随时发生报文</li>
<li>灵活分配线路：交换节点存储整个报文后，选择一条合适的空闲线路，转发报文。若某条路径故障，可重新选择另一条路径传输</li>
<li>线路利用率高：报文在一段链路上传送时才占用这段链路的通信资源</li>
<li>支持差错控制：交换节点可以对缓存下来的报文进行差错检验<br>缺点：</li>
<li>转发时延高：交换节点要收到所有报文后，才查找转发表进行转发</li>
<li>缓存开销大：报文大小没有限制，要求交换节点有较大的缓存空间</li>
<li>错误处理低效：报文较长时，发生错误概率相对更高，重传整个报文的代价也很大</li>
</ul>
<h1 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h1><p>也采用存储转发技术，但是解决了报文过长的问题</p>
<p>源主机在发送之前，先把较长的报文划分为若干较小的等长数据段，每个数据段前添加一些必要的控制信息（如源地址、目的地址和编号信息）组成的首部，构成分组</p>
<p>源主机将分组发送到分组交换网中，分组交换网的分组交换机收到一个分组后，先缓存，再从首部中提取目的地址，据此查找自己的转发表，再将分组转发给下一个分组交换机。经过多个分组交换机的存储转发后，分组到达目的主机</p>
<p>除了继承报文交换的优点外，还有如下优点：</p>
<ul>
<li>方便存储管理，存储转发开销小。</li>
<li>传输效率高</li>
<li>减少了出错概率和重传代价<br>缺点：</li>
<li>存在存储转发时延</li>
<li>需要额外的信息量</li>
<li>当采用数据报服务时，可能出现失序、丢失或重复分组的情况。如果采用虚电路服务，则没有失序问题，但是有呼叫建立、数据传输和虚电路释放三个过程</li>
</ul>
<h1 id="三种交换方式总结"><a href="#三种交换方式总结" class="headerlink" title="三种交换方式总结"></a>三种交换方式总结</h1><p>当要连续传送大量的数据，且传送时间远大于建立连接时间时，采用电路交换比较合适；从提高整个网络的信道利用率来看，报文交换和分组交换优于电路交换，其中分组交换的时延更小，更为灵活，尤其适合突发式数据传送</p>
<h1 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h1><h2 id="按分布范围"><a href="#按分布范围" class="headerlink" title="按分布范围"></a>按分布范围</h2><ul>
<li>广域网（WAN）：提供长距离通信，运送主机发送的数据，覆盖范围通常是直径几十米到几千千米的区域。是互联网核心部分，连接广域网各节点交换机的链路一般是高速链路，具有较大的通信容量。一般使用交换技术</li>
<li>城域网（MAN）：覆盖范围可以跨越几个街区甚至几个城市，直径为5-50km。多采用以太网技术</li>
<li>局域网（LAN）：一般用主机通过高速线路相连，覆盖范围较小，通常是直径为几十米到几千米的区域。一般使用广播技术</li>
<li>个人区域网（PAN）：指在个人工作的地方将电子设备用无线技术连接起来的网络，也叫无线个人区域网</li>
</ul>
<h2 id="按传输技术"><a href="#按传输技术" class="headerlink" title="按传输技术"></a>按传输技术</h2><ul>
<li>广播式网络：共享一个公共通信信道。当一个计算机发送报文分组时，其他所有计算机都会“收听”到，通过检查目的地址来决定是否接收</li>
<li>点对点网络：每条物理线路连接一对计算机。若通信的两台主机间没有直接相连的线路，则要通过中间节点进行存储转发</li>
</ul>
<h2 id="按拓扑结构"><a href="#按拓扑结构" class="headerlink" title="按拓扑结构"></a>按拓扑结构</h2><p>网络拓扑结构是指由网中节点与通信线路间的几何关系表示的网络结构</p>
<ul>
<li>总线型：单根传输线连接计算机。优点是建网容易、增删节点方便、节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感</li>
<li>星型网络：每个终端或计算机以单独线路与中央设备（一般是路由器或交换机）相连。优点是便于集中控制和管理。缺点是成本高，中央设备对故障敏感</li>
<li>环形网络：所有计算机接口设备连成一个环。最典型的例子是令牌环局域网，既可以是单环也可以是双环。环中信号单向传输</li>
<li>网状网络：每个节点至少有两条路径与其他节点相连，多用在广域网中。有规则型和非规则型两种。优点是可靠性高，缺点是控制复杂、线路成本高</li>
</ul>
<h2 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h2><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="按传输介质"><a href="#按传输介质" class="headerlink" title="按传输介质"></a>按传输介质</h2><p>可以分为有线无线两大类。有线网络可以再分为双绞线网络、同轴电缆网络等。无线网络可以分为蓝牙、微波、无线电等类型</p>
<h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><ul>
<li>速率：指连接到网络上的节点在数字信道上传送数据的速率。单位为b&#x2F;s。较高时可用kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s</li>
<li>带宽：原本表示通信线路允许通过的信号频率范围，单位是Hz。但是在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“最高数据传输速率”的同义语。单位为b&#x2F;s</li>
<li>吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。</li>
<li>时延：指数据从网络的一端传送到另一端所需的总时间。由四部分组成：<ul>
<li>发送时延：从发送第一个比特开始到最后一个比特从本地发送到线路结束。发送时延&#x3D;分组长度&#x2F;发送速率</li>
<li>传播时延：一个比特从链路一端到另一端的时间。传播时延&#x3D;信道长度&#x2F;传播速率</li>
<li>处理时延：分组在交换节点为存储转发而进行的处理所花的时间。</li>
<li>排队时延：分组在路由器的输入或输出队列排队等待的时间</li>
</ul>
</li>
<li>时延带宽积：指发送的第一个比特到达终点时发送端发出了多少比特。时延带宽积&#x3D;传播时延 * 信道带宽</li>
<li>往返时延（RTT）：从发送端发出一个短分组，到发送端收到来自接收端的确认总共经历的时间。包括各中间节点的处理时延、排队时延及转发数据时的发送时延</li>
<li>信道利用率：某个信道有百分之多少的时间有数据通过。太低会浪费网络资源。太高会产生较大的时延，导致网络拥塞。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络复习</category>
      </categories>
  </entry>
</search>
