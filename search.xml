<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7-22 洛谷题单之排序</title>
    <url>/2025/07/22/7-22/</url>
    <content><![CDATA[<h1 id="P1177-【模板】排序-洛谷"><a href="#P1177-【模板】排序-洛谷" class="headerlink" title="P1177 【模板】排序 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1177">P1177 【模板】排序 - 洛谷</a></h1><p>主要是练一下手写快排。</p>
<h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p>本部分讲述的是常用的三路快速排序。如果想了解快速排序的更多变种实现方式可以在 <a href="https://oi-wiki.org/basic/quick-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">OI Wiki</a> 中了解。</p>
<p>我们设待排序的序列为一个长度为 n 的序列 a。快速排序的具体原理如下：</p>
<p>首先，在 a 中随机选择一个数 x，之后我们进行如下操作：</p>
<ol>
<li>如果 n&#x3D;0 或 n&#x3D;1，此时根本无需排序，直接退出；</li>
<li>定义三个新的序列 b,c,d；</li>
<li>遍历整个序列 a，将比 x 小的放在 b 内，比 x 大的放在 d 内，和 x 相等的放在 c 内；</li>
<li>将 b,d 按如上过程继续排序。序列 c 中的数由于都相等所以不必排序。</li>
</ol>
<p>可以发现：实际上每一次的排序之后都会通过调用本身来继续排序，这明显就是递归。</p>
<p>通过递归，我们将一个完整的序列经过不断的分解来变成很多个小序列，直到只有一个或没有数为止。<strong>这种排序就是在不断的递归和分解当中来慢慢实现与完成排序</strong></p>
<p>模版代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    T pivot = arr[<span class="built_in">rand</span>() % (right - left + <span class="number">1</span>) + left];</span><br><span class="line">    <span class="type">int</span> i = left, j = left, k = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[k--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, left, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, k + <span class="number">1</span>, right);</span><br><span class="line">	<span class="comment">//j是第一个pivot所在的位置,k是最后一个pivot所在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1923-【深基9-例4】求第-k-小的数-洛谷"><a href="#P1923-【深基9-例4】求第-k-小的数-洛谷" class="headerlink" title="P1923 【深基9.例4】求第 k 小的数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k 小的数 - 洛谷</a></h1><p>通过分治去求。考虑上面的快排，每次分出三个相对有序的序列，可以据此判断出第k小的数在哪个序列中，然后再递归对应的序列即可</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_nth_k</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right,<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> arr[left];</span><br><span class="line">    T pivot = arr[(right-left) / <span class="number">2</span> + left];</span><br><span class="line">    <span class="type">int</span> i = left, j = left, k = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[k--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; j - left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_nth_k</span>(arr, left, j<span class="number">-1</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k - left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_nth_k</span>(arr, k<span class="number">+1</span>, right, pos- (k - left + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-24 洛谷题单之排序</title>
    <url>/2025/07/24/7-24/</url>
    <content><![CDATA[<h1 id="P1116-车厢重组-洛谷"><a href="#P1116-车厢重组-洛谷" class="headerlink" title="P1116 车厢重组 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1116">P1116 车厢重组 - 洛谷</a></h1><p>实际上是个冒泡排序的过程，在这中间记录一下交换的次数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">                sum++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">bubbleSort</span>(arr);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1068-NOIP-2009-普及组-分数线划定-洛谷"><a href="#P1068-NOIP-2009-普及组-分数线划定-洛谷" class="headerlink" title="P1068 [NOIP 2009 普及组] 分数线划定 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1068">P1068 [NOIP 2009 普及组] 分数线划定 - 洛谷</a></h1><p>结构体排序罢了，但是最后记得要处理分数一样的情况。只需要从m* 1.5开始直到第一个不一样的即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">candiate</span>&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> candiate &amp;a, <span class="type">const</span> candiate &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;candiate&gt; <span class="title">vec</span><span class="params">(<span class="number">5001</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; vec[i].name &gt;&gt; vec[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    m = m * <span class="number">1.5</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].score == vec[m - <span class="number">1</span>].score)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m += sum;</span><br><span class="line">    cout &lt;&lt; vec[m<span class="number">-1</span>].score &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cout &lt;&lt; vec[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec[i].score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1012-NOIP-1998-提高组-拼数-洛谷"><a href="#P1012-NOIP-1998-提高组-拼数-洛谷" class="headerlink" title="P1012 [NOIP 1998 提高组] 拼数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1012">P1012 [NOIP 1998 提高组] 拼数 - 洛谷</a></h1><p>具体证明请参照<a href="https://www.luogu.com.cn/problem/solution/P1012">P1012 [NOIP 1998 提高组] 拼数 - 洛谷</a>的第一篇。</p>
<p>对于做出此题而言的关键在于怎么给输入的字符串排序。而且最终的字符串长度是不会有变化的。</p>
<p>一个简单的想法是，<strong>考虑相邻两项是否需要交换</strong></p>
<p><strong>那么就把对字典序贡献最大的放在前面。比较方法只要比较 s1​+s2​ 和 s2​+s1​ 的大小即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vec</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b &gt; b+a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + n, cmp);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans += vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>IO复用</title>
    <url>/2024/07/08/IO%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基于IO复用的服务器端"><a href="#基于IO复用的服务器端" class="headerlink" title="基于IO复用的服务器端"></a>基于IO复用的服务器端</h1><h2 id="多进程服务器端的缺点和解决方法"><a href="#多进程服务器端的缺点和解决方法" class="headerlink" title="多进程服务器端的缺点和解决方法"></a>多进程服务器端的缺点和解决方法</h2><p>缺点：创建进程的代价大、进程间通信方法复杂。</p>
<p>解决方法：使用 I&#x2F;O 复用<br>![[IOserver model.png]]</p>
<h1 id="select函数和实现服务器端"><a href="#select函数和实现服务器端" class="headerlink" title="select函数和实现服务器端"></a>select函数和实现服务器端</h1><h2 id="select函数的功能和调用顺序"><a href="#select函数的功能和调用顺序" class="headerlink" title="select函数的功能和调用顺序"></a>select函数的功能和调用顺序</h2><p>select 函数可以同时监视多个文件描述符（或套接字）。</p>
<p>select 函数可以监视 3 种事项：</p>
<ol>
<li>是否有套接字接收了数据。</li>
<li>有哪些数据不需要阻塞传输数据。</li>
<li>哪些套接字发生了异常。</li>
</ol>
<p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251012/SClL/493X316/IOserver_model.png" alt="493X316&#x2F;IOserver_model.png"></p>
<h2 id="设置文件描述符"><a href="#设置文件描述符" class="headerlink" title="设置文件描述符"></a>设置文件描述符</h2><p>select 函数监视的文件描述符使用 fd_set 结构体来表示。</p>
<p>fd_set 可以看作是一个数组，该数组是一个只包含 0 和 1 的位数组。fd_set 中的第 i 个元素（即第 i 位，i从0开始）对应文件描述符 i。为1代表监视了这个文件描述符</p>
<p>使用宏来对fd_set进行操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD_ZERO(fd_set* fdset) <span class="comment">// 将变量 fdset 的所有位初始化为 0 </span></span><br><span class="line">FD_SET(<span class="type">int</span> fd, fd_set* fdset) <span class="comment">// 在变量 fdset 中注册文件描述符 fd 的信息 </span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set* fdset) <span class="comment">// 从变量 fdset 中清除文件描述符 fd 的信息 </span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set* fdset) <span class="comment">// 如果变量 fdset 中包含文件描述符 fd 的信息就返回真，此函数用来验证 select 函数的调用结果。</span></span><br></pre></td></tr></table></figure>
<h2 id="设置监视范围及超时"><a href="#设置监视范围及超时" class="headerlink" title="设置监视范围及超时"></a>设置监视范围及超时</h2><h3 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include &lt;sys/select.h&gt; </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval* timeout)</span>; </span><br><span class="line">	<span class="comment">// 功能：验证 3 种监视项的变化情况。 </span></span><br><span class="line">	<span class="comment">// 参数：maxfd：监视对象文件描述符的数量； </span></span><br><span class="line">		<span class="comment">// readset：将所有关注“是否存在待读取数据”的文件描述符注册到 readset 变量； </span></span><br><span class="line">		<span class="comment">// writeset：将所有关注“是否可传输无阻塞数据”的文件描述符注册到 writeset 变量； </span></span><br><span class="line">		<span class="comment">// execeptset：将所有关注“是否发生异常”的文件描述符注册到 exceptset 变量； </span></span><br><span class="line">		<span class="comment">// timeout：调用 select 函数后，为防止陷入无限阻塞的状态，使用 timeout 传递超时信息。 </span></span><br><span class="line">	<span class="comment">// 返回值：发生错误返回 -1，超时返回 0。因发生关注的事件返回时，返回发生事件的文件描述符数量。</span></span><br></pre></td></tr></table></figure>

<h3 id="timeval结构体"><a href="#timeval结构体" class="headerlink" title="timeval结构体"></a>timeval结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span> </span><br><span class="line">	<span class="type">long</span> tv_sec; <span class="comment">//seconds </span></span><br><span class="line">	<span class="type">long</span> tv_usec; <span class="comment">//microseconds </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>select 函数调用完成后，向其传递的 fd_set 变量会产生变化，原来为 1 的所有位都变为 0，但发生变化的文件描述符对应位则变为 1。因此 fd_set 中值为 1 的位置上的文件描述符即为发生变化的文件描述符</p>
<h1 id="windows实现"><a href="#windows实现" class="headerlink" title="windows实现"></a>windows实现</h1><p>首先select函数中添加了一个参数（位于第一的位置），这个参数没有意义，为了保持与(包括Linux的) UNIX系列操作系统的兼容性而添加的</p>
<p>区别在于fd_set不再采用位数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> &#123;</span> </span><br><span class="line">	u_int fd_count; </span><br><span class="line">	SOCKET fd_array[FD_SETSIZE]; </span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>

<p>Windows的fd_set由成员fd_count和fd_array构成, fd_count用于套接字句柄数,fd_array用于保 存套接字句柄。</p>
<p>因为Linux的文件描述符从0开始递增,因此 可以找出当前文件描述符数量和最后生成的文件描述符之间的关系。但Windows的套接字句柄并非从0开始,而且句柄的整数值之间并无规律可循,因此需要直接保存句柄的数组和记录句柄数的变量。</p>
<p>幸好处理fd set结构体的FD_XXX型的4个宏的名称、功能及使用方法与Linux完全相同</p>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><h2 id="select-c"><a href="#select-c" class="headerlink" title="select.c"></a>select.c</h2><p>select 函数调用实例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fd_set reads, temps;</span><br><span class="line">    <span class="type">int</span> result, str_len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;reads); <span class="comment">// 0 是标准输入，这里表示监视标准输入的变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temps = reads;</span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>; <span class="comment">// 设置超时，每个循环中代哦用 select 函数前都要设置</span></span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        result = select(<span class="number">1</span>, &amp;temps, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;select() error!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Time-out!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(<span class="number">0</span>, &amp;temps)) <span class="comment">// 查看结果</span></span><br><span class="line">            &#123;</span><br><span class="line">                str_len = read(<span class="number">0</span>, buf, BUF_SIZE);</span><br><span class="line">                buf[str_len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;message from console: %s&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo-selectserv-c"><a href="#echo-selectserv-c" class="headerlink" title="echo_selectserv.c"></a>echo_selectserv.c</h2><p>使用了基于 select 的 I&#x2F;O 复用的回声服务器端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    fd_set reads, cpy_reads;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="type">int</span> fd_max, str_len, fd_num, i;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(serv_sock, &amp;reads); <span class="comment">// 设置监视范围</span></span><br><span class="line">    fd_max = serv_sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cpy_reads = reads;</span><br><span class="line">        timeout.tv_sec = <span class="number">5</span>; <span class="comment">// 设置超时</span></span><br><span class="line">        timeout.tv_usec = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((fd_num = select(fd_max + <span class="number">1</span>, &amp;cpy_reads, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout)) == <span class="number">-1</span>) <span class="comment">// 调用 select 函数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd_num == <span class="number">0</span>)    <span class="comment">// 等于 0 表示超时</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_max + <span class="number">1</span>; i++) <span class="comment">// 遍历 fd_set 检查发生变化的文件描述符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(i, &amp;cpy_reads))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == serv_sock) <span class="comment">// connection request!</span></span><br><span class="line">                &#123;</span><br><span class="line">                    adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">                    clnt_sock =</span><br><span class="line">                        accept(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                    FD_SET(clnt_sock, &amp;reads);</span><br><span class="line">                    <span class="keyword">if</span> (fd_max &lt; clnt_sock)</span><br><span class="line">                        fd_max = clnt_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// read message!</span></span><br><span class="line">                &#123;</span><br><span class="line">                    str_len = read(i, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>) <span class="comment">// close request!</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        FD_CLR(i, &amp;reads);</span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        write(i, buf, str_len); <span class="comment">// echo!</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>7-23 洛谷题单之排序</title>
    <url>/2025/07/23/7-23/</url>
    <content><![CDATA[<h1 id="P1059-NOIP-2006-普及组-明明的随机数-洛谷"><a href="#P1059-NOIP-2006-普及组-明明的随机数-洛谷" class="headerlink" title="P1059 [NOIP 2006 普及组] 明明的随机数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1059">P1059 [NOIP 2006 普及组] 明明的随机数 - 洛谷</a></h1><p>可以直接用sort排序后再去重。</p>
<p>但是考虑到最大只有1000，因此可以用桶排。每个桶只需要记录有没有即可</p>
<p>最后stl库中的set可以同时完成去重和排序的目的。</p>
<p>最终我选择的set。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        s.<span class="built_in">insert</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1093-NOIP-2007-普及组-奖学金-洛谷"><a href="#P1093-NOIP-2007-普及组-奖学金-洛谷" class="headerlink" title="P1093 [NOIP 2007 普及组] 奖学金 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1093">P1093 [NOIP 2007 普及组] 奖学金 - 洛谷</a></h1><p>用结构体存储对应的变量，然后重构cmp即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">score</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> english;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> score &amp;a, <span class="type">const</span> score &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total != b.total) <span class="keyword">return</span> a.total &gt; b.total;</span><br><span class="line">    <span class="keyword">if</span>(a.chinese != b.chinese) <span class="keyword">return</span> a.chinese &gt; b.chinese;</span><br><span class="line">    <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;score&gt; <span class="title">scores</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt;scores[i].chinese &gt;&gt; scores[i].math &gt;&gt; scores[i].english;</span><br><span class="line">        scores[i].total = scores[i].chinese + scores[i].math + scores[i].english;</span><br><span class="line">        scores[i].id = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;s = scores[i];</span><br><span class="line">        cout &lt;&lt; s.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.total &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1781-宇宙总统-洛谷"><a href="#P1781-宇宙总统-洛谷" class="headerlink" title="P1781 宇宙总统 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1781">P1781 宇宙总统 - 洛谷</a></h1><p>这是个大整数，因此不能直接排序。但是考虑到C++字符串提供了比较字典序的方法，因此可以将其作为字符串来比较，当然首先要比较长度</p>
<p>因为只需要最大的，所以不需要全部存储，读一个比一次即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> winner = <span class="number">1</span>;</span><br><span class="line">    string vote;</span><br><span class="line">    cin&gt;&gt;vote;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        string current_vote;</span><br><span class="line">        cin &gt;&gt; current_vote;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(current_vote, vote)) &#123;</span><br><span class="line">            vote = current_vote;</span><br><span class="line">            winner = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; winner &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vote &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>HDFS和GFS、hive和Hbase复习</title>
    <url>/2025/05/31/HDFS%E5%92%8CGFS%E3%80%81hive%E5%92%8CHbase/</url>
    <content><![CDATA[<p>MapReduce知识的复习</p>
<span id="more"></span>
<h1 id="Google-GFS的基本设计原则"><a href="#Google-GFS的基本设计原则" class="headerlink" title="Google GFS的基本设计原则"></a>Google GFS的基本设计原则</h1><ul>
<li>廉价本地磁盘分布存储</li>
<li>多数据自动备份解决可靠性</li>
<li>为上层MapReduce框架提供支持</li>
</ul>
<h1 id="Google-GFS的基本构架和工作原理"><a href="#Google-GFS的基本构架和工作原理" class="headerlink" title="Google GFS的基本构架和工作原理"></a>Google GFS的基本构架和工作原理</h1><h2 id="GFS-Master的主要作用"><a href="#GFS-Master的主要作用" class="headerlink" title="GFS Master的主要作用"></a>GFS Master的主要作用</h2><ul>
<li>保存命名空间（整个分布式文件系统的目录结构）</li>
<li>Chunk与文件名的映射表</li>
<li>Chunk副本的位置信息</li>
</ul>
<h2 id="GFS-ChunkServer的主要作用"><a href="#GFS-ChunkServer的主要作用" class="headerlink" title="GFS ChunkServer的主要作用"></a>GFS ChunkServer的主要作用</h2><p>保存大量实际数据的数据服务器</p>
<h2 id="GFS-数据访问工作过程"><a href="#GFS-数据访问工作过程" class="headerlink" title="GFS 数据访问工作过程"></a>GFS 数据访问工作过程</h2><ul>
<li>在运行前，数据已经存储在GFS文件系统中，运行时程序会告诉GFS server要访问的文件名和数据块索引</li>
<li>GFS server根据文件名和数据块索引在文件目录空间中查找该文件或者数据块，并找到具体在哪些Chunk server上，将这些位置信息返回给程序</li>
<li>程序根据位置信息，直接访问对应的Chunk server</li>
<li>程序根据位置信息，读取指定位置的数据并做处理</li>
</ul>
<h2 id="GFS-的系统管理技术"><a href="#GFS-的系统管理技术" class="headerlink" title="GFS 的系统管理技术"></a>GFS 的系统管理技术</h2><ul>
<li>大规模集群安装技术</li>
<li>故障检测技术</li>
<li>节点动态加入技术</li>
<li>节能技术</li>
</ul>
<h1 id="Bigtable"><a href="#Bigtable" class="headerlink" title="Bigtable"></a>Bigtable</h1><h2 id="xxxxxxxxxx96-1-include-2-include-3-include-4-include-5-include-6-include-7-include-8-include-9​10-define-BUF-SIZE-10011void-error-handling-char-buf-12​13int-main-int-argc-char-argv-14-15-int-serv-sock-clnt-sock-16-struct-sockaddr-in-serv-adr-clnt-adr-17-struct-timeval-timeout-18-fd-set-reads-cpy-reads-19​20-socklen-t-adr-sz-21-int-fd-max-str-len-fd-num-i-22-char-buf-BUF-SIZE-23-if-argc-2-24-25-printf-“Usage-s-n”-argv-0-26-exit-1-27-28​29-serv-sock-socket-PF-INET-SOCK-STREAM-0-30-memset-serv-adr-0-sizeof-serv-adr-31-serv-adr-sin-family-AF-INET-32-serv-adr-sin-addr-s-addr-htonl-INADDR-ANY-33-serv-adr-sin-port-htons-atoi-argv-1-34​35-if-bind-serv-sock-struct-sockaddr-serv-adr-sizeof-serv-adr-1-36-error-handling-“bind-error”-37-if-listen-serv-sock-5-1-38-error-handling-“listen-error”-39​40-FD-ZERO-reads-41-FD-SET-serv-sock-reads-设置监视范围42-fd-max-serv-sock-43​44-while-1-45-46-cpy-reads-reads-47-timeout-tv-sec-5-设置超时48-timeout-tv-usec-5000-49​50-if-fd-num-select-fd-max-1-cpy-reads-0-0-timeout-1-调用-select-函数51-break-52​53-if-fd-num-0-等于-0-表示超时54-continue-55​56-for-i-0-i-fd-max-1-i-遍历-fd-set-检查发生变化的文件描述符57-58-if-FD-ISSET-i-cpy-reads-59-60-if-i-serv-sock-connection-request-61-62-adr-sz-sizeof-clnt-adr-63-clnt-sock-64-accept-serv-sock-struct-sockaddr-clnt-adr-adr-sz-65-FD-SET-clnt-sock-reads-66-if-fd-max-clnt-sock-67-fd-max-clnt-sock-68-printf-“connected-client-d-n”-clnt-sock-69-70-else-read-message-71-72-str-len-read-i-buf-BUF-SIZE-73-if-str-len-0-close-request-74-75-FD-CLR-i-reads-76-close-i-77-printf-“closed-client-d-n”-i-78-79-else80-81-write-i-buf-str-len-echo-82-83-84-85-86-87-close-serv-sock-88-return-0-89-90​91void-error-handling-char-buf-92-93-fputs-buf-stderr-94-fputc-‘-n’-stderr-95-exit-1-96-c"><a href="#xxxxxxxxxx96-1-include-2-include-3-include-4-include-5-include-6-include-7-include-8-include-9​10-define-BUF-SIZE-10011void-error-handling-char-buf-12​13int-main-int-argc-char-argv-14-15-int-serv-sock-clnt-sock-16-struct-sockaddr-in-serv-adr-clnt-adr-17-struct-timeval-timeout-18-fd-set-reads-cpy-reads-19​20-socklen-t-adr-sz-21-int-fd-max-str-len-fd-num-i-22-char-buf-BUF-SIZE-23-if-argc-2-24-25-printf-“Usage-s-n”-argv-0-26-exit-1-27-28​29-serv-sock-socket-PF-INET-SOCK-STREAM-0-30-memset-serv-adr-0-sizeof-serv-adr-31-serv-adr-sin-family-AF-INET-32-serv-adr-sin-addr-s-addr-htonl-INADDR-ANY-33-serv-adr-sin-port-htons-atoi-argv-1-34​35-if-bind-serv-sock-struct-sockaddr-serv-adr-sizeof-serv-adr-1-36-error-handling-“bind-error”-37-if-listen-serv-sock-5-1-38-error-handling-“listen-error”-39​40-FD-ZERO-reads-41-FD-SET-serv-sock-reads-设置监视范围42-fd-max-serv-sock-43​44-while-1-45-46-cpy-reads-reads-47-timeout-tv-sec-5-设置超时48-timeout-tv-usec-5000-49​50-if-fd-num-select-fd-max-1-cpy-reads-0-0-timeout-1-调用-select-函数51-break-52​53-if-fd-num-0-等于-0-表示超时54-continue-55​56-for-i-0-i-fd-max-1-i-遍历-fd-set-检查发生变化的文件描述符57-58-if-FD-ISSET-i-cpy-reads-59-60-if-i-serv-sock-connection-request-61-62-adr-sz-sizeof-clnt-adr-63-clnt-sock-64-accept-serv-sock-struct-sockaddr-clnt-adr-adr-sz-65-FD-SET-clnt-sock-reads-66-if-fd-max-clnt-sock-67-fd-max-clnt-sock-68-printf-“connected-client-d-n”-clnt-sock-69-70-else-read-message-71-72-str-len-read-i-buf-BUF-SIZE-73-if-str-len-0-close-request-74-75-FD-CLR-i-reads-76-close-i-77-printf-“closed-client-d-n”-i-78-79-else80-81-write-i-buf-str-len-echo-82-83-84-85-86-87-close-serv-sock-88-return-0-89-90​91void-error-handling-char-buf-92-93-fputs-buf-stderr-94-fputc-‘-n’-stderr-95-exit-1-96-c" class="headerlink" title="xxxxxxxxxx96 1#include &lt;stdio.h&gt;2#include &lt;stdlib.h&gt;3#include &lt;string.h&gt;4#include &lt;unistd.h&gt;5#include &lt;arpa&#x2F;inet.h&gt;6#include &lt;sys&#x2F;socket.h&gt;7#include &lt;sys&#x2F;time.h&gt;8#include &lt;sys&#x2F;select.h&gt;9​10#define BUF_SIZE 10011void error_handling(char *buf);12​13int main(int argc, char *argv[])14{15    int serv_sock, clnt_sock;16    struct sockaddr_in serv_adr, clnt_adr;17    struct timeval timeout;18    fd_set reads, cpy_reads;19​20    socklen_t adr_sz;21    int fd_max, str_len, fd_num, i;22    char buf[BUF_SIZE];23    if (argc !&#x3D; 2)24    {25        printf(“Usage : %s \n”, argv[0]);26        exit(1);27    }28​29    serv_sock &#x3D; socket(PF_INET, SOCK_STREAM, 0);30    memset(&amp;serv_adr, 0, sizeof(serv_adr));31    serv_adr.sin_family &#x3D; AF_INET;32    serv_adr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);33    serv_adr.sin_port &#x3D; htons(atoi(argv[1]));34​35    if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) &#x3D;&#x3D; -1)36        error_handling(“bind() error”);37    if (listen(serv_sock, 5) &#x3D;&#x3D; -1)38        error_handling(“listen() error”);39​40    FD_ZERO(&amp;reads);41    FD_SET(serv_sock, &amp;reads); &#x2F;&#x2F; 设置监视范围42    fd_max &#x3D; serv_sock;43​44    while (1)45    {46        cpy_reads &#x3D; reads;47        timeout.tv_sec &#x3D; 5; &#x2F;&#x2F; 设置超时48        timeout.tv_usec &#x3D; 5000;49​50        if ((fd_num &#x3D; select(fd_max + 1, &amp;cpy_reads, 0, 0, &amp;timeout)) &#x3D;&#x3D; -1) &#x2F;&#x2F; 调用 select 函数51            break;52​53        if (fd_num &#x3D;&#x3D; 0)    &#x2F;&#x2F; 等于 0 表示超时54            continue;55​56        for (i &#x3D; 0; i &lt; fd_max + 1; i++) &#x2F;&#x2F; 遍历 fd_set 检查发生变化的文件描述符57        {58            if (FD_ISSET(i, &amp;cpy_reads))59            {60                if (i &#x3D;&#x3D; serv_sock) &#x2F;&#x2F; connection request!61                {62                    adr_sz &#x3D; sizeof(clnt_adr);63                    clnt_sock &#x3D;64                        accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);65                    FD_SET(clnt_sock, &amp;reads);66                    if (fd_max &lt; clnt_sock)67                        fd_max &#x3D; clnt_sock;68                    printf(“connected client: %d \n”, clnt_sock);69                }70                else &#x2F;&#x2F; read message!71                {72                    str_len &#x3D; read(i, buf, BUF_SIZE);73                    if (str_len &#x3D;&#x3D; 0) &#x2F;&#x2F; close request!74                    {75                        FD_CLR(i, &amp;reads);76                        close(i);77                        printf(“closed client: %d \n”, i);78                    }79                    else80                    {81                        write(i, buf, str_len); &#x2F;&#x2F; echo!82                    }83                }84            }85        }86    }87    close(serv_sock);88    return 0;89}90​91void error_handling(char *buf)92{93    fputs(buf, stderr);94    fputc(‘\n’, stderr);95    exit(1);96}c"></a>xxxxxxxxxx96 1#include &lt;stdio.h&gt;2#include &lt;stdlib.h&gt;3#include &lt;string.h&gt;4#include &lt;unistd.h&gt;5#include &lt;arpa&#x2F;inet.h&gt;6#include &lt;sys&#x2F;socket.h&gt;7#include &lt;sys&#x2F;time.h&gt;8#include &lt;sys&#x2F;select.h&gt;9​10#define BUF_SIZE 10011void error_handling(char *buf);12​13int main(int argc, char *argv[])14{15    int serv_sock, clnt_sock;16    struct sockaddr_in serv_adr, clnt_adr;17    struct timeval timeout;18    fd_set reads, cpy_reads;19​20    socklen_t adr_sz;21    int fd_max, str_len, fd_num, i;22    char buf[BUF_SIZE];23    if (argc !&#x3D; 2)24    {25        printf(“Usage : %s <port>\n”, argv[0]);26        exit(1);27    }28​29    serv_sock &#x3D; socket(PF_INET, SOCK_STREAM, 0);30    memset(&amp;serv_adr, 0, sizeof(serv_adr));31    serv_adr.sin_family &#x3D; AF_INET;32    serv_adr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);33    serv_adr.sin_port &#x3D; htons(atoi(argv[1]));34​35    if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) &#x3D;&#x3D; -1)36        error_handling(“bind() error”);37    if (listen(serv_sock, 5) &#x3D;&#x3D; -1)38        error_handling(“listen() error”);39​40    FD_ZERO(&amp;reads);41    FD_SET(serv_sock, &amp;reads); &#x2F;&#x2F; 设置监视范围42    fd_max &#x3D; serv_sock;43​44    while (1)45    {46        cpy_reads &#x3D; reads;47        timeout.tv_sec &#x3D; 5; &#x2F;&#x2F; 设置超时48        timeout.tv_usec &#x3D; 5000;49​50        if ((fd_num &#x3D; select(fd_max + 1, &amp;cpy_reads, 0, 0, &amp;timeout)) &#x3D;&#x3D; -1) &#x2F;&#x2F; 调用 select 函数51            break;52​53        if (fd_num &#x3D;&#x3D; 0)    &#x2F;&#x2F; 等于 0 表示超时54            continue;55​56        for (i &#x3D; 0; i &lt; fd_max + 1; i++) &#x2F;&#x2F; 遍历 fd_set 检查发生变化的文件描述符57        {58            if (FD_ISSET(i, &amp;cpy_reads))59            {60                if (i &#x3D;&#x3D; serv_sock) &#x2F;&#x2F; connection request!61                {62                    adr_sz &#x3D; sizeof(clnt_adr);63                    clnt_sock &#x3D;64                        accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);65                    FD_SET(clnt_sock, &amp;reads);66                    if (fd_max &lt; clnt_sock)67                        fd_max &#x3D; clnt_sock;68                    printf(“connected client: %d \n”, clnt_sock);69                }70                else &#x2F;&#x2F; read message!71                {72                    str_len &#x3D; read(i, buf, BUF_SIZE);73                    if (str_len &#x3D;&#x3D; 0) &#x2F;&#x2F; close request!74                    {75                        FD_CLR(i, &amp;reads);76                        close(i);77                        printf(“closed client: %d \n”, i);78                    }79                    else80                    {81                        write(i, buf, str_len); &#x2F;&#x2F; echo!82                    }83                }84            }85        }86    }87    close(serv_sock);88    return 0;89}90​91void error_handling(char *buf)92{93    fputs(buf, stderr);94    fputc(‘\n’, stderr);95    exit(1);96}c</port></h2><p>为应用程序提供比文件系统更方便、更高层的数据操作能力。主要解决一些大型媒体数据的结构化存储问题</p>
<h2 id="BigTable设计动机"><a href="#BigTable设计动机" class="headerlink" title="BigTable设计动机"></a>BigTable设计动机</h2><ul>
<li>存储管理海量的结构化半结构化数据</li>
<li>海量的服务请求</li>
<li>商用数据库无法适用</li>
</ul>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul>
<li>广泛的适用性</li>
<li>很强的可扩展性</li>
<li>高吞吐量数据访问</li>
<li>高可用性和容错性</li>
<li>自动管理能力</li>
<li>简单些</li>
</ul>
<h2 id="多维表"><a href="#多维表" class="headerlink" title="多维表"></a>多维表</h2><ul>
<li>行关键字：</li>
<li>列关键字</li>
<li>时间戳</li>
</ul>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><ul>
<li>主服务器：新子表分配、子表监控、元数据操作、负载均衡； </li>
<li>子表服务器：数据存储和访问操作 </li>
<li>基本存储结构SSTable，存储在GFS文件系统中。一个SSTable对应GFS一个 64MB 的数据块，一个SSTable里面可以划分64KB的子块，还有Index索引。 </li>
<li>子表寻址：3级B+树</li>
</ul>
<h1 id="Hadoop-分布式文件系统HDFS"><a href="#Hadoop-分布式文件系统HDFS" class="headerlink" title="Hadoop 分布式文件系统HDFS"></a>Hadoop 分布式文件系统HDFS</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>大规模数据分布存储能力</li>
<li>高并发访问能力</li>
<li>强大的容错能力</li>
<li>顺序式文件访问</li>
<li>简单的一致性模型</li>
<li>基于块的文件存储，默认的块的大小是64MB。减少元数据的量。利于顺序读写（在磁盘上数据顺序存放） </li>
<li>多副本数据块形式存储，按照块的方式随机选择存储节点， 默认副本数目是3</li>
</ul>
<h2 id="NameNode的作用"><a href="#NameNode的作用" class="headerlink" title="NameNode的作用"></a>NameNode的作用</h2><p>保存文件系统三种元数据：命名空间、数据块与文件名的映射表、每个数据块副本的位置信息</p>
<h2 id="可靠性与出错恢复"><a href="#可靠性与出错恢复" class="headerlink" title="可靠性与出错恢复"></a>可靠性与出错恢复</h2><ul>
<li>DataNode节点的检测 <ul>
<li>心跳：NameNode 不断检测DataNode是否有效。若失效，则寻找新的节点替代，将失效节点数据重新分布</li>
</ul>
</li>
<li>数据一致性: 校验和</li>
<li>安全模式启动：与DataNode通信获取信息，检查数据块，退出安全模式的时候才 进行文件操作等</li>
</ul>
<h1 id="基本构架与工作过程"><a href="#基本构架与工作过程" class="headerlink" title="基本构架与工作过程"></a>基本构架与工作过程</h1><h2 id="JobTracker的作用"><a href="#JobTracker的作用" class="headerlink" title="JobTracker的作用"></a>JobTracker的作用</h2><p>并行计算框架的主控节点，管理和调度作业执行</p>
<h2 id="TaskTracker的作用"><a href="#TaskTracker的作用" class="headerlink" title="TaskTracker的作用"></a>TaskTracker的作用</h2><p>管理每个节点计算任务的执行</p>
<h1 id="容错处理和性能优化"><a href="#容错处理和性能优化" class="headerlink" title="容错处理和性能优化"></a>容错处理和性能优化</h1><p>由Hadoop系统自己解决。主要方法是将失败的任务进行再次执行<br>TaskTracker会把状态信息汇报给JobTracker，最终由 JobTracker决定重新执行哪一个任务<br>为了加快执行的速度，Hadoop也会自动重复执行同一个任 务，以最先执行成功的为准（投机执行）</p>
<h1 id="HBase-基本工作原理"><a href="#HBase-基本工作原理" class="headerlink" title="HBase 基本工作原理"></a>HBase 基本工作原理</h1><h2 id="HBase的设计目标"><a href="#HBase的设计目标" class="headerlink" title="HBase的设计目标"></a>HBase的设计目标</h2><p>针对HDFS缺少结构化半结构化数据存储访问能力的缺陷，和传统数据库在容量和数据格式上都难以适应非结构化半结构化的处理，提供分布式数据管理系统，解决大规模结构化和半结构化数据存储访问问题</p>
<h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><ul>
<li>列式存储</li>
<li>通过一个行关键字、列关键字和时间戳进行索引，时间戳允许多版本</li>
<li>读写严格一致</li>
<li>提供很高的数据读写速度</li>
<li>良好的线性可扩展性</li>
<li>提供海量数据存储能力</li>
<li>数据可以用户也可以自动分片</li>
<li>自动失效与检测恢复能力</li>
<li>提供hdfs和MapReduce集成</li>
</ul>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>逻辑数据模型是分布式多维映射表，物理模型为按列存储的稀疏行&#x2F;列矩阵。物理存储格式上按逻辑模型中的行进行分割，并按照列族存储</p>
<h2 id="基本构架"><a href="#基本构架" class="headerlink" title="基本构架"></a>基本构架</h2><p>由一个MasterServer和由一组子表数据区服务器RegionServer构成， 分别存储逻辑大表中的部分数据。大表中的底层数据存于HDFS中</p>
<h1 id="Hive基本工作原理"><a href="#Hive基本工作原理" class="headerlink" title="Hive基本工作原理"></a>Hive基本工作原理</h1><h2 id="Hive组成模块"><a href="#Hive组成模块" class="headerlink" title="Hive组成模块"></a>Hive组成模块</h2><ul>
<li>HiveQL：Hive的数据查询语言，提供与用户的接口，包括CLI，数据库访问编程接口JDBC和web界面的网络接口</li>
<li>Driver：执行驱动程序，包括会话的处理，查询获取以及执行驱动</li>
<li>Compiler：编译器，编译HiveQL，包括分析、执行计划生产和优化等</li>
<li>执行引擎：在Driver的驱动下完成操作，包括MapReduce、HDFS操作或者元数据操作</li>
<li>MetaStore：用以存储元数据，包括存储操作的数据对象的格式信息，在HDFS中的存储位置信息及其他用于数据转换的信息等</li>
</ul>
<h2 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h2><ul>
<li>Tables：Hive的数据模型由数据表组成，数据表中的列是有类型的，可以是int、float等，也可以是复合类型</li>
<li>Partitions：数据表可以按照一定的规则划分</li>
<li>Buckets：数据存储的桶，在一定范围内的数据按照Hash的方式划分</li>
</ul>
<h2 id="元数据存储：Metastore"><a href="#元数据存储：Metastore" class="headerlink" title="元数据存储：Metastore"></a>元数据存储：Metastore</h2><p>Hive中一系列的数据表格组成一个命名空间，这个命名空间的描述信息保存在MetaStore中。元数据使用SQL的形式存储在传统的关系数据库中</p>
<h2 id="物理分布情况"><a href="#物理分布情况" class="headerlink" title="物理分布情况"></a>物理分布情况</h2><p>Hive在HDFS中有特定的位置，通常放置在HDFS中如下目录：&#x2F;home&#x2F;hive&#x2F;warehouse。每个数据表被存放在warehouse的子目录中。</p>
<h1 id="Hive-一般有什么调优方式"><a href="#Hive-一般有什么调优方式" class="headerlink" title="Hive 一般有什么调优方式"></a>Hive 一般有什么调优方式</h1><p>Hive 的调优方式有多种，以下是一些常见的方法。</p>
<ul>
<li><strong>查询语句优化</strong>：合理设计查询语句，避免不必要的子查询和全表扫描。例如，在连接表时，确保连接条件正确且使用合适的连接类型。对于大表关联，可以使用<code>map join</code>将小表加载到内存中，在<code>map</code>阶段进行连接，减少数据传输和<code>shuffle</code>。</li>
<li><strong>数据格式优化</strong>：选择合适的数据格式，如 ORC、Parquet 等列式存储格式，它们具有更好的压缩比和查询性能，能减少 I&#x2F;O 开销。</li>
<li><strong>分区和桶化</strong>：对表进行分区，根据业务需求按照时间、地域等维度划分，查询时可以只扫描相关分区，提高查询效率。桶化则是对数据进行更细粒度的划分，基于哈希值将数据分散到不同的桶中，有助于提高某些查询的性能，如等值查询。</li>
<li><strong>资源配置优化</strong>：根据集群的资源情况和查询的特点，合理调整 Hive 的内存、CPU 等资源分配。例如，增加<code>map</code>和<code>reduce</code>任务的内存分配，以避免任务因内存不足而失败或性能低下。</li>
<li><strong>执行计划优化</strong>：可以通过<code>EXPLAIN</code>命令查看查询的执行计划，分析是否存在不合理的地方，如过多的<code>shuffle</code>操作或低效的算子组合，然后针对性地进行调整</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark复习</title>
    <url>/2025/05/28/MapReduce/</url>
    <content><![CDATA[<p>MapReduce知识的复习</p>
<span id="more"></span>
<h1 id="为什么需要大规模数据处理"><a href="#为什么需要大规模数据处理" class="headerlink" title="为什么需要大规模数据处理"></a>为什么需要大规模数据处理</h1><ul>
<li>处理数据的能力大幅落后于数据增长 </li>
<li>海量数据隐含着更准确的事实</li>
</ul>
<h2 id="什么是MapReduce"><a href="#什么是MapReduce" class="headerlink" title="什么是MapReduce"></a>什么是MapReduce</h2><ul>
<li>基于集群的高性能并行计算平台</li>
<li>并行程序开发与运行框架</li>
<li>并行程序设计模型与方法</li>
</ul>
<h2 id="为什么如此重要"><a href="#为什么如此重要" class="headerlink" title="为什么如此重要"></a>为什么如此重要</h2><ul>
<li>高效的大规模数据处理方法</li>
<li>改变了大规模尺度上组织计算的方式</li>
<li>第一个不同于冯诺依曼结构的，基于集群而非单机的计算方式的突破</li>
<li>目前为止最成功的基于大规模计算资源的并行计算抽象方法</li>
</ul>
<h1 id="对付大数据处理-分而治之"><a href="#对付大数据处理-分而治之" class="headerlink" title="对付大数据处理-分而治之"></a>对付大数据处理-分而治之</h1><ul>
<li>大数据分而治之的并行化计算</li>
<li>大数据任务划分和并行计算模型</li>
</ul>
<h2 id="构建抽象模型-Map和Reduce"><a href="#构建抽象模型-Map和Reduce" class="headerlink" title="构建抽象模型-Map和Reduce"></a>构建抽象模型-Map和Reduce</h2><p>主要设计思想：为大数据处理过程中的两个主要操作提供以一种抽象机制</p>
<h2 id="典型流式大数据问题的特征"><a href="#典型流式大数据问题的特征" class="headerlink" title="典型流式大数据问题的特征"></a>典型流式大数据问题的特征</h2><ul>
<li>大量数据记录&#x2F;元素重复处理</li>
<li>对每个数据数据记录&#x2F;元素做感兴趣的处理，获取中间结果</li>
<li>排序和整理中间结果以便后续处理</li>
<li>收集整理中间结果</li>
<li>产生最终结果输出</li>
</ul>
<h1 id="基于Map和Reduce的并行计算模型"><a href="#基于Map和Reduce的并行计算模型" class="headerlink" title="基于Map和Reduce的并行计算模型"></a>基于Map和Reduce的并行计算模型</h1><ul>
<li>各个Map函数对所划分的数据并行处理，从不同的输入数据产生不同的中间结果输出</li>
<li>各个reduce并行计算，各自处理不同的中间结果数据集合</li>
<li>进行reduce前，必须等到所有map执行完。因此有一个同步障，这个阶段也对中间结果数据进行收集整理，以便reduce更高效</li>
<li>最终汇总所有reduce的处理结果即为最终结果</li>
</ul>
<h1 id="上升到构架-自动并行化并隐藏底层细节"><a href="#上升到构架-自动并行化并隐藏底层细节" class="headerlink" title="上升到构架-自动并行化并隐藏底层细节"></a>上升到构架-自动并行化并隐藏底层细节</h1><h2 id="主要需求、目标和设计思想"><a href="#主要需求、目标和设计思想" class="headerlink" title="主要需求、目标和设计思想"></a>主要需求、目标和设计思想</h2><ul>
<li>实现自动并行化计算</li>
<li>为程序员隐藏系统层细节</li>
</ul>
<h2 id="提供统一构建并完成以下功能"><a href="#提供统一构建并完成以下功能" class="headerlink" title="提供统一构建并完成以下功能"></a>提供统一构建并完成以下功能</h2><ul>
<li>任务调度</li>
<li>数据代码互定位</li>
<li>出错处理</li>
<li>分布式数据存储和文件管理</li>
<li>Combiner和Partitioner</li>
</ul>
<h2 id="Combiner和Partitioner"><a href="#Combiner和Partitioner" class="headerlink" title="Combiner和Partitioner"></a>Combiner和Partitioner</h2><ul>
<li>Combiner：合并相同key的键值对，减少数据通信开销。在reduce前执行</li>
<li>Partitioner：map输出的中间结果需要根据一定策略进行划分处理，保证相关数据发送到同一个数据节点。</li>
</ul>
<h1 id="MapReduce的主要设计思想和特征"><a href="#MapReduce的主要设计思想和特征" class="headerlink" title="MapReduce的主要设计思想和特征"></a>MapReduce的主要设计思想和特征</h1><ul>
<li>向外横向拓展，而非向上纵向拓展。MapReduce集群的构筑选用价格便宜、易于扩展的大量低端商用服务器。</li>
<li>失效被认为是常态。使用多种机制如节点自动重启技术使集群和计算框架能有效处理失效节点的检测和恢复</li>
</ul>
<ul>
<li>把计算处理向数据迁移。采用数据代码互定位的技术，使节点优先计算本地数据，否则将远程数据发送到本地。</li>
<li>顺序处理数据，避免随机访问数据。所有计算被组织成流式操作，以便利用大量集群上磁盘集合的高传输带宽。</li>
<li>为应用开发者隐藏系统细节。程序员只需要描述算什么，具体怎么算由系统完成</li>
<li>平滑无缝的可拓展性。计算性能可随节点数目的增长而保持几乎线性的增长。</li>
</ul>
<h1 id="MapReduce基本构思"><a href="#MapReduce基本构思" class="headerlink" title="MapReduce基本构思"></a>MapReduce基本构思</h1><ul>
<li>如何对待大数据处理：分而治之。</li>
<li>上升到抽象模型：Mapper和Reducer</li>
<li>上升到构架：统一构建，为程序员隐藏系统细节</li>
</ul>
<h1 id="Google-MapReduce并行处理的基本过程"><a href="#Google-MapReduce并行处理的基本过程" class="headerlink" title="Google MapReduce并行处理的基本过程"></a>Google MapReduce并行处理的基本过程</h1><ul>
<li>待处理的大数据局被分为大小相同的数据块，以及对应的用户程序</li>
<li>系统中有一个负责调度的主节点，以及map和reduce的工作节点</li>
<li>用户作业程序提交给主节点</li>
<li>主节点寻找可用的map节点，并将程序和数据发送</li>
<li>主节点寻找可用的reduce节点，将程序发送</li>
<li>启动每个map节点程序</li>
<li>每个map节点处理读取的数据块，做数据处理工作，将中间结果存放到本地，告知主节点任务完成以及中间结果存储位置</li>
<li>所有map节点完成后，启动reduce节点，reduce节点远程读取中间结果</li>
<li>reduce将计算结果汇总到一个文件</li>
</ul>
<h1 id="失效处理"><a href="#失效处理" class="headerlink" title="失效处理"></a>失效处理</h1><h2 id="主节点失效"><a href="#主节点失效" class="headerlink" title="主节点失效"></a>主节点失效</h2><p>主节点周期性设置检查点，一旦某个任务失效，可以从最近的检查点重新执行。</p>
<h2 id="工作节点失效"><a href="#工作节点失效" class="headerlink" title="工作节点失效"></a>工作节点失效</h2><p>主节点会周期性给工作节点发送心跳检测，如果无回应，认为失效。主节点终止该工作节点任务并将任务调度到其他节点上重新执行</p>
<h2 id="计算优化"><a href="#计算优化" class="headerlink" title="计算优化"></a>计算优化</h2><p>把一个Map计算任务让多个Map节点同时做，取最快完成者的计算结果。</p>
<h1 id="Hadoop数据倾斜"><a href="#Hadoop数据倾斜" class="headerlink" title="Hadoop数据倾斜"></a>Hadoop数据倾斜</h1><p>在使用 Hadoop 的过程中，经常会遇到数据倾斜问题。数据倾斜是指在数据处理过程中，某些节点或任务处理的数据量远远大于其他节点或任务，导致整个作业的执行效率低下。</p>
<p>数据倾斜产生的原因主要有以下几点。一是数据本身的分布不均匀，某些键值对应的记录数量过多，而其他键值对应的记录数量很少。二是在数据处理过程中，不合理的分区策略导致数据在各个分区之间分布不均衡。三是在进行关联操作时，关联键的分布不均匀，导致某些 Reduce 任务需要处理大量的数据。</p>
<p>针对数据倾斜问题，可以采取以下解决方案。首先，可以对数据进行预处理，在数据进入 Hadoop 之前，对数据进行清洗和转换，尽量使数据分布均匀。其次，调整分区策略，根据数据的特点选择合适的分区算法，如按照哈希值分区、按照范围分区等，确保数据在各个分区之间均匀分布。对于关联操作导致的数据倾斜，可以采用数据采样的方法，先对数据进行采样，分析关联键的分布情况，然后根据分布情况对数据进行重新分区或调整关联顺序。另外，还可以使用 Hadoop 的一些优化参数，如调整 Map 和 Reduce 任务的数量、设置合理的内存分配等，来提高任务的执行效率，缓解数据倾斜问题。</p>
<h1 id="数仓分层有所了解么？作用是什么？分层框架是怎样的？"><a href="#数仓分层有所了解么？作用是什么？分层框架是怎样的？" class="headerlink" title="数仓分层有所了解么？作用是什么？分层框架是怎样的？"></a>数仓分层有所了解么？作用是什么？分层框架是怎样的？</h1><p>数据仓库分层是将数据按照不同的主题、粒度和处理阶段进行划分，形成不同的层次结构。</p>
<p>其作用主要有以下几点。首先，清晰的数据结构便于管理和维护数据，使数据的流向和处理过程更加清晰，降低了数据管理的复杂性。其次，通过分层可以实现数据的逐步细化和整合，在不同层次进行数据的清洗、转换和汇总等操作，提高数据质量。再者，分层可以提高数据的安全性，不同层次的数据可以根据其敏感程度设置不同的访问权限。最后，能提升查询性能，针对不同的查询需求，可以在相应的层次上进行优化，减少数据扫描范围，提高查询效率。</p>
<p>常见的分层框架包括以下几个层次。原始数据层（ODS），主要用于存储从数据源直接抽取过来的原始数据，保持数据的原貌，不做过多处理。数据仓库层（DWD），对原始数据进行清洗、转换和初步的整合，按照业务主题进行划分，如用户主题、订单主题等，存储的是明细数据。数据集市层（DWS），在 DWD 层的基础上，根据不同的分析需求，对数据进行进一步的汇总和聚合，形成宽表，以满足特定部门或业务线的分析需求。应用层（APP），面向具体的应用场景和业务需求，将经过处理和分析的数据进行展示和应用，如生成报表、仪表盘等。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL必知必会</title>
    <url>/2024/10/26/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p>读过《SQL必知必会》后的总结</p>
<span id="more"></span>

<h1 id="了解SQL"><a href="#了解SQL" class="headerlink" title="了解SQL"></a>了解SQL</h1><h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><p>数据库是保存有组织的数据的容器，通常是一个文件或一组文件</p>
<p>数据库软件是数据库管理系统（DBMS），数据库是通过DBMS创建和操纵的容器</p>
<p>RDBMS指关系型数据库管理系统，是SQL的基础，也是现代数据库系统的基础</p>
<p>RDBMS的数据存储在被称为表(tables)的数据库对象中</p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表是一种结构化的文件，存储在表中的数据是同一种类型的数据或清单。</p>
<p>每一个表有唯一的名字。有一些特性：数据在表中如何存储、存储什么样的数据、数据如何分解等。</p>
<p>模式描述了表或数据库的这些特性信息。</p>
<h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><p>表由列组成，列是表中的一个字段。使用表存储数据时要正确地将数据分解为多个列。</p>
<p>每个列都有相应的数据类型，限定了可存储在该列中地数据种类。</p>
<p>注意：数据类型及其名称的不同是 SQL 不兼容的一个主要原因。</p>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>行是表中的一个记录，表中的数据是按行存储的。</p>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>表中每一行都应该有一列或者几列可以唯一标识自己，这就是表的主键</p>
<p>表中至少有一个主键</p>
<h3 id="作为主键的列需要满足的条件"><a href="#作为主键的列需要满足的条件" class="headerlink" title="作为主键的列需要满足的条件"></a>作为主键的列需要满足的条件</h3><ol>
<li>任意两行不具有相同的主键值</li>
<li>每一行必须有一个主键值（主键列不允许有NULL值）</li>
<li>主键列中的值不允许修改或更新</li>
<li>主键值不能重用（即使被删除后，也不能给以后的新行）<br>当多个列作为主键时，只需要所有的列值的组合是唯一的，单个列的值可以不唯一。</li>
</ol>
<h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><p>SQL(Structured Query Language)：结构化查询语言。SQL 是一种专门用来与数据库沟通的语言。</p>
<p>SQL 不是某个特定数据库供应商专用的语言，几乎所有重要的 DBMS 都支持 SQL，但是不同厂商进行了不同的扩展。</p>
<p>标准 SQL 由 ANSI 标准委员会管理，因此称为 ANSI SQL。</p>
<p>可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。</p>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><p>不区分大小写，但是一般<strong>SQL关键字使用大写，列名和表名使用小写</strong></p>
<h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><p>SQL 语句由简单的英语单词组成，这些单词称为关键字。</p>
<p>每个 SQL 语句由一个或多个关键字构成，关键字不能作为表或列的名字。</p>
<p>多条 SQL 语句必须以分号分割，单条 SQL 语句一般不需要（有的 DBMS 也需要）</p>
<p>处理 SQL 语句时所有的空格都会被忽略，SQL 语句可以写成一行，也可以写成多行。</p>
<p>SQL 语句由子句组成，有些子句是必须的，有些是可选的。一个子句通常由一个关键字加上所提供的数据组成。比如 FROM 子句，WHRER 子句。</p>
<h2 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>SELECT 语句返回的数据是未排序的，可能是记录的添加顺序也可能不是。</p>
<h2 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>不同列名间以逗号分隔</p>
<h2 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>一般除非确实需要每一列，否则不要使用 * 通配符，会降低性能。</p>
<h2 id="检索不同的值"><a href="#检索不同的值" class="headerlink" title="检索不同的值"></a>检索不同的值</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>关键字 DISTINCT 用来区分不同的值。</p>
<p>如果有多行 vend_id 列值相同，只返回其中一行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>DISTINCT 作用于跟在其后的所有的列，而不是一列。</p>
<p>如果有多行的 vend_id 与 prod_price 两列的列值都相同，则只返回一行。</p>
<h2 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h2><p>只返回前N行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM Products </span><br><span class="line">LIMIT 3;</span><br></pre></td></tr></table></figure>
<p>只返回从m行开始的前N行（下面这个例子返回从第2行开始的4行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Product </span><br><span class="line">LIMIT 4 OFFSET 2;</span><br></pre></td></tr></table></figure>
<p>有简化版写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Product</span><br><span class="line">LIMIT 4,2;</span><br></pre></td></tr></table></figure>
<h2 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--一条注释 </span><br><span class="line">#一条注释 //这种使用的较少 </span><br><span class="line">/*多行注释*/ //这是多行注释</span><br></pre></td></tr></table></figure>
<h1 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h1><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_id</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY prod_name</span><br></pre></td></tr></table></figure>
<p>按字母顺序进行排序。</p>
<p>ORDER BY 子句中使用的列一般是将要显示的列，但是也可以不是。</p>
<p>通常 ORDER BY 子句必须是 SELECT 语句的最后一个子句。</p>
<p>当有 LIMIT 时，LIMIT 应位于 ORDER BY 的后面，且 DBMS 会先执行 ORDER BY 后执行 LIMIT</p>
<h2 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name </span><br><span class="line">FROM Products </span><br><span class="line">ORDER BY prod_id, prod_price;</span><br></pre></td></tr></table></figure>
<p>首先按 prod_id 排序，对于 prod_id 相同的多行，按 prod_price 排序。</p>
<h2 id="按列位置排序"><a href="#按列位置排序" class="headerlink" title="按列位置排序"></a>按列位置排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name </span><br><span class="line">FROM Products </span><br><span class="line">ORDER BY 2,3;</span><br></pre></td></tr></table></figure>
<p>按相对列位置进行排序。</p>
<p>ORDER BY 2,3 表示按照 SELECT 后跟的列名中的第二个和第三个进行排序</p>
<p>当根据不出现在 SELECT 清单中的列进行排序时，不能采用这种方法。但是可以混合使用实际列名和相对列位置。</p>
<h2 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY 2 DESC,3;</span><br></pre></td></tr></table></figure>
<p>使用关键字 DESC 来指定按降序排列，DESC 仅作用于位于它前面的一个列名。</p>
<p>如果想在多个列上按降序排列，要对每一列都指定 DESC 关键字。</p>
<p>DESC 是 DESCENDING 的缩写，两个都可以用。对应的升序是 ASC(ASCENDING)，可以省略</p>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><h2 id="使用where子句"><a href="#使用where子句" class="headerlink" title="使用where子句"></a>使用where子句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price = 3.49;</span><br></pre></td></tr></table></figure>
<p>使用 WHERE 子句指定过滤条件。</p>
<p>字符串要用单引号括起来。</p>
<h2 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h2><p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251009/xdP5/627X432/Where%E6%93%8D%E4%BD%9C%E7%AC%A6.png" alt="627X432&#x2F;Where操作符.png"><br>MySql支持的操作符如下<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251009/S1VY/668X298/mysql_where%E6%93%8D%E4%BD%9C%E7%AC%A6.png" alt="668X298&#x2F;mysql_where操作符.png"></p>
<p>还有<strong>IS NULL、IN、NOT</strong></p>
<h3 id="BETWEEN-操作符"><a href="#BETWEEN-操作符" class="headerlink" title="BETWEEN 操作符"></a>BETWEEN 操作符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price </span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price BETWEEN 5 AND 10;</span><br></pre></td></tr></table></figure>
<p>BETWEEN 匹配的值包括两个边界值 5 和 10。</p>
<h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price </span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price IS NULL;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 不等于<br>在使用不等于作为过滤条件时，并不会匹配到 NULL 值的行。</p>
</blockquote>
<h1 id="高级数据过滤"><a href="#高级数据过滤" class="headerlink" title="高级数据过滤"></a>高级数据过滤</h1><h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h2><p>可以使用<strong>AND操作符</strong> 和 <strong>OR操作符</strong>来组合多个条件</p>
<p>AND 的优先级高于 OR，可以使用圆括号来控制运算顺序。建议当在一个子句种同时使用 AND 和 OR 时加上圆括号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price </span><br><span class="line">FROM products </span><br><span class="line">WHERE (vend_id = &#x27;DLL01&#x27; OR vend_id = &#x27;BRS01&#x27;) AND prod_price &gt;= 10;</span><br></pre></td></tr></table></figure>
<h2 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price, vend_id</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id IN (&#x27;DLL01&#x27;, &#x27;BRS01&#x27;);</span><br></pre></td></tr></table></figure>
<p>IN 后跟一个圆括号列表，用来指定要匹配值的清单。</p>
<p>IN 的作用和 OR 类似，可以使用 OR 完成同样的操作。IN 操作符一般比一组 OR 操作符执行的更快。</p>
<p><strong>IN 可以包含其他 SELECT 语句</strong></p>
<h2 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE NOT vend_id IN (&#x27;DLL01&#x27;, &#x27;BRS01&#x27;);</span><br></pre></td></tr></table></figure>
<p>NOT 否定其后所跟的任何条件。</p>
<h1 id="使用通配符进行过滤"><a href="#使用通配符进行过滤" class="headerlink" title="使用通配符进行过滤"></a>使用通配符进行过滤</h1><h2 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h2><p>使用LIKE来匹配具有特定模式的字符串，类似正则表达式</p>
<p>通配符：用来匹配值的一部分的特殊字符。</p>
<p>搜索模式：由字面值、通配符或两者组合构成的搜索条件。通配符可以在搜索模式中的任意位置使用，并可以使用多个通配符。</p>
<p>LIKE 后一般跟一个使用了通配符的搜索模式。</p>
<p>根据 DBMS 的设置，搜索可以区分大小写。</p>
<p>常用通配符</p>
<ol>
<li>%:1. 百分号通配符匹配任意数量的任意字符（0 个及 0 个以上）</li>
<li>_ ：下划线通配符用来匹配一个任意字符</li>
<li>[] ：方括号通配符用来指定一个字符集，匹配一个属于字符集的字符（只有 Microsoft Access 和 SQL Server 支持它）。可以在方括号内的开始位置加一个 ^ （ Microsoft Access 中对应字符是 !）来表示否定（像正则表达式一样）<br>MySQL 仅支持 % 和 _ 两种通配符</li>
</ol>
<blockquote>
<p>[!NOTE] 注意可能填补的空格<br>有些DBMS用空格来填补字段的内容。例如，如果某列有50个字符， 而存储的文本为Fish bean bag toy（17个字符），则为填满该列需要在文本后附加33个空格。这样做一般对数据及其使用没有影响，但是可能对上述SQL语句有负面影响。子句WHERE prod_name LIKE ‘F%y’只匹配以F开头、以y结尾的prod_name。如果值后面跟空格， 则不是以y结尾，所以Fish bean bag toy就不会检索出来。简单 的解决办法是给搜索模式再增加一个%号：’F%y%’还匹配y之后的字符（或空格）。更好的解决办法是用函数去掉空格。</p>
</blockquote>
<p>百分号通配符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_name LIKE &#x27;F%y&#x27;; //匹配以 F 开头以 y 结尾的字符串</span><br></pre></td></tr></table></figure>
<p>下划线通配符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_name LIKE &#x27;__ inch %&#x27;;</span><br></pre></td></tr></table></figure>
<p>方括号通配符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_name LIKE &#x27;[1-9][0-9] inch %&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h2><p>通配符搜索比其他搜索耗费时间更多，因此：</p>
<ol>
<li>不要过度使用通配符，如果其他操作符能达到目的，就使用其他操作符。</li>
<li>必须使用通配符时，尽量不要把它放在搜索模式的开始位置。</li>
</ol>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><p>有时存储在表中的数据不是应用程序需要的，需要直接从数据库中检索出转换、计算或格式化的数据。比如数据库中一列保存了姓，另一列保存了名，而用户想要将姓名一块输出</p>
<p>在SQL语句内可完成的许多转换和格式化工作都可以直接在客户端应用程序内完成，但是一般来说，在数据库服务器上完成更快</p>
<p><strong>字段</strong>：基本与列的意思相同，经常互换使用，不过字段通常与计算字段一起使用</p>
<p>计算字段并不实际存在于数据库表中。计算字段是运行时在 SELECT 语句内创建的。</p>
<h2 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h2><p>拼接：将值连接到一起构成单个值。</p>
<p>MySQL、MariaDB 使用 Concat 函数来拼接字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#x27;(&#x27;, RTRIM(vend_country), &#x27;)&#x27;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name</span><br></pre></td></tr></table></figure>
<p>其他 DBMS 使用 + 或 || 来拼接字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;Access、SQL Server&#x27; </span><br><span class="line">SELECT vend_name + &#x27;(&#x27; + vend_country + &#x27;)&#x27; </span><br><span class="line">FROM vendors </span><br><span class="line">ORDER BY vend_name; </span><br><span class="line">&#x27;DB2、Oracle、PostgreSQL、SQLite、Open Office Base&#x27; </span><br><span class="line">SELECT vend_name || &#x27;(&#x27; || vend_country || &#x27;)&#x27; </span><br><span class="line">FROM vendors </span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<h3 id="TRIM函数"><a href="#TRIM函数" class="headerlink" title="TRIM函数"></a>TRIM函数</h3><p>大多数DBMS都支持RTRIM()（去掉右边的空格）、LTRIM()（去掉字符串左边的空格）以及 TRIM()（去掉字符串左右两边的空格）。</p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>上面SELECT拼接得到的字段没有名字，可以使用别名alias作为一个字段或值的替换名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#x27;(&#x27;, vend_country, &#x27;)&#x27;) AS vend_title </span><br><span class="line">FROM vendors </span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<p>使用关键字 AS 来赋予别名。推荐通过 AS 来使用别名。</p>
<p>别名除了给计算字段命名外，还可以重命名某个列名。</p>
<p>别名可以是一个单词也可以是一个字符串，如果是字符型需要加引号。但是建议别名只使用单个单词。</p>
<h2 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h2><p>计算字段的另一用途是对检索出的数据执行算术计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price </span><br><span class="line">FROM orderitems </span><br><span class="line">WHERE order_num = 20008;</span><br></pre></td></tr></table></figure>
<p>将列 quantity 与列 item_price 相乘后命名为 expended_price 输出。</p>
<p>SQL 支持加减乘除四种算术运算，可以用圆括号来区分优先顺序。</p>
<h3 id="测试计算"><a href="#测试计算" class="headerlink" title="测试计算"></a>测试计算</h3><p>SELECT 语句不加 FROM 子句时可以用来处理简单的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 2*3; //返回 6 </span><br><span class="line">SELECT Trim(&#x27; abc&#x27; ); //返回 abc </span><br><span class="line">SELECT Now() AS CurrentTime; //返回当前日期和时间</span><br></pre></td></tr></table></figure>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>几乎所有的 DBMS 都等同地支持 SQL 语句，但是每个 DBMS 都有特定的函数，只有少数几个函数被所有主要的 DBMS 等同地支持。</p>
<p>因为函数不可移植，所以如果使用函数编写 SQL 程序，要做好注释，以便理解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;提取字符串的组成部分&#x27; </span><br><span class="line">SUBSTRING(); // MySQL、SQL Server </span><br><span class="line">SUBSTR(); // DB2、Oracle、PostgreSQL、SQLite </span><br><span class="line">MID(); // Access </span><br><span class="line">&#x27;数据类型转换&#x27; </span><br><span class="line">CONVERT(); // MySQL、MariaDB、SQL Server </span><br><span class="line">CAST(); // PostgreSQL、SQLite </span><br><span class="line">&#x27;取当前日期&#x27; </span><br><span class="line">CURDATE(); // MySQL、MariaDB 。MySQL 中 NOW() 是同时取日期和时间。 </span><br><span class="line">NOW(); // Access </span><br><span class="line">DATE(); // SQLite </span><br><span class="line">GETDATE(); // SQL Server </span><br><span class="line">CURRENT_DATE // DB2、PostgreSQL</span><br></pre></td></tr></table></figure>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>大多数 SQL 都支持以下函数：</p>
<ol>
<li>用于处理文本字符串的函数。如删除或填充值、转换大小写。</li>
<li>用于在数值数据上进行算术操作的数值函数。如返回绝对值、进行算术运算。</li>
<li>用于处理日期和是兼职并从中提取特定成分的日期和时间函数。如返回两个日期之差、检查日期有效性。</li>
<li>返回 DBMS 正使用的特殊信息的系统函数。如返回用户登录信息。</li>
</ol>
<p>下面只列出了 MySQL 中的函数。</p>
<h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEFT();RIGHT();// 返回字符串左边/右边的字符</span><br><span class="line">LENGTH(); // 返回字符串的长度</span><br><span class="line">LOWER();UPPER(); // 将字符串转换为小写/大写</span><br><span class="line">LTRIM();RTRIM;();TRIM();// 去掉字符串左边/右边/两边的空格</span><br><span class="line">SOUNDEX(); // 返回字符串的 SOUNDEX 值</span><br><span class="line">LOCATE();// 找出串的一个子串</span><br><span class="line">SUBSTRING(); // 返回子串的字符</span><br></pre></td></tr></table></figure>

<p>SOUNDEX 值是描述一个文本串的语音表示的字母数字模式，他考虑了类似的发音字符和字节，使得能对字符串进行发音比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;下面这个语句未查询到符合条件的返回值&#x27; </span><br><span class="line">SELECT cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE cust_contact = &#x27;Michael Green&#x27;; </span><br><span class="line">&#x27;下面这个语句返回 Michelle Green，因为两者发音相似&#x27; </span><br><span class="line">SELECT cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE SOUNDEX(cust_contact) = SOUNDEX(&#x27;Michael Green&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p>日期和时间采用相应的数据类型存储在表中，每种 DBMS 都有自己的特殊形式。日期和时间值以特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。</p>
<p>大多数 DBMS 具有比较日期、执行基于日期的运算、选择日期格式等的函数。</p>
<p>日期和时间函数在 SQL 中具有重要的作用，但是他们可移植性最差。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddData(); // 增加一个日期（天、周等） </span><br><span class="line">AddTime(); // 增加一个时间（时、分等） </span><br><span class="line">CurDate(); CurTime(); // 返回当前日期/时间 </span><br><span class="line">DateDiff(); // 计算两个日期之差 </span><br><span class="line">Date_Add(); // 高度灵活的日期计算函数 </span><br><span class="line">Date_Format(); // 返回一个格式化的日期或时间串 </span><br><span class="line">DayOfWeek(); // 对于一个日期，返回对应的星期几 </span><br><span class="line">Year(); Month(); Day(); // 返回一个日期的年份/月份/天数部分 </span><br><span class="line">Hour(); Minute(); Second(); // 返回一个时间的小时/分钟/秒部分 </span><br><span class="line">Now(); // 返回当前日期和时间 </span><br><span class="line">Date(); // 返回一个日期时间的日期部分 </span><br><span class="line">Time(); // 返回一个日期时间的时间部分</span><br></pre></td></tr></table></figure>
<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>数值处理函数仅处理数值数据。一般用于代数、三角或几何运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cos(); Sin(); Tan(); </span><br><span class="line">Abs(); // 返回绝对值 </span><br><span class="line">Mod(); // 返回余数 </span><br><span class="line">Pi(); // 返回圆周率 </span><br><span class="line">Rand(); // 返回随机数 </span><br><span class="line">Exp(); // 返回一个数的指数值 </span><br><span class="line">Sqrt(); // 返回一个数的平方根</span><br></pre></td></tr></table></figure>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>聚集函数用来汇总数据，而非检索数据。比如说想知道表中的总行数、某一列的最大值、平均值等就可以使用聚集函数。</p>
<p>SQL 提供了 5 个聚集函数，它们对某些行运行，计算并返回一个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVG() //返回某列的平均值 </span><br><span class="line">COUNT() //返回某列的行数 </span><br><span class="line">MAX() //返回某列的最大值 </span><br><span class="line">MIN() //返回某列的最小值 </span><br><span class="line">SUM() //返回某列值的和</span><br></pre></td></tr></table></figure>
<h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h3><p>AVG() 可以用来返回所有列的平均值，也可以返回特定列或特定行的平均值。</p>
<p>只能作用于数值列，且列名作为函数参数<br>、<br>会忽略值为NULL的行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;返回某一列中所有行的平均值&#x27;</span><br><span class="line"></span><br><span class="line">SELECT AVG(prod_price) AS avg_price </span><br><span class="line">FROM Products;</span><br><span class="line"></span><br><span class="line">&#x27;返回某一列中特定行的平均值&#x27;</span><br><span class="line"></span><br><span class="line">SELECT AVG(prod_price) AS avg_price </span><br><span class="line">FROM Products WHRER vend_id = &#x27;DLL01&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><p>COUNT() 函数有两种使用方式：</p>
<ol>
<li>COUNT(* )：返回表中的行数（值为 NULL 的行也会统计在内）</li>
<li>COUNT(colum)：对特定列中具有值的行进行计数，忽略 NULL 值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_cust </span><br><span class="line">FROM Customers;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(cust_email) AS num_cust </span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>
<h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h3><p>MAX() 返回指定列中的最大值，可以用于数值或日期值。但许多 DBMS 也允许它用于返回文本列中的最大值。</p>
<p>MySQL 中的 MAX() 函数支持返回任何列的最大值，包括文本列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MAX(prod_price) AS max_price </span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<h3 id="MIN"><a href="#MIN" class="headerlink" title="MIN"></a>MIN</h3><p>类似MAX</p>
<h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h3><p>SUM() 返回指定列值的和，忽略值为 NULL 的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SUM(item_price*quantity) AS total_price </span><br><span class="line">FROM OrderItems </span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>
<h2 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h2><p>以上聚集函数都可以如下使用：</p>
<ol>
<li>对所有行执行计算（默认或显式指定ALL参数）</li>
<li>只包含不同的值，指定DISTINCT参数，只计算不同的值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price </span><br><span class="line">FROM Products </span><br><span class="line">WHERE vend_id = &#x27;DLL01&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h2><p>SELECT 语句可以包含多个聚集函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items, </span><br><span class="line">	MIN(prod_price) AS price_min, </span><br><span class="line">	MAX(prod_price) AS price_max, </span><br><span class="line">	AVG(prod_price) AS price_avg </span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p>用到两个SELECT子句：GROUPBY和HAVING子句</p>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算（使用第九章中的聚集函数）。</p>
<h2 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h2><p>使用GROUP BY子句创建分组，该子句指示DBMS分组数据，然后对每个组而非整个结果集进行聚集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_pords </span><br><span class="line">FROM products </span><br><span class="line">GROUP BY vend_id</span><br></pre></td></tr></table></figure>
<p>规定：</p>
<ol>
<li>GROUP BY可以包含任意数目的列，因此可以对分组进行嵌套，更细致的进行数据分组</li>
<li>如果嵌套了分组，数据将在最后指定的分组进行汇总。即基于指定的所有列来分组</li>
<li>该子句列出的每一列都必须是检索列或有效的表达式。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句指定相同的表达式，不能用别名</li>
<li>大多数 SQL 不允许 GROUP BY 列带有长度可变的数据类型，如文本或备注型字段</li>
<li>除聚集计算语句外，SELECT语句中每一列都必须在GROUP BY子句中给出。因为结果返回的是对分组后的各个组进行聚集的结果，而不是对单条记录的统计结果</li>
<li>如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回</li>
<li>GROUP BY 子句必须在 WHRER 子句之后，ORDER BY 子句之前（ORDER BY 永远在最后）</li>
</ol>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>可以使用 HAVING 子句过滤分组，类似于 WHERE 子句用来过滤行。实际上所有基本的 WHERE 子句都可以用 HAVING 来替代。HAVING 支持所有的 WHERE 操作符。</p>
<p>可以理解为：WHERE 在数据分组前过滤，HAVING 在数据分组后过滤。如果不指定 GROUP BY，那么 HAVING 和 WHERE 对大多 DBMS 来说是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders </span><br><span class="line">FROM orders </span><br><span class="line">GROUP BY cust_id </span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<p>上面的代码中 HAVING 子句过滤了订单在两个以上（COUNT(* )&gt;&#x3D;2）的分组。</p>
<h3 id="将-WHERE-和-HAVING-一块使用"><a href="#将-WHERE-和-HAVING-一块使用" class="headerlink" title="将 WHERE 和 HAVING 一块使用"></a>将 WHERE 和 HAVING 一块使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_price &gt;= 4 </span><br><span class="line">GROUP BY vend_id </span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<p>上面的代码先使用 WHERE 过滤数据，然后对过滤后的数据分组，然后过滤分组。</p>
<h2 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h2><p>GROUP BY 分组的数据一般是以分组顺序输出的，但这不是 SQL 规范所要求的。</p>
<p>一般在使用 GROUP BY 时，也要用 ORDER BY 子句。</p>
<h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><p>SELECT子句及其顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT //选择要返回的列或表达式 </span><br><span class="line">FROM //从表中检索数据 </span><br><span class="line">WHERE //行级过滤 </span><br><span class="line">GROUP BY //分组 </span><br><span class="line">HAVING //组级过滤 </span><br><span class="line">ORDER BY //输出排序</span><br></pre></td></tr></table></figure>
<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL可以使用子查询，即嵌套在其他查询内的查询</p>
<h2 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h2><p>嵌套的层数没有限制，但是实际使用一般不嵌套太多层。</p>
<p><strong>作为子查询的 SELECT 语句只能查询单个列</strong></p>
<p>在 SELECT 语句中，子查询是从内向外处理的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, cust_name, cust_city, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">					FROM orders</span><br><span class="line">					WHERE order_num IN (SELECT order_num </span><br><span class="line">										FROM orderitems</span><br><span class="line">										WHERE prod_id = &quot;RGAN01));</span><br></pre></td></tr></table></figure>
<p>上面的程序通过三层嵌套查询获得了订购产品 RGAN01 的所有顾客的详细信息。</p>
<p>（<strong>这个例子中，考虑到可能有产品订购数量和RGAN01一样，故数据有可能比实际的多</strong>）</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>也可以把子查询 SELECT 语句作为外层查询的计算字段。</p>
<p>计算字段中的子查询为外层查询检索出的每个项目执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_state, (</span><br><span class="line">		SELECT COUNT(*) </span><br><span class="line">		FROM orders </span><br><span class="line">		WHERE orders.cust_id = customers.cust_id) AS orders //这里使用了完全限定列名。 </span><br><span class="line">FROM customers </span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>
<p>上面的代码查询了所有顾客的订单数量。</p>
<h3 id="完全限定列名"><a href="#完全限定列名" class="headerlink" title="完全限定列名"></a>完全限定列名</h3><p>表名加列名就构成了完全限定列名，使用一个句点分隔表名和列名。</p>
<p>如果在 SELECT 语句中操作多个表，就应该使用完全限定列名来避免歧义。</p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><p>SQL可以在数据查询中联结表。这是SQL中最重要、最强大的特性</p>
<h3 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h3><p>关系数据库设计的基础：避免相同的数据出现多次</p>
<p>关系表的设计要把信息分解成多个表。一类数据一个表。各个表通过一些共同值来互相关联。这样使关系数据库的可伸缩性非常好（即能够很好地适应不断增加的工作量）、、</p>
<h3 id="联结-1"><a href="#联结-1" class="headerlink" title="联结"></a>联结</h3><p>是一种机制，用来在一条SELECT语句中联结多个表返回一组输出</p>
<p>是在DBMS查询时建立起来的，实际数据库表中不存在</p>
<h3 id="引用完整性"><a href="#引用完整性" class="headerlink" title="引用完整性"></a>引用完整性</h3><p>在联结不同表时，要维护好引用的完整性。</p>
<p>比如 Products 表中存储了一些商品，每个商品有对应的供应商 ID，另有一个表 Vendors 存储了所有的供应商，那么应保证 Products 中的所有商品的供应商 ID 在 Vendors 中都存在，不能向 Products 中插入 Vendors 表中没有的供应商 ID。</p>
<p>在 DBMS 的图形界面上一般可以进行相关设置，以保证引用完整性</p>
<h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, vendors.vend_id, prod_name, prod_price </span><br><span class="line">FROM vendors, products </span><br><span class="line">WHERE vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<p>上面的代码中 FROM 子句列出了两个表，这两个表通过 WHERE 子句建立了联结。</p>
<h3 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a>WHERE子句的重要性</h3><p>在一条 SELECT 语句中联结几个表时，相应的关系是在运行中构造的。</p>
<p>联结两个表时，实际上就是将第一个表中的每一行与第二个表中的每一行配对。</p>
<p>WHERE 子句作为过滤条件（这里是联结条件），只包含那些匹配给定条件的行。没有 WHERE 子句，第一个表中的每一行将于第二个表中的每一行配对，而不管它们逻辑上是否能配在一起。</p>
<p>要保证所有联结都有 WHERE 子句。</p>
<blockquote>
<p>[!NOTE] 笛卡尔积<br>没有联结条件的表关系返回的结果是笛卡尔积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
</blockquote>
<h3 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h3><p>上面使用的联结被称为等值联结，基于两个表之间的相等测试，也称为内联结</p>
<p>可以用另一种即join</p>
<p><strong>注意：当使用了 JOIN 关键字后，就不能再用 WHERE，而必须用 ON。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, vendors.vend_id, prod_name, prod_price </span><br><span class="line">FROM vendors INNER JOIN products </span><br><span class="line">ON vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><h2 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h2><p>SQL 除了可以对列名和计算字段使用别名，还可以给表名起别名。</p>
<p>给表名起别名有两个作用：</p>
<ol>
<li>缩短 SQL 语句。</li>
<li>允许在一条 SELECT 语句中多次使用相同的表。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact </span><br><span class="line">FROM customers AS C, orders AS O, orderitems AS OI //在 FROM 子句中定义表别名 </span><br><span class="line">WHERE C.cust_id = O.cust_id AND O.order_num = OI.order_num AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>表的别名可以用于 WHERE 子句，SELECT 列表等各个部分。</p>
<p>列别名会返回到客户端，而表别名只在查询执行中使用，不返回到客户端。</p>
<h2 id="使用不同类型的内联结"><a href="#使用不同类型的内联结" class="headerlink" title="使用不同类型的内联结"></a>使用不同类型的内联结</h2><p>除了内联结（等值联结）外，还有三种其他联结：自联结、自然联结、外联结。</p>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><p>通过表别名可以在一条 SELECT 语句中不止一次引用相同的表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT A.cust_id, A.cust_name, A.cust_contact </span><br><span class="line">FROM customers AS A, customers AS B </span><br><span class="line">WHERE A.cust_name = B.cust_name AND A.cust_contact = &#x27;Jim Jones&#x27;;</span><br></pre></td></tr></table></figure>
<p>使用子查询可以实现相同功能，但是自联结速度一般快很多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, cust_name, cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE cust_name = (SELECT cust_name </span><br><span class="line">					FROM customers </span><br><span class="line">					WHERE cust_contact = &#x27;Jim Jones&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h2><p>因为联结的多个表必然具有相同的列，因此有时可能返回多次相同的列（实际应用中，基本所有的内联结都是自然联结）。</p>
<p>自然联结排除多次出现，使每一列只返回一次。</p>
<p>自然联结并不是系统完成的，而是要求你自己完成：只能选择那些唯一的列。一般通过对一个表使用通配符(SELECT * )，而对其他表的列使用明确的子集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_price </span><br><span class="line">FROM customers AS C, orders AS O, orderitems AS OI </span><br><span class="line">WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来</p>
<h2 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h2><p>内联结是将一个表中的行与另一个表中的行（按行依次匹配）相关联，外联结可以包含没有关联行（即对应的列为 NULL）的那些行。</p>
<p>使用关键字 OUTER JOIN 来指定联结类型，同时用 RIGHT 或 LEFT 关键字指定包含其所有行的表（RIGHT 包含右边的表，LEFT 包含左边的表）。</p>
<p>下面这个 LEFT 表示要查询 customers 中所有的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num </span><br><span class="line">FROM customers LEFT OUTER JOIN orders </span><br><span class="line">ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>还有一种外联结是全外联结，它检索两个表中的所有行并关联那些可以关联的行。全外联结包含两个表的不关联的行（MariaDB、MySQL 和 SQLite不支持全联结）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num </span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>
<h2 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h2><p>聚集函数可以和联结一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id, COUNT(orders.order_num) AS num_ord </span><br><span class="line">FROM customers INNER JOIN orders </span><br><span class="line">ON customers.cust_id = orders.cust_id </span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>上面的例子将检索出的行按 customers.cust_id 分组并聚集。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id, COUNT(orders.order_num) AS num_ord </span><br><span class="line">FROM customers LEFT OUTER JOIN orders </span><br><span class="line">ON customers.cust_id = orders.cust_id </span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>上面的例子将检索出的行按 customers.cust_id 分组并聚集，其中对于在 orders 中没有的 customers.cust_id，它的 num_ord 为 0。</p>
<h2 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h2><p>联结使用的要点：</p>
<ol>
<li>注意所使用的联结类型。一般使用内联结，有时也要用到外联结。</li>
<li>确切的联结语法应该查看 DBMS 的具体文档。</li>
<li>保证使用正确的联结条件。应该总是提供联结条件。</li>
<li>在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型</li>
</ol>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>使用 UNION 操作符将多条 SELECT 语句组合成一个结果</p>
<h2 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h2><p>执行多个查询并将结果作为一个查询结果集返回</p>
<ol>
<li>在一个查询中从不同的表返回数据</li>
<li>对一个表执行多个查询，按一个查询返回数据</li>
</ol>
<p>多数情况，组合相同表的两个查询所完成的工作与有多个 WHERE 子句条件的一个查询所完成的工作相同</p>
<h2 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h2><p>可用 UNION 操作符来组合数条 SQL 查询。</p>
<p>使用 UNION 很简单，给出每条SELECT 语句，在各条语句之间放上关键字 UNION 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;) </span><br><span class="line">UNION </span><br><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_name = &#x27;Fun4All&#x27;;</span><br></pre></td></tr></table></figure>
<p>上面组合查询的结果是两个查询结果的并集。</p>
<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><ol>
<li>每个查询必须包含相同的列、表达式或聚集函数（各个列不需要以相同的次序列出）</li>
<li>必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION 分隔（因此，如果组合四条SELECT 语句，将要使用三个 UNION 关键字）</li>
<li>列数据类型必须兼容，类型不必完全相同，但必须是 DBMS 可以隐含转换的类型</li>
</ol>
<h3 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h3><p>默认情况下 UNION 从查询结果集中自动去除了重复的行；如果想返回所有的匹配行，可使用 UNION ALL 而不是 UNION。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;) </span><br><span class="line">UNION ALL </span><br><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_name = &#x27;Fun4All&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="对组合查询结果进行排序"><a href="#对组合查询结果进行排序" class="headerlink" title="对组合查询结果进行排序"></a>对组合查询结果进行排序</h3><p>在用 UNION 组合查询时，只能使用一条 ORDER BY 子句，它必须位于最后一条SELECT 语句之后。DBMS 将用它来排序所有 SELECT 语句返回的所有结果。</p>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>INSERT 用来将行插入（或添加）到数据库表。插入有几种方式：</p>
<ol>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入某些查询的结果</li>
</ol>
<h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><h4 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h4><p>直接按表中列的顺序列出各列的值，没有值就使用 NULL。这种方法可移植性差，容易出错，不提倡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers </span><br><span class="line">VALUES(&#x27;1000000006&#x27;, &#x27;Toy Land&#x27;, &#x27;123 Any Street&#x27;, &#x27;New York&#x27;, &#x27;NY&#x27;, &#x27;11111&#x27;, &#x27;USA&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure>
<h4 id="明确给出列名"><a href="#明确给出列名" class="headerlink" title="明确给出列名"></a>明确给出列名</h4><p>在表名后的括号里明确指定列名。优点是可移植性强，且即使表的结构改变也可以工作。建议使用这种方式</p>
<p>这种方式下各列的顺序可以随意调换，只要列名与列值相对于即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email) </span><br><span class="line">VALUES( &#x27;1000000006&#x27;, &#x27;Toy Land&#x27;, &#x27;123 Any Street&#x27;, &#x27;New York&#x27;, &#x27;NY&#x27;, &#x27;11111&#x27;, &#x27;USA&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure>
<h4 id="插入部分行"><a href="#插入部分行" class="headerlink" title="插入部分行"></a>插入部分行</h4><p>使用明确给出列名的方式还可以省略列，只提供一部分列的值。</p>
<p>省略的列必须满足：该列被定义为允许 NULL 或在表的定义中给出了该列的默认值（这表示如果不提供值将使用默认值）</p>
<h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><p>可以利用它将 SELECT 语句的结果插入表中，这就是所谓的 INSERT SELECT。它是由一条 INSERT 语句和一条 SELECT 语句组成的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers( cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) </span><br><span class="line">SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country </span><br><span class="line">FROM CustNew;</span><br></pre></td></tr></table></figure>
<p>这个例子在 INSERT 和 SELECT 语句中使用了相同的列名。但是不一定要求列名匹配。DBMS 不关心 SELECT 返回的列名。它使用的是列的位置，因此 SELECT 中的第一列（不管其列名）将用来填充表列中指定的第一列，第二列将用来填充表列中指定的第二列，如此等等。</p>
<p>INSERT SELECT 中 SELECT 语句可以包含 WHERE 子句，以过滤插入的数据</p>
<p>INSERT 通常只插入一行。要插入多行，必须执行多个INSERT 语句。INSERT SELECT是个例外，它可以用一条 INSERT 插入多行，不管 SELECT 语句返回多少行，都将被INSERT 插入</p>
<h2 id="从一个表复制到另一个表"><a href="#从一个表复制到另一个表" class="headerlink" title="从一个表复制到另一个表"></a>从一个表复制到另一个表</h2><p>有一种数据插入不使用 INSERT 语句。要将一个表的内容复制到一个全新的表（运行中创建的表），可以使用 SELECT INTO 语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="operator">/</span><span class="operator">/</span>要想只复制部分的列，可以明确给出列名 </span><br><span class="line"><span class="keyword">INTO</span> CustCopy </span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure>
<p>MySQL、MariaDB、Oracle、PostgreSQL 和 SQLite 不使用 SELECT INTO，而使用 CREATE 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE CustCopy AS </span><br><span class="line">SELECT * FROM Customers;</span><br></pre></td></tr></table></figure>
<p>在使用 SELECT INTO 时，需要知道一些事情：</p>
<ol>
<li>任何 SELECT 选项和子句都可以使用，包括 WHERE 和 GROUP BY；</li>
<li>可利用联结从多个表插入数据；</li>
<li>不管从多少个表中检索数据，数据都只能插入到一个表中。</li>
</ol>
<h1 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h1><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>更新（修改）表中的数据，可以使用 UPDATE 语句。有两种使用 UPDATE 的方式：</p>
<ol>
<li>更新表中的特定行；</li>
<li>更新表中的所有行。</li>
</ol>
<p><strong>在使用 UPDATE 时一定要细心。因为稍不注意，就会更新表中的所有行</strong></p>
<p>基本的UPDATE 语句由三部分组成，分别是：</p>
<ol>
<li>要更新的表；</li>
<li>列名和它们的新值；</li>
<li>确定要更新哪些行的过滤条件。如果没有 WHERE 子句，将更新所有行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Customers </span><br><span class="line">SET cust_contact = &#x27;Sam Roberts&#x27;, cust_email = &#x27;kim@thetoystore.com&#x27; </span><br><span class="line">WHERE cust_id = &#x27;1000000005&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="删除某个列的值"><a href="#删除某个列的值" class="headerlink" title="删除某个列的值"></a>删除某个列的值</h3><p>要删除某个列的值，可通过 UPDATE 设置它为 NULL（假如表定义允许NULL 值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Customers </span><br><span class="line">SET cust_email = NULL </span><br><span class="line">WHERE cust_id = &#x27;1000000005&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>从一个表中删除（去掉）数据，使用 DELETE 语句。有两种使用 DELETE的方式</p>
<ol>
<li>从表中删除特定的行</li>
<li>从表中删除所有的行<br>在使用 DELETE 时一定要细心。因为稍不注意，就会错误地删除表中所有行</li>
</ol>
<p>如果某个行通过外键与其他表中的行相连接，则 DELETE 将抛出错误并中止。</p>
<p>DELETE 不需要列名或通配符。DELETE 删除整行而不是删除列。要删除指定的列，请使用 UPDATE 语句</p>
<h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><p>使用 UPDATE 或 DELETE 时所遵循的重要原则：</p>
<ol>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带 WHERE 子句的 UPDATE 或 DELETE 语句。</li>
<li>保证每个表都有主键，尽可能像 WHERE 子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在 UPDATE 或 DELETE 语句使用 WHERE 子句前，应该先用 SELECT 进行测试，保证它过滤的是正确的记录，以防编写的WHERE 子句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样 DBMS 将不允许删除其数据与其他表相关联的行。</li>
<li>有的 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 语句。如果所采用的 DBMS 支持这个特性，应该使用它。</li>
</ol>
<h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>一般有两种创建表的方法：</p>
<ol>
<li>多数 DBMS 都具有交互式创建和管理数据库表的工具（这本质上也是通过 SQL 语句创建的）。</li>
<li>表也可以直接用 SQL 语句操纵。</li>
</ol>
<p>CREATE TABLE 语句用来创建表。使用 CREATE TABLE 语句时要给出下列信息：</p>
<ol>
<li>新表的名字，在关键字 CREATE TABLE 之后给出；</li>
<li>表列的名字和定义，用逗号分隔；</li>
<li>有的 DBMS 还要求指定表的位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Products </span><br><span class="line">( //注意使用的是圆括号 </span><br><span class="line">	prod_id CHAR(10) NOT NULL, </span><br><span class="line">	vend_id CHAR(10) NOT NULL, </span><br><span class="line">	prod_name CHAR(254) NOT NULL, </span><br><span class="line">	prod_price DECIMAL(8,2) NOT NULL, </span><br><span class="line">	pro_desc TEXT(1000) NULL </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的 TEXT 只适用于 MySQL，在 Oracle、PostgreSQL、SQL Server 和 SQLite 中要换成 VARCHAR。</p>
<p>注意创建新表时，指定的表名必须之前不存在。</p>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>NULL 值就是没有值，允许 NULL 值的列也允许在插入行时不给出该列的值。</p>
<p>每个表列要么是 NULL 列，要么是 NOT NULL 列。这在创建时由表的定义规定，不指明的话默认为 NULL 列。</p>
<p>只有 NOT NULL 列才能作为主键。</p>
<h3 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h3><p>SQL 允许通过关键字 DEFAULT 指定某一列的默认值，在插入行时如果不给出值，DBMS 将自动采用默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE OrderItems </span><br><span class="line">( </span><br><span class="line">	prod_id CHAR(10) NOT NULL, </span><br><span class="line">	quantity INTEGER NOT NULL DEFAULT 1, </span><br><span class="line">	order_time CHAR(30) NOT NULL DEFAUTL CURRENT_DATE(), //指定系统时间为默认值 </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>默认值经常用于日期或时间戳列，将系统日期作为默认日志。</p>
<h2 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h2><p>可以使用 ALTER TABLE 语句更新表定义。不同 DBMS 的 ALTER TABLE 的可更新范围不同。</p>
<p>使用 ALTER TABLE 更改表结构，必须给出下面的信息：</p>
<ol>
<li>在 ALTER TABLE 之后给出要更改的表名（该表必须存在，否则将出错）；</li>
<li>列出要做哪些更改。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Vendors </span><br><span class="line">ADD vend_phone CHAR(20);</span><br></pre></td></tr></table></figure>
<p>上面的例子给 Vendors 增加了一列。更改或删除列、增加约束或增加键等操作也使用类似的语法。</p>
<p>可以在一条 ALTER 语句中对一个表进行多次更改，不同更改间用逗号分隔</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>理想情况下，不要在表中包含数据时对其进行更新。</li>
<li>所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。</li>
<li>许多 DBMS 不允许删除或更改表中的列</li>
<li>多数 DBMS 允许重新命名表中的列。</li>
<li>许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。</li>
</ol>
<p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p>
<ol>
<li>用新的列布局创建一个新表；</li>
<li>使用 INSERT SELECT 语句从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ol>
<p>使用 ALTER TABLE 要极为小心，应该在进行改动前做完整的备份（表结构和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们。</p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>删除表使用 DROP TABLE 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE CustCopy;</span><br></pre></td></tr></table></figure>
<p>删除表没有确认，也不能撤销，执行 DROP TABLE 语句将永久删除表。</p>
<p>许多 DBMS 允许强制实施有关规则，防止删除与其他表相关联的表。此时如果对某个表发布一条 DROP TABLE 语句，且该表是某个关系的组成部分，则 DBMS 将阻止这条语句执行。</p>
<h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><p>DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 用户使用 RENAME 语句重命名表。</p>
<p>MySQL 重命名表的方式如下，可以在单个 RENAME 语句中重命名多个表，不同重命名间用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE customers TO customers2, </span><br><span class="line">			vendors TO vendors2;</span><br></pre></td></tr></table></figure>
<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚拟的表，不包含数据，只包含查询语句</p>
<p>理解：视图实际上是把一个查询包装为了一个虚拟表，虚拟表的内容就是包装起来的查询的结果。</p>
<p>创建视图之后，可以用与表基本相同的方式使用它们。可以对视图执行 SELECT 操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加和更新数据。</p>
<p>视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p><strong>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。</strong></p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ol>
<li>重用 SQL 语句。</li>
<li>简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。</li>
<li>使用表的一部分而不是整个表。</li>
<li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ol>
<h3 id="使用视图的一些规则和限制"><a href="#使用视图的一些规则和限制" class="headerlink" title="使用视图的一些规则和限制"></a>使用视图的一些规则和限制</h3><ol>
<li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的 DBMS 中有所不同（嵌套视图可能会严重降低查询的性能，因此在使用之前，应该对其进行全面测试）。</li>
<li>许多 DBMS 禁止在视图查询中使用 ORDER BY 子句，MySQL 允许。</li>
<li>有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。</li>
<li>视图不能索引，也不能有关联的触发器或默认值。</li>
<li>有些 DBMS 把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表</li>
</ol>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>视图用 CREATE VIEW 语句来创建。</p>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW ProductCustomers AS </span><br><span class="line">SELECT cust_name, cust_contact, prod_id </span><br><span class="line">FROM Customers, Orders, OrderItems </span><br><span class="line">WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num;</span><br></pre></td></tr></table></figure>
<p>上面的例子创建了一个名为 ProductCustomers 的视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM ProductCustomers WHERE prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>上面的例子通过 WHERE 子句从视图中检索数据。</p>
<p>利用视图，可一次性编写基础的 SQL，然后根据需要多次使用。</p>
<h3 id="利用视图重新格式化检索出的数据"><a href="#利用视图重新格式化检索出的数据" class="headerlink" title="利用视图重新格式化检索出的数据"></a>利用视图重新格式化检索出的数据</h3><p>视图的另一常见用途是重新格式化检索出的数据。</p>
<p>对于以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27; </span><br><span class="line">AS vend_title </span><br><span class="line">FROM Vendors </span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<p>如果经常要使用上述格式，可以创建一个视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW VendorLocations AS </span><br><span class="line">SELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27; </span><br><span class="line">AS vend_title </span><br><span class="line">FROM Vendors;</span><br></pre></td></tr></table></figure>

<p>之后再进行格式化查询就可以通过视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM VendorLocations;</span><br></pre></td></tr></table></figure>
<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><p>视图对于应用普通的WHERE子句很有用</p>
<h3 id="用视图简化计算字段"><a href="#用视图简化计算字段" class="headerlink" title="用视图简化计算字段"></a>用视图简化计算字段</h3><p>在简化计算字段的使用上，视图也特别有用。</p>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>删除视图，可以使用 DROP 语句，其语法为 DROP VIEW viewname;。</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>更新视图必须先删除它，然后再重新创建。</p>
<p>MySQL 中更新视图还可以使用 CREATE OR REPLACE VIEW 语句。如果要更新的视图不存在，它会创建一个视图；如果要更新的视图存在，它会替换原有视图。</p>
<h1 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>经常会有一些复杂的操作需要多条 SQL 语句才能完成，这时可以创建存储过程。</p>
<p>存储过程就是为以后使用而保存的一条或多条SQL 语句。</p>
<h2 id="为什么要使用"><a href="#为什么要使用" class="headerlink" title="为什么要使用"></a>为什么要使用</h2><p>存储过程的用处：</p>
<ol>
<li>通过把处理封装在一个易用的单元中，可以简化复杂的操作。</li>
<li>保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。也能减少错误。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员不需要知道这些变化。</li>
<li>因为存储过程通常以编译过的形式存储，所以 DBMS 处理命令所需的工作量少，提高了性能。</li>
<li>存在一些只能用在单个请求中的SQL 元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</li>
</ol>
<p>简而言之，存储过程的三个优点：简单、安全、高性能。</p>
<h2 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h2><p>使用 EXECUTE 语句执行存储过程。注意 MySQL 使用的是 CALL 而不是 EXCUTE。</p>
<p>EXECUTE 语句接受存储过程名和需要传递给它的参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> AddNewProduct( <span class="string">&#x27;JTS01&#x27;</span>, <span class="string">&#x27;Stuffed Eiffel Tower&#x27;</span>, <span class="number">6.49</span>, <span class="string">&#x27;Plush&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>对于具体的DBMS，可能包括以下的执行选择：</p>
<ol>
<li>参数可选，具有不提供参数时的默认值；</li>
<li>不按次序给出参数，以“参数&#x3D;值”的方式给出参数值。</li>
<li>输出参数，允许存储过程在正执行的应用程序中更新所用的参数。</li>
<li>用 SELECT 语句检索数据。</li>
<li>返回代码，允许存储过程返回一个值到正在执行的应用程序。</li>
</ol>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>MySQL版本的一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE productPricing() //如果存储过程接受参数，它们将在()中列举出来 </span><br><span class="line">BEGIN </span><br><span class="line">	SELECT Avg(prod_price) AS pricaverage </span><br><span class="line">	FROM products </span><br><span class="line">END; </span><br><span class="line">DROP PROCEDURE productPricing; //删除存储过程</span><br></pre></td></tr></table></figure>
<h1 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h1><p>可以利用 COMMIT 和 ROLLBACK 语句管理事务处理。</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>事务处理（transaction processing）确保成批的 SQL 操作要么完全执行，要么完全不执行，可以用来维护数据库的完整性。</p>
<p>事务处理是一种机制，用来管理必须成批执行的 SQL 操作，保证数据库不包含不完整的操作结果。</p>
<p>利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态。</p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>事务：一组 SQL 语句。</li>
<li>回退：撤销指定的 SQL 语句。</li>
<li>提交：将未存储的 SQL 语句结果写入到数据库表。</li>
<li>保留点：事务处理中设置的临时占位符，可以对它发布回退。</li>
</ul>
<p>事务处理用来管理 INSERT、UPDATE 和 DELETE 语句。不能回退SELECT语句（也没有必要）、CREATE 、DROP。</p>
<h2 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h2><p>管理事务的关键在于将SQL语句组分解为逻辑块，并明确数据何时应该回退，何时不应该</p>
<p>MySQL 和 MariaDB 中的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION ... //这些语句必须完全执行或完全不执行。</span><br></pre></td></tr></table></figure>

<p>SQL Server 使用的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION ... <span class="keyword">COMMIT</span> TRANSACTION</span><br></pre></td></tr></table></figure>

<p>Oracle 中等同的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET TRANSACTION ...</span><br></pre></td></tr></table></figure>

<h3 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h3><p>SQL 中的 ROLLBACK 命令用来回退（撤销）SQL 语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders; </span><br><span class="line"><span class="keyword">ROLLBACK</span>; <span class="operator">/</span><span class="operator">/</span>撤销上面的 <span class="keyword">DELETE</span> 语句</span><br></pre></td></tr></table></figure>
<h3 id="使用Commit"><a href="#使用Commit" class="headerlink" title="使用Commit"></a>使用Commit</h3><p>一般的SQL语句都是针对数据库表直接执行和编写的，属于隐式提交，即提交操作自动进行</p>
<p>在事务处理块中，提交不会隐式进行。而是使用 COMMIT 语句进行明确的提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION </span><br><span class="line">DELETE FROM ordersitems WHERE order_num = 20010; </span><br><span class="line">DELETE FROM orders WHERE order_num = 20010; COMMIT;</span><br></pre></td></tr></table></figure>
<p>当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭。</p>
<h3 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h3><p>使用简单的ROLLBACK和COMMIT语句，可以写入或撤销整个事务</p>
<p>有时只想回退部分事务，可以在事务处理块中的合适位置放置占位符，回退时可以回退到某个占位符，称为保留点</p>
<p>使用 SAVEPOINT 语句创建保留点。</p>
<p>在 MySQL 、MariaDB 和 Oracle 中，如下进行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT delete1; </span><br><span class="line">ROLLBACK TRANSACTION delete1;</span><br></pre></td></tr></table></figure>
<p>保留点越多越好，可以在 MySQL 代码中设置任意多的保留点。保留点会在事务处理完成后自动释放。</p>
<h1 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h1><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>SQL 检索操作返回一组称为结果集的行，这组返回的行都是与 SQL 语句相匹配的行（零行或多行）。有时需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在</p>
<p>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p>主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。游标对基于Web 的应用用处不大。</p>
<p>Mysql中的游标只能用于存储过程和函数</p>
<h2 id="使用游标-1"><a href="#使用游标-1" class="headerlink" title="使用游标"></a>使用游标</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用 DECLARE 语句创建游标，并定义相应的 SELECT 语句，根据需要带 WHERE 和其他子句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders() </span><br><span class="line">BEGIN </span><br><span class="line">	DECLARE ordernumbers CURSOR </span><br><span class="line">	FOR </span><br><span class="line">	SELECT order_num FROM orders; </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>上面的存储过程定义了一个游标，存储过程结束后游标就会消失。</p>
<h2 id="使用游标-2"><a href="#使用游标-2" class="headerlink" title="使用游标"></a>使用游标</h2><p>定义游标后可以打开游标，使用 OPEN 语句打开游标，然后使用 FETCH 语句访问游标数据，最后使用 CLOSE 语句关闭游标。</p>
<p>FETCH 指出要检索哪些行，从何处检索它们以及将它们放于何处（如变量名）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN ordernumbers //处理 OPEN 语句时会执行对应的查询并存储检索出的数据以供浏览和滚动。 FETCH ordernumbers INTO var; //用 FETCH 检索当前行的 order_num 列（自动从第一行开始）并存到局部变量 var 中。 </span><br><span class="line">CLOSE ordernumbers //关闭游标</span><br></pre></td></tr></table></figure>
<p>例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders() </span><br><span class="line">BEGIN </span><br><span class="line">	//声明局部变量 </span><br><span class="line">	DECLARE done BOOLEAN DEFAULT 0; </span><br><span class="line">	DECLARE o INT; </span><br><span class="line">	DECLARE t DECIMAL(8, 2); </span><br><span class="line">	//创建游标 </span><br><span class="line">	DECLARE ordernumbers CURSOR </span><br><span class="line">	FOR </span><br><span class="line">	SELECT order_num FROM orders; </span><br><span class="line">	//声明 continue handler，这是在条件出现时被执行的代码。 </span><br><span class="line">	//SQLSTATE&#x27;02000&#x27; 是一个未找到条件，当 REPEAT 由于没有更多的行供循环而不能继续时，出现这个条件。 </span><br><span class="line">	DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;02000&#x27; SET done=1; //当 SQLSTATE &#x27;02000&#x27; 出现时，SET done=1。 </span><br><span class="line">	//创建一个表用来存储结果 </span><br><span class="line">	CREATE TABLE IF NOT EXISTS ordertotals (order_num INT, total DECIMAL(8, 2)); </span><br><span class="line">	//打开游标 </span><br><span class="line">	OPEN ordernumbers; </span><br><span class="line">	//循环所有行 </span><br><span class="line">	REPEAT </span><br><span class="line">		FETCH ordernumbers INTO o; </span><br><span class="line">		CALL ordertotal(o, 1, t); </span><br><span class="line">		INSERT INTO ordertotals(order_num, total) VALUES(o, t); </span><br><span class="line">	UNTIL done END REPEAT; //反复执行直到 done=1 </span><br><span class="line">	//关闭游标 </span><br><span class="line">	CLOSE ordernumbers; </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h1 id="高级SQL特性"><a href="#高级SQL特性" class="headerlink" title="高级SQL特性"></a>高级SQL特性</h1><p>SQL 的几个高级数据处理特性：约束、索引、触发器。</p>
<p>约束是实施引用完整性的重要部分，索引可改善数据检索的性能，触发器可以用来执行运行前后的处理，安全选项可用来管理数据访问。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束是管理如何插入或处理数据库数据的规则。</p>
<p>关系数据库存储分解为多个表的数据，每个表存储相应的数据。利用键来建立从一个表到另一个表的引用，由此产生了引用完整性。</p>
<p>DBMS 通过在数据库表上施加约束来实施引用完整性。大多数约束是在表定义中定义的，用 CREATE TABLE 或 ALTER TABLE 语句。</p>
<h3 id="主键-1"><a href="#主键-1" class="headerlink" title="主键"></a>主键</h3><p>主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或多个列）的值唯一标识表中的每一行。</p>
<p>任意列只要满足以下条件，就可以用于主键</p>
<ol>
<li>任意两行的主键值不同</li>
<li>每行都有一个主键值（列中不允许有NULL值）</li>
<li>包含主键值的列从不修改或更新。主键值不能重用。如果从表中删除某一行，其主键值不分配给新行</li>
</ol>
<p>在表定义时用PRIMARY KEY关键字声明主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Vendors </span><br><span class="line">( </span><br><span class="line">	vend_id CHAR(10) NOT NULL PRIMARY KEY, </span><br><span class="line">	vend_name CHAR(50) NOT NULL, </span><br><span class="line">	vend_address CHAR(50) NULL, </span><br><span class="line">	vend_city CHAR(50) NULL, </span><br><span class="line">	vend_state CHAR(5) NULL, </span><br><span class="line">	vend_zip CHAR(10) NULL, </span><br><span class="line">	vend_country CHAR(50) NULL</span><br></pre></td></tr></table></figure>
<p>使用 CONSTRAINT 语法定义主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Vendors</span><br><span class="line">ADD CONSTRAINT PRIMARY KEY (vend_id);</span><br></pre></td></tr></table></figure>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>是表中的一列，值必须列在另一表的主键中，外键是保证引用完整性的极其重要部分</p>
<p>外键除了保证引用完整性外，还能防止意外的删除。比如订单中定义了外键关联到顾客，那么要想删除顾客必须先删除所有与该顾客相关联的订单项。</p>
<p>使用REFERENCES关键字声明外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Orders </span><br><span class="line">( </span><br><span class="line">	order_num INTEGER NOT NULL PRIMARY KEY, </span><br><span class="line">	order_date DATETIME NOT NULL, </span><br><span class="line">	cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id) );</span><br></pre></td></tr></table></figure>
<p>上面的例子在 Orders 的 cust_id 列上定义了一个外键，这样 cust_id 中的任何值都必须是 Customers 表中的 cust_id 值。</p>
<p>使用 CONSTRAINT 语法声明外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Venders </span><br><span class="line">ADD CONSTRAINT REFERENCES Customers(cust_id);</span><br></pre></td></tr></table></figure>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>用来保证一列（或一组列）中数据唯一。类似主键，但有以下区别：</p>
<ol>
<li>表中可以包含多个唯一约束，但每个表只允许一个主键</li>
<li>唯一约束列可包含NULL值</li>
<li>唯一约束列可以修改或更新</li>
<li>唯一约束列的值可以重复用</li>
<li>与主键不一样，唯一约束不能用来定义外键。</li>
</ol>
<p>唯一约束的语法类似于其他约束的语法。唯一约束既可以用 UNIQUE 关键字在表定义中定义，也可以用单独的 CONSTRAINT 定义</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点：</p>
<ol>
<li>检查最小或最大值。例如防止 0 个物品的订单（即使 0 是合法的数）。</li>
<li>指定范围。</li>
<li>只允许特定的值</li>
</ol>
<p>数据类型限制了列中可保存的数据的类型，检查约束在数据类型内又做了进一步的限制。</p>
<p>使用关键字 CHECK 添加检查约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE OrderItems </span><br><span class="line">( </span><br><span class="line">	order_num INTEGER NOT NULL, </span><br><span class="line">	order_item INTEGER NOT NULL, </span><br><span class="line">	prod_id CHAR(10) NOT NULL, </span><br><span class="line">	quantity INTEGER NOT NULL CHECK (quantity &gt; 0), </span><br><span class="line">	item_price MONEY NOT NULL </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用 CONSTRAINT 语法添加检查约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Products </span><br><span class="line">ADD CONSTRAINT CHECK (gender LIKE &#x27;[MF]&#x27;) //使 gender 列只包含 M 或 F。</span><br></pre></td></tr></table></figure>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引用来排序数据以加快搜索和排序操作的速度。</p>
<p>数据库索引的作用与书籍中索引&#x2F;目录的作用一样。</p>
<p>主键数据总是排序的，这是 DBMS 的工作。因此，按主键检索特定行总是一种快速有效的操作。但是，搜索其他列中的值通常效率不高。</p>
<p>可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS 以使用书的索引类似的方法使用它。DBMS 搜索排过序的索引，找出匹配的位置，然后检索这些行。</p>
<p>注意事项：</p>
<ol>
<li>索引改善检索操作的性能，但是降低了数据插入、修改和删除的性能。执行这些操作时，DBMS必须动态更新索引</li>
<li>索引数据可能占用大量存储空间</li>
<li>并非所有数据都适合做索引，取值不多的数据（如州）不如具有更多可能值的数据（如姓或名）能通过索引得到那么多的好处</li>
<li>索引用于数据过滤和数据排序。</li>
<li>可以在索引在定义多个列，例如，州加上城市。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处</li>
</ol>
<p>索引用 CREATE INDEX 语句创建，索引必须唯一命名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX prod_name_id </span><br><span class="line">ON Products (prod_name);</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是特殊的存储过程，它在特定的事件（表更改）发生时自动执行。触发器可以与特定表上的 INSERT、UPDATE 和 DELETE 操作（或组合）相关联。</p>
<p>与存储过程不一样（存储过程只是简单的存储 SQL 语句），触发器与单个的表相关联。与 Orders 表上的 INSERT 操作相关联的触发器在 Orders 表中插入行时执行。</p>
<p>触发器中的代码有如下数据的访问权</p>
<ol>
<li>INSERT 操作中的所有新数据；</li>
<li>UPDATE 操作中的所有新数据和旧数据；</li>
<li>DELETE 操作中删除的数据。</li>
</ol>
<p>常见用途如下：</p>
<ol>
<li>保证数据的一致性。例如，在 INSERT 或 UPDATE 操作中将所有州名转换为大写。</li>
<li>基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表。</li>
<li>进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入。</li>
<li>计算计算列的值或更新时间戳。</li>
</ol>
<p>一般约束比触发器快，因此尽量用约束</p>
<p>只有表才支持触发器，视图和临时表都不支持</p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>使用 CREATE TRIGGER 创建触发器，触发器可以在一个操作发生前或发生后执行。</p>
<p>需要给出4条信息</p>
<ol>
<li>唯一的触发器名：触发器应该有一个在数据库内唯一的名字</li>
<li>触发器关联的表</li>
<li>触发器应该响应的活动（DELETE、INSERT 或 UPDATE）</li>
<li>触发器何时执行（处理之前（BEFORE）或之后（AFTER））</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products //触发器在表 products 的 INSERT 语句成功执行后执行。 </span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;;</span><br></pre></td></tr></table></figure>

<p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条 INSERT、UPDATE 和 DELETE 的之前和之后）。</p>
<p>触发器失败：如果 BEFORE 触发器失败，则将不执行请求的操作。如果 BEFORE 触发器或语句本身失败，将不执行 AFTER 触发器。</p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p><code>DROP TRIGGER newproduct;</code></p>
<h3 id="使用INSERT触发器"><a href="#使用INSERT触发器" class="headerlink" title="使用INSERT触发器"></a>使用INSERT触发器</h3><p>INSERT触发器在 INSERT 语句执行之前或之后执行。需要知道以下几点：</p>
<ol>
<li>在INSERT触发器代码内，可以引用一个名为NEW的虚拟表，访问被插入的行</li>
<li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li>
<li>对于 AUTO_INCREMENT 列（这种列具有 MySQL 自动赋予的值），NEW 在 INSERT 执行之前包含 0，在 INSERT 执行之后包含新的自动生成值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders </span><br><span class="line">FOR EACH ROW SELECT NEW.order_num; //每次插入新订单时都显示订单号</span><br></pre></td></tr></table></figure>
<p>之前执行的话一般用于数据验证和净化</p>
<h3 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h3><p>DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：</p>
<ol>
<li>在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；</li>
<li>OLD 中的值全都是只读的，不能更新。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders </span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN </span><br><span class="line">	INSERT INTO archive_orders(order_num, order_date, cust_id)</span><br><span class="line">	VALUES(OLD.order_num, OLD.order_date, OLD.cust_id) </span><br><span class="line">END; //将要被删除的订单保存到名为 archive_orders 的存档表中</span><br></pre></td></tr></table></figure>

<h3 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h3><p>UPDATE触发器在 UPDATE 语句执行之前或之后执行。需要知道以下几点：</p>
<ol>
<li>在 UPDATE 触发器代码中，可以引用一个名为 OLD 的虚拟表访问以前（UPDATE 语句前）的值，引用一个名为 NEW 的虚拟表访问新更新的值；</li>
<li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新（允许更改将要用于 UPDATE 语句中的值）</li>
<li>OLD中的值全是只读的，不能更新</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors </span><br><span class="line">FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state); //保证每个州名都是大写。</span><br></pre></td></tr></table></figure>
<h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><p>大多数 DBMS 都给管理员提供了管理机制，利用管理机制授予或限制对数据的访问。</p>
<p>任何安全系统的基础都是用户授权和身份确认。</p>
<p>一般说来，需要保护的操作有：</p>
<ol>
<li>对数据库管理功能（创建表、更改或删除已存在的表等）的访问；</li>
<li>对特定数据库或表的访问；</li>
<li>访问的类型（只读、对特定列的访问等）；</li>
<li>仅通过视图或存储过程对表进行访问；</li>
<li>创建多层次的安全措施，从而允许多种基于登录的访问和控制；</li>
<li>限制管理用户账号的能力。</li>
</ol>
<p>安全性使用 GRANT 和 REVOKE 语句来管理，不过，大多数 DBMS 提供了交互式的管理实用程序，这些实用程序在内部使用 GRANT 和 REVOKE 语句。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka—弥合日志系统和消息队列的鸿沟</title>
    <url>/2025/09/15/Kafka%20%E2%80%94%E2%80%94%20%E5%BC%A5%E5%90%88%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%B8%BF%E6%B2%9F/</url>
    <content><![CDATA[<p>一个崭新的针对日志处理的消息系统，名为 <strong>Kafka</strong>。Kafka 兼顾了<strong>日志聚合</strong>需求和<strong>消息队列</strong>需求。一方面来说，Kafka 是一个支持平滑扩展，支持高吞吐的分布式系统；另一方面，Kafka 提供了类似于消息队列的 API，并且允许应用对日志消息进行实时消费。</p>
<p>论文发表时，Kafka 已经在 LinkedIn 上线了六个多月，只用一个系统就满足了我们两大方面的需求，从而极大简化了我们的基础设施</p>
<span id="more"></span>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Kafka是日志处理和消息队列系统的集大成者。较低的延迟、极高的容量和吞吐，使其可以应用于在线服务和离线业务。为了兼顾性能和可扩展性，Kafka 做了一些看起来反直觉但是却很实用的设计。例行总结一下其设计特点：</p>
<ol>
<li>面向存储的消息队列：意味在近实时的情况下能够将传统消息队列的存储增加几个数量级。实现原理是充分利用了磁盘的顺序写和操作系统自身的缓存；此外为了提高访盘、传输效率，使用了文件分段、段首索引、零拷贝和批量拉取等技术。</li>
<li>灵活的生产消费方式：总体而言是基于主题粒度的发布订阅式架构，并且既支持<strong>组内多消费者</strong>互斥消费，也支持不同<strong>消费者组</strong>间的重复消费。涉及到消息队列的两个核心选择：pull式消费以及客户端侧存储消费进度。pull式消费可能会导致空轮询和稍微的延迟，好处是灵活；客户端存储式消费可以使broker无状态，以进行灵活伸缩和容错。为了简化实现，消费时，每个分区最多为一个消费者所消费。</li>
<li>zookeeper存储元信息：利用分布式一致性组件 Zookeeper 以注册表的形式存储系统元信息，包括 broker 和消费者的存活信息、消费者和分区间的对应关系、每个分区的消费进度等等</li>
<li>分区级别的多副本设计：利用该条可以实现对 broker 的容错。</li>
<li>简洁强大的消费接口：Kafka 的客户端一般提供两层接口抽象。包括无需关注<strong>分区</strong>和<strong>偏移量</strong>信息的高层（high-level）_简单读写_接口，以及可以灵活控制分区组织和消费进度的低层（low-level）接口</li>
</ol>
<h1 id="相关系统"><a href="#相关系统" class="headerlink" title="相关系统"></a>相关系统</h1><p>传统的企业级消息系统（如 activemq， IBM Websphere MQ， Oracle Enterprise Messaging Service，TIBCO Enterprise Message Service）已经存在很长时间了，主要作用是<strong>消息总线</strong>和<strong>异步解耦</strong>。但它们并不能无缝适配日志处理需求，主要有以下几点原因：</p>
<ul>
<li>语义侧重点不同：传统消息队列侧重于提供灵活的消息送达保证，比如多个队列的事务问题、消息送达的 ACK 确认、消息的严格保序等等。这些功能在日志处理系统中需求并不是那么高，但是他们大大增加了 API 复杂性和系统实现的难度。</li>
<li>高吞吐支持差：大部分传统的消息队列都不将高吞吐作为第一设计目标。比如 JMS 连 batch 接口都没有，因此每发一个消息都会使用一个新的 TCP 连接，显然不能满足我们日志系统高吞吐的需求</li>
<li>不支持分布式存储：这些传统消息系统通常不容易进行切片（partition）以存储到多台机器上。因此在数据量大时，不能支持平滑扩容。</li>
<li>面向实时而非累积：这些消息系统的另一个特点是假设消费类型是<strong>近实时消费</strong>（near immediate），因而未被消费的消息的量总是和。一旦消息产生累积，这类消息系统的性能将大大下降。因此他们难以支持离线消费和大批量消费的任务类型。说白了，传统的消息系统的设计思路并不面向<strong>存储</strong>。</li>
</ul>
<h1 id="架构和设计原则"><a href="#架构和设计原则" class="headerlink" title="架构和设计原则"></a>架构和设计原则</h1><h2 id="概念体系"><a href="#概念体系" class="headerlink" title="概念体系"></a>概念体系</h2><p>由于上述系统的诸多限制，我们开发了一个基于消息的日志聚合系统 ——Kafka。首先介绍一些 Kafka 的概念体系</p>
<ul>
<li>主题：定义了某种消息流的类型</li>
<li>生产者：会将消息发布到某个主题下，这些发布的消息会被暂时屯在一组叫做代理商（broker）的服务器中</li>
<li>一个消费者可以从代理商那同时订阅一到多个主题，然后以拉取的方式进行消费。</li>
</ul>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>消息系统应该是很简单的，为了表达这种简单，我们将 Kafka 的接口（API）设计的很简约。为了避免枯燥的描述这些 API，我们用两个很简单的小例子来说明 Kafka 的 API 长啥样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer = new Producer(…);  </span><br><span class="line">message = new Message(“test message str”.getBytes());  </span><br><span class="line">set = new MessageSet(message);  </span><br><span class="line">producer.send(“topic1”, set);</span><br></pre></td></tr></table></figure>

<p>如代码所示，一条消息的格式很简单，就是一组字节，用户可以根据喜好来对数据进行序列化（即将对象实例编码成一组字节）。为了提高效率，可以一次发送一组消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">streams[] = Consumer.createMessageStreams(“topic1”, 1)  </span><br><span class="line">for (message : streams[0]) &#123;  </span><br><span class="line">    bytes = message.payload();  </span><br><span class="line">    // do something with the bytes  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者通过创建一个或多个流来订阅 topic，被发布到相应 topic 的消息会渐次进入这些消费者创建的订阅流。</p>
<p>在语言层面，我们将每个消息流抽象为一个迭代器（Iterator）， 消费者利用该迭代器取出一条条消息的消息体以进行处理。和一般的迭代器不同，我们的迭代器永不停止，当无新消息到来时，迭代器就会一直阻塞。我们同时支持两种消费模式，既可以一组消费者对某个 topic 进行<strong>互斥</strong>消费，也可以每个消费者对同一个主题进行<strong>独立</strong>消费。</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://dl.z.wiki/autoupload/fr/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251013/4iob/1246X827/kafka_structure.png" alt="1246X827&#x2F;kafka_structure.png"><br>Kafka 是分布式系统，因此一个 Kafka 集群中会包含多个 broker 机器。为了均摊负载，每个 topic 被切分成多个分片（Partition)，每个 broker 机器持有其中的一个或多个分片。多个生产者和消费者可以同时进行消息的生产和消费</p>
<h2 id="单个分区的效率"><a href="#单个分区的效率" class="headerlink" title="单个分区的效率"></a>单个分区的效率</h2><h3 id="极简的存储设计"><a href="#极简的存储设计" class="headerlink" title="极简的存储设计"></a>极简的存储设计</h3><p>一个 topic 的每个分区就是逻辑上的一段日志。具体到物理上，为了防止分区文件过大，我们会将其进一步分成数据段（segment）</p>
<p>每次数据往最新的数据段中写，写到设定容量（比如说 1G）后，就会新建一个段文件继续写。此外，为了提高写入性能，我们会将日志记录在内存中进行缓存，只有日志数量达到设定值或者缓存数据的大小达到设定值时，才会将数据刷到外存中。为了保证可靠性，只有数据刷到了外存后，才会将其暴露给消费者。</p>
<p>Kafka存储的每条消息没有显式的消息ID，而仅通过该条消息在分片中的偏移量（offset）来定位。这样我们省却了为了随机查找而建立的索引的额外开销。值得一提的是，我们的偏移量并不是连续的，而是类似于 TCP 中的 SEQ 的字节 offset—— 为了计算下一条消息的偏移量，我们需要将当前消息偏移量加上当前消息长度</p>
<p>每个消费者总是<strong>顺序的</strong>去消费每个分区的数据，如果消费者每<strong>确认</strong>（ack）一个偏移量，就意味着该偏移量前面的所有消息都被消费过了。实现上来说，消费者端的库代码会向 broker 发一系列请求来拉取数据到消费者的缓冲区中供应用代码来消费。</p>
<p><strong>每个拉取请求包含了起始偏移地址和可以接受的字节尺寸。每个 Broker 在内存中维护了数据段首偏移量到数据段物理地址的映射（应该是用查找树组织的，因为需要范围定位）。当一个读取请求到来时</strong>，broker 根据请求偏移量来定位到相应的段，然后根据请求尺寸来读出指定的数据量，然后返回给消费者</p>
<p>费者收到消息后，计算出下一条消息的偏移量，以进行下一次拉取请求</p>
<h3 id="高效的传输优化"><a href="#高效的传输优化" class="headerlink" title="高效的传输优化"></a>高效的传输优化</h3><p>对于<strong>生产者</strong>，我们在 API 层面允许一次发送一批消息。对于消费者，虽然在 API 层面看起来是逐条消息进行消费，但在底层也是会批量拉取，比如每次都一次拉取数百 KB</p>
<p>另一个与众不同的设计决策在于，我们不在 Kafka 系统层面进行<strong>显式</strong>的消息缓存。也就是说，我们仅仅利用文件系统层面的页缓存（page cache）来实现加速硬盘读写的目的。这样做好处有二：</p>
<ol>
<li>避免消息的多次缓存</li>
<li>broker 进程重启后缓存不丢失</li>
</ol>
<p>在 Kafka 的应对的场景中，生产者和消费者都是顺序的访问段文件，并且消费者通常只是稍落后生产者。操作系统默认的写穿透（write-through）和预读取（read-ahead）等启发式的缓存策略天然适配该场景</p>
<p>还优化了消费者远程数据访问过程。因为 Kafka 是一个支持多次订阅的系统，一条消息可能被不同的消费者消费多次，因此远程数据访问的优化能够极大提升系统性能</p>
<p>传统上，一条数据从本地文件送到 socket 上通常包含以下几个过程：</p>
<ol>
<li>从外存中读入数据到操作系统的页缓存</li>
<li>从页缓存拷贝数据到应用缓冲区</li>
<li>从应用缓冲区拷贝到内核缓冲区</li>
<li>从内核缓冲区拷贝到socket</li>
</ol>
<p>这些过程涉及四次数据拷贝和两次系统调用，可以说非常冗余浪费。在 Linux 和其他一些操作系统中，存在一个 sendfile （zero copy，零拷贝技术）的 API，能够直接将数据从文件传送到 socket 中。利用此 API，可以省去步骤（2）（3）中引入的两次数据拷贝和一次系统调用，由此使得 Kafka 可以将数据从 broker 的段文件中高效的传输给消费者。</p>
<h3 id="无状态的broker"><a href="#无状态的broker" class="headerlink" title="无状态的broker"></a>无状态的broker</h3><p>其他消息队列不同，在 Kafka 中，broker 不负责保存每个消费者的消费进度。也就说是，每个消费者需要自己保存自己的消费偏移量等信息，从而使 broker 的设计可以相对简化，不用维护过多状态</p>
<p>但如此一来，由于 broker 不知道所有订阅者的消费进度，就难以决定何时对某条消息进行删除。</p>
<p>Kafka 使用了一个看似 tricky 的策略 —— 按时间窗口对消息进行保存。比如说，只保存最近七天的数据。当然，每个 topic 可以设置不同的策略。这个简单的策略大部分情况下都很够用，即使是离线消费者也通常会每天，每小时甚至近实时进行消费，七天足以。Kafka 并不会随着数据量增大而显著降低性能，这个保证是允许 Kafka 使用如此简单的策略的关键所在</p>
<p>这种大量存储 + 拉取的设计带来的另外一个重要的好处是 —— 消费者可以主动选择进行回退（rewind）消费。这个需求看起来违背了通常消息队列的定义，然而在很多情况下却非常有必要。随便举两个例子：</p>
<ol>
<li>当消费者进程由于错误而挂掉后，可以在恢复后有选择的对挂掉前后的数据重新消费。这对将 ETL 数据导入 Hadoop 等数据仓库之类的场景非常重要</li>
<li>消费者会定期的将拉取的数据刷到持久化的存储中（比如倒排索引系统中）。如果消费者宕机，那部分已经从 消息系统拉取但是未持久化的数据就会被丢失。但是对于 Kafka 来说，消费者只需要记住 flush 到的 offset 即可，下次重启后再从该 offset 后开始拉取。但是对于传统没有大量缓存的消息队列来说，可能这部分数据就永远的丢了，或者得在消费端做某种错误备份和恢复的复杂策略。</li>
</ol>
<h2 id="多机协调"><a href="#多机协调" class="headerlink" title="多机协调"></a>多机协调</h2><p>下面我们来讨论多个生产者和消费者在分布式环境中的行为。对于生产者，其发送数据时，可以将其随机发送到一个分区所在 broker；也可以根据 Key 以及作用于 Key 上的路由函数，将其发送到某特定分区机器（broker）上。对于消费者，行为稍复杂，接下来将会详细说明。</p>
<p>Kafka 有个概念叫做_消费者组_（consumer groups）。同一个消费者组中包含多个消费者，这些消费者会<strong>互斥</strong>的消费一组 topic，即，对于一条消息，仅会被同组消费者中的一个所消费。不同的消费者组会进行独立消费，即每个消费者组维护自己的消费进度，不需要进行协同。一个消费者组内的每个消费者可以分属不同进程甚至不同机器，我们目标是在不引入过多额外开销的情况下将消息均匀的分发到每个消费者</p>
<p>第一个决策是将每个<strong>分片作为最小的并行粒度</strong>。即每个分区最多为一个消费者所消费，如果我们允许多个消费者消费同一个分区，势必会引入锁之类的协调机制并且记录下一些状态以跟踪每个消费者的消费状态，这会加大实现难度。而在我们的设计中，只有在消费者数量变动，需要重新平衡流量的时候才需要协调。为了能使每个消费者流量更均衡，建议是让分区个数远大于消费者个数，这点很容易实现，只需要给 topic 配置更多分区即可。</p>
<p>第二个决策是<strong>不引入中心的主节点</strong>，代之以让所有消费者以去中心化的形式进行协调。如果使用中心节点，我们还得去关心其容错问题，又引入了不必要的复杂度。为了让消费者更好的进行协调，我们引入了一个高可用的一致性服务 ——Zookeeper。Zookeeper 的 API 很像文件系统，是以前缀树的形式组织的 KV （<em>K 是路径，以 ‘&#x2F;‘ 来区分层次，V 可以是任何可序列化的值</em>）存储。该 API 支持创建一个路径、给一个路径设置值、读取路径的值、删除一个路径、列出某个路径下所有子节点的值。此外，Zookeeper 还具有以下特性：</p>
<ol>
<li>客户端可以向某个路径注册一个回调函数，以监听该路径的值或其孩子节点的变动。</li>
<li>路径可以被创建为易失的（ephemeral），即当所有该路径的客户端消失后，该路径及值会被自动的移除。</li>
<li>Zookeeper 使用一致性协议将其数据进行多机备份，使其服务具有高可靠性和高可用性。</li>
</ol>
<p>Kafka 使用 Zookeeper 干了以下几件事情：</p>
<ol>
<li>监控 brokers 和消费者的增删。</li>
<li>当出现 brokers 或者消费者的增删时，启动消费再平衡任务。</li>
<li>维护消费者的间关系状态，跟踪每个分区的消费偏移量。</li>
</ol>
<p>具体来说，当一个 broker 或消费者启动时，它会将元信息存在 Zookeeper 中的注册表（registry）中。</p>
<ol>
<li>broker 的注册表包括 broker 的主机名和端口号、以及存于其上的 topics 和分区。</li>
<li>消费者的注册表包括其所属的消费者组以及订阅的 topic。</li>
</ol>
<p>每个消费者组都在 Zookeeper 中有一个相关联的所有权注册表和偏移量注册表。</p>
<ol>
<li>我们将消费者消费某个分区的行为称为占有，所有权注册表（ownership registry）即记录了消费者与其占有的分区间的对应关系。其中，路径名标识一个分区，记录值是该分区的拥有者。</li>
<li>偏移量记录表记录了该消费者组所有订阅的 topic 对应的每个分区的消费进度（即偏移量）。</li>
</ol>
<p>Zookeeper 中 broker 的注册表、消费者的注册表和拥有关系的注册表是<strong>易失的</strong>，而偏移量注册表是<strong>永久的</strong>（persistent）。当一个 broker 死掉时，其上所有分区会自动从 broker 注册表中删除。当一个消费者死掉时，其在消费者注册表的条目会被删除，在拥有关系的注册表中所拥有的分区关系条目也会被删除。每个消费者都会监听 broker 注册表和消费者注册表，当有 broker 变动或者消费者组中成员变动的时候，就会接收到通知。</p>
<p>当某个消费者加入或者消费者组中有成员变化时，该消费者就会启动一个再平衡（re-balance）的进程以决定他需要消费哪个分区集。伪码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Algorithm 1: rebalance process for consumer Ci in group G</span><br><span class="line">For each topic T that Ci subscribes to &#123;</span><br><span class="line">    remove partitions owned by Ci from the ownership registry</span><br><span class="line">    read the broker and the consumer registries from Zookeeper</span><br><span class="line">    compute PT = partitions available in all brokers under topic T</span><br><span class="line">    compute CT = all consumers in G that subscribe to topic T</span><br><span class="line">    sort PT and CT</span><br><span class="line">    let j be the index position of Ci in CT and let N = |PT|/|CT|</span><br><span class="line">    assign partitions from j*N to (j+1)*N - 1 in PT to consumer Ci</span><br><span class="line">    for each assigned partition p &#123;</span><br><span class="line">        set the owner of p to Ci in the ownership registry</span><br><span class="line">        let Op = the offset of partition p stored in the offset registry</span><br><span class="line">        invoke a thread to pull data in partition p from offset Op</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法如上，简单来说就是该消费者去 Zookeeper 拿到所有 topic。对于每个 topic ，拿到分区集合 set (Pt) 以及所属消费者组的消费者集合 Ct。然后将分区集尽量等分为 |Ct| 块，该消费者按照一个确定性算法挑去其中一块，比如说按某种特定方式对 Ct 和 Pt 进行排序。之后，每个消费者对于每个属于自己分区启动一个线程进行拉取，并且从偏移量注册表中保存的偏移量开始消费。随着分区中的数据被不断的消费，消费者会不断的在注册表中更新偏移量。</p>
<p>当消费者或者 broker 出现变动时，同一个消费者组中的所有消费都会收到通知，由于网络等原因，每个消费者收到通知的时间会有先后关系。当先收到通知的消费者在运行上述算法去拿新的分区的数据时，很可能发现该分区还被其他消费者占有。对于这种情况，我们采用一个很简单的策略：该消费者将自己占有的分区释放掉，并且等一小会，然后进行重试。在实际运行中，一般再平衡程序在几次重试后就能达到稳定。</p>
<p>当一个新的消费者组创建时，注册表中没有任何的偏移量记录。这时，使用 broker 提供的 API，该消费者组可以针对每个分区选择从最小的偏移量或者最大的偏移量进行消费（这取决于消费者组的配置）。</p>
<h2 id="数据交付保证"><a href="#数据交付保证" class="headerlink" title="数据交付保证"></a>数据交付保证</h2><p>原则上，Kafka 仅提供” 至少一次”（at-least-once）的交付语义。恰好一次（exactly-once）交付语义可以通过两阶段提交来保证，但是在我们应用场景中，这并不是必须的。其实大部分时候，在网络状况良好的一般机房中，大部分消息都都会被消费者组恰好消费一次，仅在消费者进程异常退出没有做正常的清理工作时（比如没有将最后消费到的 offset 更新到 Zookeeper），那么新的消费者在启动时，就会重复的消费那部分 offset 没有提交的数据。如果应用不能够容忍这种情况，就必须在应用逻辑中增加消息去重的逻辑，可以用一个字典来存储最近消费过的数据的 id 进行去重，该 id 可以是 Kafka 中给 message 的 offset，也可以是用户自定义的和消息一一对应的某个 key。这种方法的性能要好于在 Kafka 层面使用两阶段提交的方法来保证恰好一次的语义。</p>
<blockquote>
<p>[!NOTE] 次数<br>一般来说，数据在交付时，由于系统意外宕机、网络抖动等问题，会出现数据条目丢失的情况。在这个情况下，如果我们不进行介入，那么所有就是提供至多一次的语义（at-most-once）。如果我们对丢失的数据条目进行重试，就有可能造成多次交付的情况，因为发送端无法确定接收端是在接收到数据后网络出了问题，还是接受前出了问题，无脑重试的话，就有可能造成同一条数据的多次处理，这种情况下我们提供的是至少一次（at-least-once）的交付语义。如果想强行实现恰好一次（exactly-once）的交付语义也不是不可以，比如使用两阶段提交等一致性方法保证数据消费和偏移量更新的原子性，以提供恰好消费一次的语义。但是这样仍有可能出问题，并且使系统复杂度变高，时间耗费也较多。所以一般如果对丢少量数据不敏感，用 at-most-once 就够了，如果敏感，可以用 at-least-once 并在应用层去重。</p>
</blockquote>
<p>Kafka 保证来自于同一个分区的消息是保序的，即 offset 大小顺序，但是不同分区之间的顺序是不保证的。为了避免数据出错，Kafka 在每个消息中保存了一个 CRC 校验和。当 broker 遇到 IO 问题时，在恢复时，可以把 CRC 校验不一致的消息给删掉。由于 CRC 保存在消息中，生产和消费的环节都可以检查一下 CRC 来规避网络传输带来的错误。</p>
<p>当一个 broker 宕机时，其上面所有消息将会变为不可用。进一步，如果 broker 的存储系统完全坏掉，其上面的未消费消息将永远丢失。将来，我们计划提供内置的多机冗余备份，以容忍单个 broker 节点偶然出现问题（当然现在 2019 也早已经实现了）</p>
<h1 id="一些自己感觉重要的东西强调"><a href="#一些自己感觉重要的东西强调" class="headerlink" title="一些自己感觉重要的东西强调"></a>一些自己感觉重要的东西强调</h1><h2 id="阐述-Kafka-生产者和消费者的工作原理"><a href="#阐述-Kafka-生产者和消费者的工作原理" class="headerlink" title="阐述 Kafka 生产者和消费者的工作原理"></a>阐述 Kafka 生产者和消费者的工作原理</h2><p>Kafka 生产者的工作原理如下：首先，生产者将消息发送到 Kafka 集群。它会把消息序列化为字节数组，以便在网络上传输。然后，根据指定的分区策略，决定将消息发送到哪个分区。如果没有指定分区，会根据消息的键（key）来计算分区，以确保具有相同键的消息被发送到同一个分区，这有助于实现数据的有序性和局部性。生产者还可以配置一些参数，如 acks，来控制消息发送的确认机制。当 acks 设置为 0 时，生产者发送消息后不等待任何确认，性能最高但可能会丢失消息；当 acks 设置为 1 时，生产者会等待分区的 leader 副本确认消息已收到；当 acks 设置为 -1（或 all）时，生产者会等待所有的 in - sync replicas（ISR）都确认收到消息，这能保证消息的可靠性，但可能会影响性能。</p>
<p>Kafka 消费者的工作原理是：消费者通过订阅主题（topic）来获取消息。它会从指定的分区中拉取消息，消费者会记录自己已经消费到的偏移量（offset），以便在下次启动时能够从上次中断的地方继续消费。消费者可以以单线程或多线程的方式处理消息。在一个消费组（consumer group）中，每个消费者实例会负责消费主题的一部分分区，这样可以实现水平扩展，提高消费能力。消费者还可以配置一些参数，如 auto - commit - interval，来控制偏移量的自动提交间隔。如果关闭自动提交，消费者需要手动提交偏移量，以确保在处理完消息后才更新偏移量，避免消息的重复消费或丢失。</p>
<h2 id="Kafka消息机制"><a href="#Kafka消息机制" class="headerlink" title="Kafka消息机制"></a>Kafka消息机制</h2><p>Kafka 的消息机制基于主题（topic）和分区（partition）。主题是消息的逻辑分类，每个主题可以包含多个分区。消息被发送到主题的特定分区中，分区是 Kafka 进行数据存储和读取的基本单位，它保证了消息的顺序性。</p>
<p>当生产者发送消息时，消息会被追加到分区的末尾。每个消息在分区中都有一个唯一的偏移量（offset），用于标识消息在分区中的位置。消费者通过偏移量来确定从哪里开始消费消息。</p>
<p>Kafka 采用了发布 - 订阅模式，生产者将消息发布到主题，多个消费者可以订阅同一个主题来获取消息。消费者可以以不同的消费组进行订阅，每个消费组中的消费者会独立地消费消息，不同消费组之间互不影响。</p>
<p>在消息的存储方面，Kafka 将消息持久化到磁盘上，以保证消息的可靠性和可恢复性。它使用了分段日志文件（log segment）来存储消息，每个日志段包含一定数量的消息，当一个日志段达到一定大小或时间限制时，会创建新的日志段。这样可以方便地进行消息的删除和压缩等操作。</p>
<p>此外，Kafka 还支持消息的压缩，以减少网络传输和磁盘存储的开销。生产者可以在发送消息时对消息进行压缩，消费者在消费消息时会自动解压缩。</p>
<h2 id="Kafka-如何保证消息可靠"><a href="#Kafka-如何保证消息可靠" class="headerlink" title="Kafka 如何保证消息可靠"></a>Kafka 如何保证消息可靠</h2><p>Kafka 通过多种机制来保证消息的可靠性。</p>
<p>首先，在生产者端，通过设置 acks 参数来确保消息被可靠地发送到 Kafka 集群。当 acks 设置为 -1（或 all）时，生产者会等待所有的 ISR 中的副本都确认收到消息后才认为消息发送成功。这意味着即使 leader 副本出现故障，其他副本也已经保存了该消息，不会导致消息丢失。</p>
<p>其次，Kafka 集群采用了多副本机制来保证消息的可靠性。每个分区都有多个副本，其中一个是 leader 副本，其他是 follower 副本。生产者发送的消息会首先被发送到 leader 副本，然后由 leader 副本将消息复制到 follower 副本。当 leader 副本出现故障时，Kafka 会自动从 follower 副本中选举出新的 leader 副本，保证消息的继续处理和不丢失。</p>
<p>再者，消费者端通过手动提交偏移量的方式来保证消息的可靠消费。当消费者处理完一条消息后，再手动提交偏移量，这样即使消费者在处理消息过程中出现故障，重新启动后也可以从上次提交的偏移量处继续消费，避免消息的重复消费或丢失。</p>
<p>另外，Kafka 还提供了消息的持久化机制，将消息存储在磁盘上，并通过定期的日志刷盘和副本同步来保证消息的安全性。即使集群出现故障，也可以通过磁盘上的消息日志来恢复数据。</p>
<p>最后，Kafka 还支持数据的一致性检查和错误处理机制。例如，在消息的复制过程中，如果发现副本之间的数据不一致，会进行自动的修复和同步，确保数据的一致性和完整性。</p>
<h2 id="如果要保证一个消息持久化之后才会消费下一个消息，应该怎么做"><a href="#如果要保证一个消息持久化之后才会消费下一个消息，应该怎么做" class="headerlink" title="如果要保证一个消息持久化之后才会消费下一个消息，应该怎么做"></a>如果要保证一个消息持久化之后才会消费下一个消息，应该怎么做</h2><p>一种方法是在消费者端关闭自动提交偏移量功能，并在处理完当前消息且确认消息已持久化到存储介质（如数据库或文件系统）后，手动提交偏移量。这样，只有当消息被成功持久化后，偏移量才会更新，消费者下次启动时就会从下一个未处理的消息开始消费，保证了消息的顺序性和可靠性。</p>
<p>另一种方法是利用 Kafka 的事务功能。生产者可以使用事务来确保消息的原子性发送，即要么所有相关消息都成功发送并持久化，要么都不发送。消费者在消费时，可以设置为只消费已经提交事务的消息。这样可以保证在一个事务中的所有消息都被持久化后，消费者才会消费到这些消息，从而实现了消息的有序和可靠消费</p>
<p>还可以通过在应用程序层面实现一个消息队列，将从 Kafka 消费到的消息先放入这个队列中，然后在另一个线程中进行消息的持久化和确认操作。只有当消息被成功持久化并确认后，才从队列中取出下一个消息进行处理，从而保证了消息的顺序消费和持久化的可靠性。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>7-21 代码随想录之数组</title>
    <url>/2025/07/21/day1/</url>
    <content><![CDATA[<h1 id="704-二分查找-力扣（LeetCode）"><a href="#704-二分查找-力扣（LeetCode）" class="headerlink" title="704. 二分查找 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></h1><p>这是二分查找的模版题。二分查找两种思路：左闭右开和左闭右闭。</p>
<p>在进行二分查找的循环中，循环的条件就是查找的区间要是合法的，即区间内至少有1个元素，例如，在左闭右闭的方法中，[1, 1]中至少有“1”这个元素，区间合法；而对于左闭右开，[1, 1)中没有元素，这个区间就是非法的。</p>
<p>在确认区间合法后，才在区间中取中间值</p>
<p>对于左闭右闭：由于每一次查找都需要在合法区间中寻找，且此次循环的合法区间不能包含上一次循环中已经筛除的值，所以在更新左右端点的值时，左端点的下标为中点下标+1，右端点的下标为中点下标-1。</p>
<p>对于左闭右开：与上面一样，但是此时区间的右端点不在区间内，所以在更新左右端点的值时，左端点的下标为中点下标+1，右端点的下标为中点下标。</p>
<p>注意<br>无论是左闭右闭还是左闭右开，在初始化时都必须要让数组中的所有元素都在初始合法区间内，例如数组nums为{1， 2， 3， 4}， 对于左闭右闭，那么初始的合法区间为[0, nums.size() - 1]，而对于左闭右开，初始的合法区间应该为[0, nums.size())</p>
<p>给出代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="27-移除元素-力扣（LeetCode）"><a href="#27-移除元素-力扣（LeetCode）" class="headerlink" title="27. 移除元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a></h1><p>双指针，慢的指向最后一个非val的下一个元素，快的就一直遍历。每遇到一个非val的元素，就把它赋值给慢指针对应的位置</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] == val)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="977-有序数组的平方-力扣（LeetCode）"><a href="#977-有序数组的平方-力扣（LeetCode）" class="headerlink" title="977. 有序数组的平方 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a></h1><p>最开始想的是从数组左右两边遍历，然后将大的放在右边，小的放在左边。但是如果全是负数就会出错，因为不会有任何一个数的绝对值小于数组最右边那个数，则一旦最右边那个数至于最左边后就不会再交换了。</p>
<p>所以初始一个新的数组，然后从后往前填空，但是不改变原数组元素的顺序</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> pos = r;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[r]) &gt; <span class="built_in">abs</span>(nums[l]))&#123;</span><br><span class="line">                result[pos--] = nums[r] * nums[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result[pos--] = nums[l] * nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>Spark复习</title>
    <url>/2025/06/02/Spark/</url>
    <content><![CDATA[<p>Spark知识的复习</p>
<span id="more"></span>
<h1 id="为什么会有Spark"><a href="#为什么会有Spark" class="headerlink" title="为什么会有Spark"></a>为什么会有Spark</h1><ul>
<li>MapReduce计算模式有缺陷，包括IO性能低、延时高、数据共享麻烦等等</li>
<li>在内存计算上比MapReduce快100倍，磁盘快10倍</li>
<li>广泛性：结合SQL、流处理和复杂分析</li>
<li>多处运行：hadoop、云等运行</li>
<li>数据共享方便：利用内存加速计算</li>
</ul>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>从集群层面</p>
<ul>
<li>Master node：整个集群的控制器，管理workernode</li>
<li>worker node：是计算节点，接受主节点命令和进行状态汇报</li>
<li>executors：每个worker上有一个executors，负责完成task程序的执行<br>从系统层面</li>
<li>Driver是应用执行起点，负责作业调度</li>
<li>Worker管理计算节点，创建并行处理任务</li>
<li>Cache存储中间结果等<br>从应用程序的角度</li>
<li>Application：基于Spark的用户程序，包含一个Driver Program和多个Executor</li>
<li>Job：某个RDD的action算子生成或提交的一个或多个一系列的调度阶段，称为一个或多个Job</li>
<li>Stage：每个Job被拆分成一系列任务的集合，每组任务被称为一个Stage</li>
<li>Task：基本程序执行单元，在一个executor执行</li>
</ul>
<h1 id="RDD-基于内存计算的弹性分布式数据集"><a href="#RDD-基于内存计算的弹性分布式数据集" class="headerlink" title="RDD 基于内存计算的弹性分布式数据集"></a>RDD 基于内存计算的弹性分布式数据集</h1><ul>
<li>定义是能横跨集群所有节点进行并行计算的分区元素集合。</li>
<li>创建方式为由Hadoop文件系统的一个文件创建而来，或者从一个已有的Scala集合转换得到</li>
<li>只读，可分区，全部或部分可以缓存在内存中，在多次计算间重用。</li>
<li>包含一组RDD的Partition、对父RDD的一组依赖、父RDD上执行何种计算的一个函数和描述分区模式和数据存放位置的元数据四类信息。</li>
</ul>
<h1 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h1><p>Spark使用RDD以及对应的Transform（惰性操作）&#x2F;Action（立即计算）等操作算子执行分布式计算</p>
<ul>
<li>容错性：Lineage 基于RDD之间的依赖关系组成lineage， 以及重计算和checkpoint等机制；</li>
<li>只读，可分区：数据集的全部或部分可以缓存在内存中，在多次计算中重用</li>
<li>弹性：内存不够时可以与磁盘交换</li>
<li>一组RDD形成可执行的有向无环图DAG</li>
</ul>
<h1 id="RDD的容错实现"><a href="#RDD的容错实现" class="headerlink" title="RDD的容错实现"></a>RDD的容错实现</h1><ul>
<li>Lineage：使RDD可以通过记录RDD之间的变换，而不需要存储实际的数据，就可以恢复</li>
<li>CheckPoints：对于有很长Lineage的RDD，通过lineage恢复耗时较长，因此有必要设置检查点</li>
</ul>
<h1 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h1><ul>
<li>窄依赖：父RDD中的一个Partition最多被子RDD中的一个Partition依赖</li>
<li>宽依赖：父RDD中的一 个Partition被子RDD中的多个Partition所依赖</li>
</ul>
<h1 id="RDD持久化"><a href="#RDD持久化" class="headerlink" title="RDD持久化"></a>RDD持久化</h1><ul>
<li>未序列化的Java对象存于内存中，性能表现最优</li>
<li>序列化的数据存于内存中。</li>
<li>磁盘存储</li>
</ul>
<h1 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h1><ul>
<li>transform：使用这种操作只是定义了一个新的RDD，并没有计算‘</li>
<li>action：立即计算这个RDD的值，并返回结果给程序或者写入外存储。</li>
</ul>
<h1 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h1><ul>
<li>transformation和action：在RDD的transformation时，不进行作业提交，而在action操作时，才会触发SparkContext提交作业</li>
<li>Lineage：为了保证RDD数据的鲁棒性，Spark通过Lineage记录一个RDD如何通过一个或者多个父系RDD转变过来的，当数据丢失时，可以重新计算</li>
<li>Spark调度：采用了事件驱动的Scala库类Akka完成任务启动，通过复用线程池的方式来取代MapReduce进程或者线程启动或切换的开销</li>
<li>API：使用scala语言开发，并且默认Scala作为其 编程语言。因此，编写Spark程序比MapReduce程序要简洁得 多。同时，Spark系统也支持Java、Python语言进行开发</li>
<li>Spark生态：Spark SQL、Spark Streaming、GraphX等等为Spark的应+用提供了丰富的场景和模型，适合应用于不同的计算模式和计算任务</li>
<li>Spark部署：Spark拥有Standalone、Mesos、YARN等多种部署方式，可以部署在多种底层平台上</li>
</ul>
<h1 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h1><ul>
<li>用户编写的Spark程序提交到相应的框架中</li>
<li>Spark创建Spark Context作为本次运行环境</li>
<li>SparkContext连接相应的集群配置来确定程序的资源配置使用情况</li>
<li>连接集群资源成功后，Spark获取当前集群上存在Executor的节点，</li>
<li>Saprk分发程序代码到各个节点</li>
<li>最终SparkContext发送tasks到各个节点执行</li>
</ul>
<h1 id="Spark-数据倾斜如何解决？"><a href="#Spark-数据倾斜如何解决？" class="headerlink" title="Spark 数据倾斜如何解决？"></a>Spark 数据倾斜如何解决？</h1><p>数据倾斜是指在 Spark 作业中，数据在不同的分区或节点上分布不均衡，导致部分任务处理的数据量远大于其他任务，从而影响整个作业的执行效率。以下是一些解决 Spark 数据倾斜的方法。</p>
<p>首先，可以采用数据采样和调整分区策略。通过对数据进行采样，了解数据的分布情况，然后根据数据的分布特点调整分区数量和分区方式，使数据能够更加均匀地分布在各个分区中。例如，如果发现某个 key 的数据量特别大，可以将该 key 对应的记录分散到多个分区中。</p>
<p>其次，进行数据预处理。在数据进入 Spark 之前，对数据进行清洗和转换，去除无效数据和重复数据，减少数据量，降低数据倾斜的可能性。同时，可以对数据进行一些聚合操作，将相同 key 的数据提前进行合并，减少在 Spark 作业中的数据处理量。</p>
<p>再者，使用合适的算法和数据结构。对于一些容易导致数据倾斜的操作，如 join 操作，可以采用广播变量的方式将小表广播到各个节点，避免在 join 过程中出现数据倾斜。另外，选择合适的数据结构也很重要，例如使用哈希表来存储数据，可以提高数据的查找和处理效率，减少数据倾斜的影响。</p>
<p>此外，还可以调整 Spark 的配置参数。例如，调整 <code>spark.shuffle.memoryFraction</code> 参数，增加 shuffle 过程中可用的内存比例，避免因为内存不足导致数据溢写到磁盘，从而提高数据处理效率。同时，适当增加 <code>spark.default.parallelism</code> 参数的值，增加任务的并行度，使数据能够更均匀地分配到各个任务中。</p>
<h1 id="Spark-有什么算子"><a href="#Spark-有什么算子" class="headerlink" title="Spark 有什么算子"></a>Spark 有什么算子</h1><p>Spark 算子是对 RDD（弹性分布式数据集）进行操作的函数，可分为行动算子和转换算子。</p>
<h2 id="转换算子："><a href="#转换算子：" class="headerlink" title="转换算子："></a><strong>转换算子</strong>：</h2><ul>
<li><code>map</code>：对 RDD 中的每个元素进行一对一的转换操作 。</li>
<li><code>filter</code>：根据给定的条件筛选出 RDD 中的元素，例如筛选出一个整数列表中的偶数。</li>
<li><code>flatMap</code>：先对 RDD 中的每个元素进行操作，然后将结果扁平化，常用于处理包含多个元素的集合，如将一个包含多个单词列表的 RDD 转换为一个单词列表。</li>
<li><code>groupByKey</code>：按照键对键值对 RDD 进行分组，例如将一个包含学生姓名和成绩的 RDD 按照学生姓名进行分组。</li>
<li><code>reduceByKey</code>：对键值对 RDD 按照键进行归约操作，先在每个分区内进行局部归约，然后再在不同分区之间进行全局归约，常用于统计求和等操作。</li>
</ul>
<h2 id="行动算子："><a href="#行动算子：" class="headerlink" title="行动算子："></a><strong>行动算子</strong>：</h2><ul>
<li><code>reduce</code>：对 RDD 中的元素进行聚合操作，通过给定的函数将所有元素合并为一个结果，如计算一个整数列表的总和。</li>
<li><code>collect</code>：将 RDD 中的所有元素收集到驱动程序中，形成一个本地集合，方便在驱动程序中进行后续处理，但要注意当 RDD 数据量较大时，可能会导致内存溢出。</li>
<li><code>count</code>：返回 RDD 中的元素个数。</li>
<li><code>take</code>：返回 RDD 中的前 n 个元素，常用于快速查看 RDD 的部分数据。</li>
<li><code>saveAsTextFile</code>：将 RDD 中的数据保存为文本文件到指定的路径。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>7-244 代码随想录之链表</title>
    <url>/2025/07/24/day4/</url>
    <content><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点-力扣（LeetCode）"><a href="#19-删除链表的倒数第-N-个结点-力扣（LeetCode）" class="headerlink" title="19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></h1><p>先让cur节点往后跑n-1个，然后一起后移cur和pre。</p>
<p>这样当cur是最后一个节点时，pre就指向的是倒数第n个节点的前一个节点了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        ListNode* pre = dummynode;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> dummynode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="面试题-02-07-链表相交-力扣（LeetCode）"><a href="#面试题-02-07-链表相交-力扣（LeetCode）" class="headerlink" title="面试题 02.07. 链表相交 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></h1><p>设「第一个公共节点」为 node ，「链表 headA」的节点数量为 a ，「链表 headB」的节点数量为 b ，「两链表的公共尾部」的节点数量为 c ，则有：</p>
<p>头节点 headA 到 node 前，共有 a−c 个节点；<br>头节点 headB 到 node 前，共有 b−c 个节点；</p>
<p>那么让两个链表头先遍历完本身，再去从对方的头开始遍历，直到到达公共节点时指针 A , B 重合（如下所示）：<br>$a+(b−c)&#x3D;b+(a−c)$</p>
<p>并有两种情况：</p>
<ul>
<li>若两链表 有 公共尾部 (即 c&gt;0 ) ：指针 A , B 同时指向「第一个公共节点」node 。</li>
<li>若两链表 无 公共尾部 (即 c&#x3D;0 ) ：指针 A , B 同时指向 null 。<br>此时返回A、B均可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A = headA;</span><br><span class="line">        ListNode *B = headB;</span><br><span class="line">        <span class="keyword">while</span>(A != B)&#123;</span><br><span class="line">            A = A != <span class="literal">NULL</span>? A-&gt;next : headB;</span><br><span class="line">            B = B != <span class="literal">NULL</span>? B-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="142-环形链表-II-力扣（LeetCode）"><a href="#142-环形链表-II-力扣（LeetCode）" class="headerlink" title="142. 环形链表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></h1><p>能想到用快慢指针，快指针走2n步，慢指针走n步，通过是否碰撞来检测环的存在。</p>
<p>但是第一次确实没想到要怎么判断环的入口在哪里</p>
<p>借一下灵神的图吧<br> <img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250724/vR3R/986X829/LT142.png" alt="986X829&#x2F;LT142.png"></p>
<blockquote>
<p>[!NOTE] 链接<br><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/1999271/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-nvsq/">142. 环形链表 II - 力扣（LeetCode）</a></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">while</span> (slow != head) &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-21 代码随想录之数组</title>
    <url>/2025/07/21/day2/</url>
    <content><![CDATA[<h1 id="209-长度最小的子数组-力扣（LeetCode）"><a href="#209-长度最小的子数组-力扣（LeetCode）" class="headerlink" title="209. 长度最小的子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></h1><p>双指针维护子数组的左边界和右边界，一个变量记录和。</p>
<p><strong>注意：当和大于等于target时，需要循环减去左边界，因为当新加入的数特别大时，只减一次是不够的</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(f &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, f - s + <span class="number">1</span>);</span><br><span class="line">                    sum -= nums[s];</span><br><span class="line">                    s++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                f++;</span><br><span class="line">                <span class="keyword">if</span>(f &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    sum += nums[f];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX?<span class="number">0</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="58-区间和（第九期模拟笔试）"><a href="#58-区间和（第九期模拟笔试）" class="headerlink" title="58. 区间和（第九期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1070">58. 区间和（第九期模拟笔试）</a></h1><p>可以暴力，但是太慢了。</p>
<p>这里引入前缀和。前缀和可以简单理解为「数列的前n项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。</p>
<p>在这道题目中，计算的是区间内的和(设区间为a、b)，则该区间内的和就是前b项的和减去前a项的和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b))&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prefix[b]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = prefix[b] - prefix[a - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="44-开发商购买土地（第五期模拟笔试）"><a href="#44-开发商购买土地（第五期模拟笔试）" class="headerlink" title="44. 开发商购买土地（第五期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1044">44. 开发商购买土地（第五期模拟笔试）</a></h1><p>其实还是用前缀和的思想，但是这里最好是把整个二维数组观想成一维一维的数组（无论行列）。然后将每一维当作一个元素，去求整体的前缀和。</p>
<p>因为无论怎么分，都是以一行或者一列为单位的，那么这里面所有的元素都会划在同一个区域</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">            sum += vec[i][j];<span class="comment">//计算所有元素的和，因为只有两个区域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; m; j++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j == m - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line">            <span class="comment">//每经过一行，计算所有元素的和，然后计算result</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line">			<span class="comment">//同样作用在列上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>7-25 代码随想录之哈希表</title>
    <url>/2025/07/25/day5/</url>
    <content><![CDATA[<h1 id="242-有效的字母异位词-力扣（LeetCode）"><a href="#242-有效的字母异位词-力扣（LeetCode）" class="headerlink" title="242. 有效的字母异位词 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（LeetCode）</a></h1><p>可以用哈希，也可以直接大小为26的数组。如果是unicode字符，那就必须用哈希了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)&#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t)&#123;</span><br><span class="line">            hash[c]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : hash)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="349-两个数组的交集-力扣（LeetCode）"><a href="#349-两个数组的交集-力扣（LeetCode）" class="headerlink" title="349. 两个数组的交集 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></h1><p>维护一个set。前面插入，后面删除。如果删除成功（即之前加入了），就加入结果集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; n1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : nums1)&#123;</span><br><span class="line">            n<span class="number">1.</span><span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n<span class="number">1.</span><span class="built_in">erase</span>(b))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="202-快乐数-力扣（LeetCode）"><a href="#202-快乐数-力扣（LeetCode）" class="headerlink" title="202. 快乐数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></h1><p>既然有可能无限循环，那就说明会遇到重复的数。</p>
<p>简单计算一下，即使是9999计算后也只是324,。因此一个set是够存放的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SumSquare</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            ans = ans + (a * a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">SumSquare</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>优于select的epoll</title>
    <url>/2024/07/11/%E4%BC%98%E4%BA%8Eselect%E7%9A%84epoll/</url>
    <content><![CDATA[<h1 id="epoll理解和应用"><a href="#epoll理解和应用" class="headerlink" title="epoll理解和应用"></a>epoll理解和应用</h1><h2 id="select的缺点"><a href="#select的缺点" class="headerlink" title="select的缺点"></a>select的缺点</h2><ol>
<li>每次调用 select 函数前都要向操作系统传递监视对象信息；</li>
<li>调用完 select 函数后需要循环获取发生变化的文件描述符；</li>
<li>select 函数可以监视的最大文件描述符数量有限；</li>
</ol>
<p>前两个原因导致基于 select 函数的 I&#x2F;O 复用速度较慢。</p>
<h2 id="实现epoll时必要的函数和结构体"><a href="#实现epoll时必要的函数和结构体" class="headerlink" title="实现epoll时必要的函数和结构体"></a>实现epoll时必要的函数和结构体</h2><p>epoll 服务器端实现要用到 3 个函数和一个结构体。</p>
<p>3个函数：</p>
<ol>
<li>epoll_create：创建保存 epoll 文件描述符的空间。</li>
<li>epoll_ctl：向空间注册并注销文件描述符。</li>
<li>epoll_wait：与 select 函数类似，等待文件描述符发生变化。</li>
</ol>
<h3 id="epoll-event结构体"><a href="#epoll-event结构体" class="headerlink" title="epoll_event结构体"></a>epoll_event结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__uint32_t</span> events;</span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>  // 注意：<span class="title">epoll_data</span> 是一个联合不是结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>epoll_event 结构体在 epoll_ctl 和 epoll_wait 函数中都要用到，作用分别如下：</p>
<ol>
<li>在 epoll_ctl 中：指定向 epoll 例程注册文件描述符所关注的事件。用到的是 epoll_event 中的 events 成员。</li>
<li>在 epoll_wait 中：保存发生事件的文件描述符集合。用到的是 epoll_event 中的 data 成员的 fd 成员。</li>
</ol>
<h3 id="epoll-create函数"><a href="#epoll-create函数" class="headerlink" title="epoll_create函数"></a>epoll_create函数</h3><p>epoll 中由操作系统保存要监视的文件描述符，使用 epoll_create 函数向操作系统申请创建保存文件描述符的空间。这对应使用 select 函数时声明 fd_set 变量来保存要监视的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">        <span class="comment">// 功能：申请 size 大小的 epoll 例程（调用 epoll_create 函数创建的文件描述符保存空间称为 epoll 例程）</span></span><br><span class="line">        <span class="comment">// 参数：size：申请的 epoll 例程的大小</span></span><br><span class="line">        <span class="comment">// 返回值：成功时返回 epoll例程文件描述符，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>
<p>注意：Linux 2.6.8 之后的内核会完全忽略 size 参数，它会自己根据情况调整 epoll 例程的大小。因此调用时只需将 size 设为 0 即可。</p>
<h3 id="epoll-ctl函数"><a href="#epoll-ctl函数" class="headerlink" title="epoll_ctl函数"></a>epoll_ctl函数</h3><p>生成 epoll 例程后，就要调用 epoll_ctl 函数在其内部注册监视对象文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span>;</span><br><span class="line">        <span class="comment">// 功能：在 epoll 例程内部注册要监视的文件描述符</span></span><br><span class="line">        <span class="comment">// 参数：epfd：epoll 例程的文件描述符；op：指定监视对象的添加、删除或更改等操作。fd：需要注册的监视对象文件描述符。event：监视对象的事件类型</span></span><br><span class="line">        <span class="comment">// 返回值：成功时返回 0，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>参数 op 的可取值：</p>
<ol>
<li>EPOLL_CTL_ADD：将文件描述符注册到 epoll 例程。</li>
<li>EPOLL_CTL_DEL：从 epoll 例程中删除文件描述符。如果 fd 取此值，则第四个参数 event 应为 NULL。</li>
<li>EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况。</li>
</ol>
<p>参数 event 的使用：这里用到的是 epoll_event 结构体的 events 成员，events 成员用来指明关注的事件类型。</p>
<p>events 可以指明的事件类型不止 3 种，它的可取值如下：</p>
<ol>
<li>EPOLLIN：需要读取数据的情况。</li>
<li>EPOLLOUT：输出缓冲为空，可以立即发送数据的情况。</li>
<li>EPOLLPRI：收到 OOB 数据的情况。</li>
<li>EPOLLDHUP：断开连接或半关闭的情况，在边缘触发模式下很有用。</li>
<li>EPOLLERR：发送错误的情况。</li>
<li>EPOLLET：以边缘触发的情况得到事件通知。</li>
<li>EPOLLONESHOT：发送一次事件后，相应的文件描述符不再收到事件通知。因此需要向 epoll_ctl 函数的第二个参数传递 EPOLL_CTL_MOD，再次设置事件。</li>
</ol>
<p>可以通过位运算同时传递多个上述参数。</p>
<p>&#x2F;&#x2F; 例如：同时传递 EPOLLIN 和 EPOLLOUT<br>event.events &#x3D; EPOLLIN | EPOLLOUT;</p>
<h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><p>epoll_wait 函数与 select 函数类似，用于等待文件描述符发生变化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">        <span class="comment">// 功能：监视发生事件的文件描述符</span></span><br><span class="line">        <span class="comment">// 参数：epfd：epoll 例程的文件描述符；events：保存发生事件的文件描述符集合的结构体地址；maxevents：最多监听的事件数，必须大于 0；</span></span><br><span class="line">                <span class="comment">// timeout：超时时间，以 ms 为单位。如果 timeout 为 -1，则一直等待到事件发生。（注意类型为 int，和 select 函数中的不同）</span></span><br><span class="line">        <span class="comment">// 返回值：成功时返回发生事件的文件描述符数量，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>
<p>第二个参数 events 应该是一个 epoll_event 类型数组的地址。数组应该足够大，保证能够容下所有的文件描述符，可以取和第三个参数 maxevents 一样的值。</p>
<h1 id="条件触发和边缘触发"><a href="#条件触发和边缘触发" class="headerlink" title="条件触发和边缘触发"></a>条件触发和边缘触发</h1><p>epoll 中有两种触发方式：条件触发 LT(Level Trigger) 和边缘触发 ET(Edge Trigger)。</p>
<p>条件触发又称电平触发或水平触发。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>条件触发：只要输入缓冲中有数据就一直通知该事件。</p>
<p>边缘触发：只有当输入缓冲收到数据时注册一次该事件，之后即使输入缓冲中还有数据也不会再注册。</p>
<p>epoll 默认以条件触发方式工作。select 函数也是以条件触发方式工作的。</p>
<h2 id="边缘触发的服务器实现中要注意两点"><a href="#边缘触发的服务器实现中要注意两点" class="headerlink" title="边缘触发的服务器实现中要注意两点"></a>边缘触发的服务器实现中要注意两点</h2><ol>
<li>通过 errno 变量验证错误原因。</li>
<li>为了完成非阻塞 I&#x2F;O，更改套接字的属性为非阻塞模式。</li>
</ol>
<h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>Linux 的套接字相关函数返回 -1 以通知发生了错误，同时会设置变量 errno 的值来提示产生错误的原因。</p>
<p>访问 errno 变量需要引入 errno.h，errno 类型为 int，是一个全局变量。</p>
<p>非阻塞模式下，当 read 函数发现输入缓冲中没有数据可读时返回 -1，同时将 errno 的值设为常量 EAGAIN 的值</p>
<h3 id="将文件（套接字）更改为非阻塞模式"><a href="#将文件（套接字）更改为非阻塞模式" class="headerlink" title="将文件（套接字）更改为非阻塞模式"></a>将文件（套接字）更改为非阻塞模式</h3><p>使用 fcntl 函数来完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> filedes, <span class="type">int</span> cmd, ...)</span>; </span><br><span class="line">	<span class="comment">// 功能：更改或读取文件属性。 </span></span><br><span class="line">	<span class="comment">// 参数：filedes：要更改属性的文件描述符；cmd：指明函数调用的目的；...：可变参数，根据 cmd 的不同值会有不同情况。</span></span><br></pre></td></tr></table></figure>

<p>cmd 的可取值（包括但不限于以下）：</p>
<ol>
<li>F_GETFL：取此值时，fcntl 函数用于获取文件描述符 filedes 的属性（会返回相应值）。</li>
<li>F_SETFL：更改文件描述符属性。</li>
</ol>
<p>将文件（套接字）改为非阻塞模式要使用如下的两条语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL, <span class="number">0</span>); <span class="comment">// 获取之前的属性 </span></span><br><span class="line">fcntl(fd, F_SETFL, flag|O_NONBLOCK); <span class="comment">// 在此基础上添加非阻塞 O_NONBLOCK 标志。</span></span><br></pre></td></tr></table></figure>

<p>此后使用 read 对文件 fd 进行读取时都是非阻塞模式。</p>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><h2 id="echo-epollserv-c"><a href="#echo-epollserv-c" class="headerlink" title="echo_epollserv.c"></a>echo_epollserv.c</h2><p>这是基于 epoll 的回声服务器端（工作模式默认情况下是条件出发模式）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr;</span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *ep_events; <span class="comment">// 是个 epoll_event 类型的数组，用于存储发生事件的文件描述符的集合。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;      <span class="comment">// 是个变量，用于向 epoll 例程注册文集描述符时指明关注的事项。</span></span><br><span class="line">    <span class="type">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    epfd = <span class="built_in">epoll_create</span>(EPOLL_SIZE); <span class="comment">// 创建 epoll 例程</span></span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event) * EPOLL_SIZE); </span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN; <span class="comment">// 关注的是输入事件</span></span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event); <span class="comment">// 向 epoll 例程注册套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        event_cnt = <span class="built_in">epoll_wait</span>(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>); <span class="comment">// 监视事件的发生</span></span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) <span class="comment">// 服务器套接字用于接受新的连接请求</span></span><br><span class="line">            &#123;</span><br><span class="line">                adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock =</span><br><span class="line">                    <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 其他套接字用于提供回声服务</span></span><br><span class="line">            &#123;</span><br><span class="line">                str_len = <span class="built_in">read</span>(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (str_len == <span class="number">0</span>) <span class="comment">// close request!</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(</span><br><span class="line">                        epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(ep_events[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, ep_events[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">write</span>(ep_events[i].data.fd, buf, str_len); <span class="comment">// echo!</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="echo-EPLTserv-c"><a href="#echo-EPLTserv-c" class="headerlink" title="echo_EPLTserv.c"></a>echo_EPLTserv.c</h2><p>以条件触发模式工作的回声服务器端。</p>
<p>此程序和 echo_epollserv.c 差不多，只是将 read 函数的输入缓冲区大小缩小为 4 字节，使得一次 read 不会读完接收缓冲中的数据。由此证明条件触发情况下只要接收缓冲中还有数据，就会一直通知该事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4 <span class="comment">// 调用 read 函数时使用 4 字节的缓冲区，保证不会一次读完接收缓存中的内容</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr;</span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *ep_events;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="type">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    epfd = <span class="built_in">epoll_create</span>(EPOLL_SIZE);</span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event) * EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        event_cnt = <span class="built_in">epoll_wait</span>(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;return epoll_wait&quot;</span>); <span class="comment">// 每调用一次 epoll_wait，打印一次。</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock)</span><br><span class="line">            &#123;</span><br><span class="line">                adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                str_len = <span class="built_in">read</span>(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (str_len == <span class="number">0</span>) <span class="comment">// close request!</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(ep_events[i].data.fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, ep_events[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">write</span>(ep_events[i].data.fd, buf, str_len); <span class="comment">// echo!</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo-EPETserv-c"><a href="#echo-EPETserv-c" class="headerlink" title="echo_EPETserv.c"></a>echo_EPETserv.c</h2><p>以边缘触发模式工作的回声服务器端。</p>
<p>注意其中和条件触发模式的区别，主要区别的地方在从套接字读取数据的方式，这里多了个 while 循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLL_SIZE 50</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblockingmode</span><span class="params">(<span class="type">int</span> fd)</span></span>; <span class="comment">// 此函数用于将文件设为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr;</span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *ep_events;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="type">int</span> epfd, event_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    epfd = <span class="built_in">epoll_create</span>(EPOLL_SIZE);</span><br><span class="line">    ep_events = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event) * EPOLL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setnonblockingmode</span>(serv_sock); <span class="comment">// 将服务器套接字设为非阻塞模式</span></span><br><span class="line">    event.events = EPOLLIN;        <span class="comment">// 监听服务器套接字的输入事件</span></span><br><span class="line">    event.data.fd = serv_sock;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, serv_sock, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_cnt = <span class="built_in">epoll_wait</span>(epfd, ep_events, EPOLL_SIZE, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (event_cnt == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;epoll_wait() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;return epoll_wait&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ep_events[i].data.fd == serv_sock) &#123;</span><br><span class="line">                adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">                clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">                <span class="built_in">setnonblockingmode</span>(clnt_sock);    <span class="comment">// 将用于连接客户的套接字设为非阻塞模式</span></span><br><span class="line">                event.events = EPOLLIN | EPOLLET; <span class="comment">// 以边缘触发方式监听用于连接客户的套接字上的输入事件</span></span><br><span class="line">                event.data.fd = clnt_sock;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, clnt_sock, &amp;event);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">// 当有输入时，循环读取数据。条件触发中没有此循环。</span></span><br><span class="line">                &#123;</span><br><span class="line">                    str_len = <span class="built_in">read</span>(ep_events[i].data.fd, buf, BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span> (str_len == <span class="number">0</span>) <span class="comment">// close request! </span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, ep_events[i].data.fd, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">close</span>(ep_events[i].data.fd);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;closed client: %d \n&quot;</span>, ep_events[i].data.fd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (str_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN) <span class="comment">// 当没有数据可读时跳出循环，完成读取</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">write</span>(ep_events[i].data.fd, buf, str_len); <span class="comment">// echo!</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblockingmode</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, flag | O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(buf, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>7-23 代码随想录之链表</title>
    <url>/2025/07/23/day3/</url>
    <content><![CDATA[<h1 id="203-移除链表元素-力扣（LeetCode）"><a href="#203-移除链表元素-力扣（LeetCode）" class="headerlink" title="203. 移除链表元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（LeetCode）</a></h1><p>链表的题我个人还是喜欢有一个虚拟的头节点更好。这样便于操作和处理边界情况</p>
<p>在这个题里，维护一个当前节点和当前节点的前一个节点，当前节点值为val时，只需要把前一个节点的next指向当前节点的next即可。</p>
<p><strong>最后返回虚拟头节点的next是因为当链表内全为对应val时，原head节点将被删除</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        ListNode* dumhead = pre;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                ListNode* tmp = cur;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="206-反转链表-力扣（LeetCode）"><a href="#206-反转链表-力扣（LeetCode）" class="headerlink" title="206. 反转链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></h1><p>循环的做法比较简单，不赘述</p>
<p>对于递归，考虑设计一个函数，每次翻转两个节点间的指向关系即可。最后的那个节点就是头节点</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">nullptr</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="24-两两交换链表中的节点-力扣（LeetCode）"><a href="#24-两两交换链表中的节点-力扣（LeetCode）" class="headerlink" title="24. 两两交换链表中的节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></h1><p>依然设置一个虚拟头节点，current指针的下一个节点是需要临时保存的；因为是两两交换  </p>
<p>还有循环停止的条件是current节点和下个节点不能为空</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode* pre = dummyhead;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next; </span><br><span class="line">            cur-&gt;next = temp-&gt;next</span><br><span class="line">            temp-&gt;next = cur;</span><br><span class="line">            pre-&gt;next = temp;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>优雅地断开套接字连接</title>
    <url>/2024/06/10/%E4%BC%98%E9%9B%85%E5%9C%B0%E6%96%AD%E5%BC%80%E5%A5%97%E6%8E%A5%E5%AD%97%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>TCP 的断开连接过程比建立连接过程更重要，因为断开过程更有可能出现意外情况。</p>
<span id="more"></span>
<h1 id="基于TCP的半关闭"><a href="#基于TCP的半关闭" class="headerlink" title="基于TCP的半关闭"></a>基于TCP的半关闭</h1><h2 id="单方面断开连接带来的问题"><a href="#单方面断开连接带来的问题" class="headerlink" title="单方面断开连接带来的问题"></a>单方面断开连接带来的问题</h2><p>Linux 的 close 函数和 Windows 的 closesocket 函数都意味着完全断开连接。也就是无法发送也无法接收数据，有时候这不太优雅。</p>
<p>建立 TCP 套接字连接后可交换数据的状态可以看成一种流（包括输入流和输出流）。close 将会同时断开两个流</p>
<p>所以可以考虑只断开一部分连接：只断开输入流或输出流</p>
<h2 id="优雅断开连接的shutdown函数"><a href="#优雅断开连接的shutdown函数" class="headerlink" title="优雅断开连接的shutdown函数"></a>优雅断开连接的shutdown函数</h2><p>shutdown 函数用于只断开其中一个流</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span></span>; </span><br><span class="line">	<span class="comment">// 功能：半关闭套接字 </span></span><br><span class="line">	<span class="comment">// 参数：sock：需要断开的套接字；howto：断开方式 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回 0，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>

<p>第二个参数 howto 将决定关闭的方式，可取的值如下：</p>
<ol>
<li>SHUT_RD：断开输入流，此后套接字无法接收数据；</li>
<li>SHUT_WR：断开输出流，此后套接字无法发送数据；</li>
<li>SHUT_RDWR：同时断开 I&#x2F;O 流。</li>
</ol>
<p>值按序分别为0,1,2</p>
<blockquote>
<p>[!NOTE] 为什么需要半关闭<br>一方在发送完所有数据后可以只关闭输出流但保留输入流，这样还可以接收对方的数据。</p>
</blockquote>
<h1 id="基于windows的实现"><a href="#基于windows的实现" class="headerlink" title="基于windows的实现"></a>基于windows的实现</h1><p>Windows 中也有 shutdown 函数，参数和返回值类型都一样，但是参数 howto 取值的参数名不同。</p>
<p>howto 的三个可取值为：</p>
<ol>
<li>SD_RECEIVE：断开输入流；</li>
<li>SD_SEND：断开输出流；</li>
<li>SD_BOTH：同时断开 I&#x2F;O 流。</li>
</ol>
<h1 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h1><h2 id="file-server-c"><a href="#file-server-c" class="headerlink" title="file_server.c"></a>file_server.c</h2><p>基于半关闭的文件传输程序-服务器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sd, clnt_sd;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> read_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = <span class="built_in">fopen</span>(<span class="string">&quot;file_server.c&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    serv_sd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(serv_sd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    <span class="built_in">listen</span>(serv_sd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">    clnt_sd = <span class="built_in">accept</span>(serv_sd, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz); <span class="comment">// 这里 accept 函数只调用了一次，此程序一次运行期间实际上只能接受一次连接。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        read_cnt = <span class="built_in">fread</span>((<span class="type">void</span> *)buf, <span class="number">1</span>, BUF_SIZE, fp);</span><br><span class="line">        <span class="keyword">if</span> (read_cnt &lt; BUF_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">write</span>(clnt_sd, buf, read_cnt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(clnt_sd, buf, BUF_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shutdown</span>(clnt_sd, SHUT_WR);   <span class="comment">// 关闭了输出流</span></span><br><span class="line">    <span class="built_in">read</span>(clnt_sd, buf, BUF_SIZE); <span class="comment">// 还可以继续接收数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from client: %s \n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">close</span>(clnt_sd);</span><br><span class="line">    <span class="built_in">close</span>(serv_sd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="file-client-c"><a href="#file-client-c" class="headerlink" title="file_client.c"></a>file_client.c</h2><p>基于半关闭的文件传输程序-客户端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> read_cnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = <span class="built_in">fopen</span>(<span class="string">&quot;receive.dat&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    sd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(sd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((read_cnt = <span class="built_in">read</span>(sd, buf, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fwrite</span>((<span class="type">void</span> *)buf, <span class="number">1</span>, read_cnt, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Received file data&quot;</span>);</span><br><span class="line">    <span class="built_in">write</span>(sd, <span class="string">&quot;Thank you&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">close</span>(sd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于TCP的服务器端和客户端-1</title>
    <url>/2024/06/07/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF-1/</url>
    <content><![CDATA[<h1 id="理解TCP-UDP"><a href="#理解TCP-UDP" class="headerlink" title="理解TCP&#x2F;UDP"></a>理解TCP&#x2F;UDP</h1><p>计网学过，不赘述</p>
<h1 id="实现基于TCP的服务器端-客户端"><a href="#实现基于TCP的服务器端-客户端" class="headerlink" title="实现基于TCP的服务器端&#x2F;客户端"></a>实现基于TCP的服务器端&#x2F;客户端</h1><h2 id="服务器端进入等待连接请求状态"><a href="#服务器端进入等待连接请求状态" class="headerlink" title="服务器端进入等待连接请求状态"></a>服务器端进入等待连接请求状态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待连接请求状态：当服务器在此状态下时，在调用 accept 函数受理连接请求前，请求会处于等待状态。注意：这里说的是让来自客户端的请求处于等待状态，以等待服务器端受理它们的请求。</p>
<p>连接请求等待队列：还未受理的连接请求在此排队，backlog 的大小决定了队列的最大长度，一般频繁接受请求的 Web 服务器的 backlog 至少为 15。</p>
<h2 id="服务器端受理客户端连接请求"><a href="#服务器端受理客户端连接请求" class="headerlink" title="服务器端受理客户端连接请求"></a>服务器端受理客户端连接请求</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>accept 函数会受理连接请求等待队列中待处理的客户端连接请求，它从等待队列中取出 1 个连接请求，创建套接字并完成连接请求。如果等待队列为空，accpet 函数会阻塞，直到队列中出现新的连接请求才会返回。</p>
<p>它会在内部产生一个新的套接字并返回其文件描述符，该套接字用于与客户端建立连接并进行数据 I&#x2F;O。新的套接字是在 accept 函数内部自动创建的，并自动与发起连接请求的客户端建立连接。</p>
<p>accept 执行完毕后会将它所受理的连接请求对应的客户端地址信息存储到第二个参数 addr 中。</p>
<h2 id="客户端发起连接请求"><a href="#客户端发起连接请求" class="headerlink" title="客户端发起连接请求"></a>客户端发起连接请求</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>客户端调用 connect 函数后会阻塞，直到发生以下情况之一才会返回：</p>
<ol>
<li>服务器端接收连接请求。</li>
<li>发生断网等异常情况而中断连接请求。</li>
</ol>
<blockquote>
<p>[!NOTE] “接收连接请求”<br>注意：上面说的”接收连接请求“并不是服务器端调用了 accept 函数，而是服务器端把连接请求信息记录到等待队列。因此 connect 函数返回后并不立即进行数据交换。</p>
</blockquote>
<h2 id="基于TCP的服务器端-客户端函数调用关系"><a href="#基于TCP的服务器端-客户端函数调用关系" class="headerlink" title="基于TCP的服务器端&#x2F;客户端函数调用关系"></a>基于TCP的服务器端&#x2F;客户端函数调用关系</h2><p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/l5xm/556X483/function_call_order.png" alt="556X483&#x2F;function_call_order.png"><br>客户端只有等到服务器端调用 listen 函数后才能调用 connect 函数，否则会连接失败。</p>
<p>客户端调用 connect 函数和服务器端调用 accept 函数的顺序不确定，先调用的要等待另一方。</p>
<h1 id="实现迭代服务器端-客户端"><a href="#实现迭代服务器端-客户端" class="headerlink" title="实现迭代服务器端&#x2F;客户端"></a>实现迭代服务器端&#x2F;客户端</h1><p>回声服务器端：它会将客户端传输的字符串数据原封不动地传回客户端，像回声一样。</p>
<h2 id="实现迭代服务器端"><a href="#实现迭代服务器端" class="headerlink" title="实现迭代服务器端"></a>实现迭代服务器端</h2><p>调用一次 accept 函数只会受理一个连接请求，如果想要继续受理请求，最简单的方法就是循环反复调用 accept 函数，在前一个连接 close 之后，重新 accept。</p>
<p>在不使用多进程&#x2F;多线程情况下，同一时间只能服务于一个客户端。</p>
<h2 id="迭代回声服务器端-客户端"><a href="#迭代回声服务器端-客户端" class="headerlink" title="迭代回声服务器端&#x2F;客户端"></a>迭代回声服务器端&#x2F;客户端</h2><p>迭代回声服务器端与回声客户端的基本运行方式：</p>
<ol>
<li>服务器端同一时刻只与一个客户端相连接，并提供回声服务。</li>
<li>服务器端依次向 5 个客户端提供服务，然后退出。</li>
<li>客户端接收用户输入的字符串并发送到服务器端。</li>
<li>服务器端将接收到的字符串数据传回客户端，即”回声“。</li>
<li>服务器端与客户端之间的字符串回声一直执行到客户端输入 Q 为止。</li>
</ol>
<p>具体实现见最后本章的程序实例</p>
<h2 id="回声客户端的问题"><a href="#回声客户端的问题" class="headerlink" title="回声客户端的问题"></a>回声客户端的问题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(sock, message, <span class="built_in">strlen</span>(message)); </span><br><span class="line">str_len = <span class="built_in">read</span>(sock, message, BUF_SIZE - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在本章的回声客户端的实现中有上面这段代码，它有一个错误假设：每次调用 read、write 函数时都会执行实际的 I&#x2F;O 操作。</p>
<p>但是注意：TCP 是面向连接的字节流传输，不存在数据边界。所以多次 write 的内容可能一直存放在发送缓存中，某个时刻再一次性全都传递到服务器端，这样的话客户端前几次 read 都不会读取到内容，最后才会一次性收到前面多次 write 的内容。还有一种情况是服务器端收到的数据太大，只能将其分成多个数据包发送给客户端，然后客户端可能在尚未收到全部数据包时旧调用 read 函数。</p>
<p>理解：问题的核心在于 write 函数实际上是把数据写到了发送缓存中，而 read 函数是从接收缓存读取数据。并不是直接对 TCP 连接的另一方进行数据读写。</p>
<h1 id="4-4-基于Windows的实现"><a href="#4-4-基于Windows的实现" class="headerlink" title="4.4 基于Windows的实现"></a>4.4 基于Windows的实现</h1><p>将 Linux 平台下的实例转化为 Windows 下的实例，记住以下四点：</p>
<ol>
<li>通过 WSAStartup、WSACleanup 函数初始化并清除套接字相关库。</li>
<li>把数据类型和变量名切换为 Windows 风格。</li>
<li>数据传输中用 recv、send 函数而非 read、write 函数。</li>
<li>关闭套接字时用 closesocket 函数而非 close 函数。</li>
</ol>
<h1 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h1><h2 id="echo-server-c"><a href="#echo-server-c" class="headerlink" title="echo_server.c"></a>echo_server.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock; <span class="comment">// 这个 clnt_sock 将用来表示服务器端上真正与客户端相连接的那个套接字</span></span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr; <span class="comment">// 这个 clnt_adr 将用来存储连接的客户端的地址信息，注意和 clnt_sock 表示的对象的不同</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">error_handling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connected client %d \n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(clnt_sock, message, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">write</span>(clnt_sock, message, str_len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo-client-c"><a href="#echo-client-c" class="headerlink" title="echo_client.c"></a>echo_client.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(message, BUF_SIZE, stdin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        str_len = <span class="built_in">read</span>(sock, message, BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP及相关理论初探</title>
    <url>/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>其中C代表一致性 (Consistency)，A代表可用性 (Availability)，P代表分区容错性 (Partition tolerance)。</p>
<ul>
<li>一致性：如果一个写操作返回成功，那么之后的读请求都必须到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。</li>
<li>可用性：对数据更新具备高可用性，即使出现节点失效，请求也能够及时处理，不会一直等待</li>
<li>分区容错性：能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务</li>
</ul>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>想想两个副本处于分区两侧，即两个副本之间的网络断开，不能通信</p>
<ul>
<li>如果允许其中一个副本更新，则会导致数据不一致，即丧失了C性质。</li>
<li>如果为了保证一致性，将分区某一侧的副本设置为不可用，那么又丧失了A性质。</li>
<li>除非两个副本可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</li>
</ul>
<h1 id="PACELC理论"><a href="#PACELC理论" class="headerlink" title="PACELC理论"></a>PACELC理论</h1><p>A 中是有一定争议的，很长时间才返回，虽然可用，但是业务上可能不能接受。并且，系统大部分时间下，分区都是平稳运行的，并不会出错，在这种情况下，系统设计要均衡的其实是延迟与数据一致性的问题，为了保证数据一致性，写入与读取的延迟就会增高。这就引出了 PACELC 理论。 PAC就是CAP，E是else，L是Latency延迟，C是 Consistency。<br><img src="/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/CAP-PACELC.png" alt="CAP-PACELC"><br>如果发生了P ，那么只能保 A or C</p>
<p>如果没有发生P， 那么就在 L 和 C之前权衡，如果保证了低延时，数据一致性就会降低（副本数量少），如果保证了较高的数据一致性，就会带来相对较高的延时问题（需要同步的副本多）</p>
<h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p><img src="/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/PACELC%20eaxmple1.png" alt="PACELC eaxmple1"><br>在强一致性复制场景下，需要三副本都下盘才能返回OK确认信息给client端，假设Master节点向 Slave 节点复制数据，时延的限制是 20ms，有时候，slave 2 硬盘或网络出现故障，Master 往 Slave 复制数据的时延超过 了20ms，这个时候如果还一直等待 slave 2 返回结果再通知给client就会出现性能和时延抖动，而且这种抖动是经常会发生的长尾效应。</p>
<p>依据PACELC理论，我们可以在 consistency和Latency之间做个取舍，比如 slave 2 节点的时延超过 20ms了，就不等待slave 2 返回，master 和 slave 1 返回结果给client即可（此时同步节点大于总结点数的一半），如果 slave 2 出现 超时的次数超过 5次那么就认为这个节点可能出现故障，打个故障标签，进行后续的处理。采用这种方式可以消除写时的长尾抖动，获得更优雅的写时性能曲线。</p>
<h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p>举个日常例子，主从同步。</p>
<p>我们业务代码经常可能存在数据写入后立刻查询的操作，因为线上数据库上读写分离，在业务高峰期，存在主从延迟，解决方案一般有两种：</p>
<ul>
<li>写操作完后Sleep一段微小时间，让数据库完成主从同步</li>
<li>写操作后完后，直接通过数据库访问层的中间件指定读操作读主库数据</li>
</ul>
<p>这里就存在在时延（Latency）和一致性（Consistency）上做了权衡，选择方案一，偏向一致性，选择方案二，偏向于低时延</p>
<p>以MySQL主从复制为例，提供了三种模式：</p>
<ol>
<li>异步模式：主库执行完客户端提交的事务，立即将结果返回给客户端，不关心从库是否已经接收并。由于数据同步的延时，客户端在从库上可能读不到最新数据。这种模式对MySQL是性能最佳的，但是用户需要权衡，业务能否忍受这种延时</li>
<li>全同步复制：主库执行完客户端提交的事务，所有的从库都执行了该事务才返回结果，这样保证强一致性，但是响应时间变长了</li>
<li>半同步复制：主库在执行完客户端提交的事务后，等待至少一个从库接收到并写到 relay log 中，才返回给客户端，这样做延迟小了很多，相比于异步复制，数据更加不容易丢失</li>
</ol>
<h3 id="eureka属于AP系统吗？它明明没有放弃一致性啊"><a href="#eureka属于AP系统吗？它明明没有放弃一致性啊" class="headerlink" title="eureka属于AP系统吗？它明明没有放弃一致性啊"></a>eureka属于AP系统吗？它明明没有放弃一致性啊</h3><p>描述AP和CP时，通常都会以eureka和zookeeper来具体。eureka是AP的代表作，zookeeper则是CP的代表作。二者之所以这样归类，是因为：</p>
<ul>
<li>eureka各节点互相独立、平等的。各节点都提供自我查询和注册服务（读写请求）。当发生网络分区，eureka各节点依旧可以接收和注册服务。并且当丢失过多客户端时，节点会进入自我保护（接收新服务注册、不删除过期服务）。在该种模式下，eureka集群剩下最后一个节点，也可以向外提供服务。尽管向外提供的数据可能是过期的数据。</li>
<li>zookeeper采用的过半原则，由leader处理写请求。当发生网络分区时，leader由于丢失过半的follower，从而处理不了客户端的请求，需要重新选举新leader，期间服务将不可用。糟糕的是，如果集群中没有过半的节点存活，将选举不出新leader，服务将一直处于不可用状态</li>
</ul>
<p>而在A、C之间的抉择需要二选一的情况下，一定是发生了网络分区的情况。eureka集群正常运行时，各节点之间可以正常通讯、保持心跳、复制数据，以此保持数据的一致性。但发生网络分区时，eureka确实选择了可用性，而放弃了一致性。</p>
<h1 id="FLP不可能定理"><a href="#FLP不可能定理" class="headerlink" title="FLP不可能定理"></a>FLP不可能定理</h1><p>这是最重要的定理之一，给出了一个非常重要的结论：在网络可靠且存在节点失效的异步模型中，不存在一个可以解决一致性问题的确定性算法。</p>
<p>不要浪费时间去为异步分布式系统设计在任意场景上都能够实现共识的算法，异步系统完全没有办法保证能在有限时间内达成一致。</p>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>这是CAP理论的延伸，核心思想是即使无法做到强一致性（CAP的一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）</p>
<p><strong>Basically Available</strong>（基本可用）分布式系统在出现不可预知故障的时候，允许损失部分可用性</p>
<p><strong>Soft state</strong>（软状态）软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<p><strong>Eventually consistent</strong>（最终一致性）最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
<h1 id="CAP与BASE关系"><a href="#CAP与BASE关系" class="headerlink" title="CAP与BASE关系"></a>CAP与BASE关系</h1><p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是通过业务，牺牲强一致性而获得可用性，并允许数据在一段时间内是不一致的，但是最终达到一致性状态。</p>
<h1 id="CAP与ACID关系"><a href="#CAP与ACID关系" class="headerlink" title="CAP与ACID关系"></a>CAP与ACID关系</h1><p>ACID 是传统数据库常用的设计理念，追求强一致性模型。BASE 支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p>
<p>数据库中多个事务并发会有以下问题：</p>
<ul>
<li>脏读：事务T1读取了T2更改的x，但是T2在实际存储数据时可能出错回滚了，这时T1读取的实际是无效的数据，这种情况下就是脏读</li>
<li>不可重复读：是说在T1读取x时，由于中间T2更改了x，所以T1前后两次读取的x值不相同，这就是所谓的不可重复读</li>
<li>幻读：在T1读取符合某个条件的所有记录时，T2增加了一条符合该条件的记录，这就导致T1执行过程中前后读取的记录可能不一致，即T2之后读取时会多出一条记录。</li>
</ul>
<p>为了解决这些问题，事务提出四种隔离级别来规避上述问题。而解决的就是ACID中的C（一致性），所以ACID中的C（一致性）可以理解为不出现脏读、幻读、不可重复读的问题。可以把它称为“内部一致性”，解决的是数据库内部的一致性问题。</p>
<p>CP中的C（一致性），相对好理解，我把它理解为“外部一致性”。就分布式系统而言的，针对客户端的请求，无论访问那个节点，都能获得最新的相同的值。</p>
<p>ACID 和 BASE 代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此 ACID 和 BASE 又会结合使用。</p>
<h1 id="NWR策略-Quorum协议"><a href="#NWR策略-Quorum协议" class="headerlink" title="NWR策略-Quorum协议"></a>NWR策略-Quorum协议</h1><p>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。这个三个字母分别代表着：</p>
<ul>
<li>N：分布式系统中，一个有多少个副本数据</li>
<li>W：处理一次写请求，需要更新多少个副本数据</li>
<li>R：处理一次读请求，需要读取多少个副本数据</li>
</ul>
<p>分别设置不同的值时，将产生不同的一致性效果</p>
<ul>
<li>W+R&gt;N：整个系统对于客户端的请求能保证强一致性。因为写请求和读请求一定存在一个相交的副本，读取的时候返回该副本的数据即可。</li>
<li>W+R&lt;&#x3D;N，整个系统对于客户端的请求则不能保证强一致性</li>
</ul>
<p>W、R的大小，直接影响其对应的处理效率。主要注意，读写请求的效率取决于最慢的副本处理速度</p>
<p>这种就将PACELC均衡权力交给了用户</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>域名及网络地址</title>
    <url>/2024/06/11/%E5%9F%9F%E5%90%8D%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h1><p>可以通过 ping 命令查看域名对应的 IP 地址。</p>
<p>查看本机的默认 DNS 域名服务器地址可以使用 nslookup 命令。</p>
<h1 id="IP地址和域名间的转换"><a href="#IP地址和域名间的转换" class="headerlink" title="IP地址和域名间的转换"></a>IP地址和域名间的转换</h1><h2 id="程序中有必要使用域名吗"><a href="#程序中有必要使用域名吗" class="headerlink" title="程序中有必要使用域名吗"></a>程序中有必要使用域名吗</h2><p>系统随时可能会因为各种原因导致 IP 地址变更。而域名则比 IP 地址稳定得多，因此编写程序时使用域名要比 IP 地址更好。</p>
<p>客户端可以在程序使用域名和 IP 地址的转换函数，每次运行程序时根据域名获取 IP 地址再接入服务器，这样就不会依赖服务器的 IP 地址了。</p>
<h2 id="利用域名获取IP地址"><a href="#利用域名获取IP地址" class="headerlink" title="利用域名获取IP地址"></a>利用域名获取IP地址</h2><p>可以使用以下函数来根据字符串格式的域名获取 IP 地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span> </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span>* hostname); </span><br><span class="line">	<span class="comment">// 功能：利用域名获取 host 信息，包括绑定的其他域名及所有 IP 地址 </span></span><br><span class="line">	<span class="comment">// 参数：hostname：字符串格式的域名 </span></span><br><span class="line">	<span class="comment">// 返回值：包含 IP 地址信息的结构体的指针</span></span><br></pre></td></tr></table></figure>
<p>hostent 结构体的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> &#123; </span><br><span class="line">	<span class="type">char</span>* h_name; <span class="comment">// 官方域名 </span></span><br><span class="line">	<span class="type">char</span>** h_aliases; <span class="comment">// 绑定的其他域名 </span></span><br><span class="line">	<span class="type">int</span> h_addrtype; <span class="comment">// 结构体中存储的地址所属的地址族，如果是 IPv4 地址，则此变量为 AF_INET </span></span><br><span class="line">	<span class="type">int</span> h_length; <span class="comment">// IP 地址的长度，如果是 IPv4 地址，则此变量值为 4 </span></span><br><span class="line">	<span class="type">char</span>** h_addr_list;<span class="comment">// 地址列表，最重要的成员。以整数形式保存域名对应的 IP 地址（可能有多个） </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 gethostbyname 函数后返回的 hostent 结构体的变量结构如下图：<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251012/LzZ6/668X457/hostent_structure.png" alt="668X457&#x2F;hostent_structure.png"><br>注意：h_addr_list 中存储地址的方式是 char*，而 char* 的内容并不是地址值，实际上是 in_addr 结构体的地址。</p>
<p>因此要取得点分十进制字符串格式的地址，需要先将 char* 转换为 in_addr* 类型，然后解引用取得整数地址值，再使用 inet_ntoa 将其转换为点分十进制格式的字符串。</p>
<p><code>inet_ntoa(*(struct in_addr *)host-&gt;h_addr_list[i]));</code></p>
<h2 id="利用IP地址获取域名"><a href="#利用IP地址获取域名" class="headerlink" title="利用IP地址获取域名"></a>利用IP地址获取域名</h2><p>gethostbyaddr 函数利用 IP 地址获取域名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span> </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyaddr</span>(<span class="type">const</span> <span class="type">char</span>* addr, <span class="type">socklen_t</span> len, <span class="type">int</span> family); </span><br><span class="line">	<span class="comment">// 功能：利用 IP 地址获取 host 信息，包括绑定的所有域名及其他 IP 地址 </span></span><br><span class="line">	<span class="comment">// 参数：addr : 含有IP地址信息的in_addr结构体指针。为了同时传递IPv4地址之外的其他信息,该变量的类 型声明为char指针。 </span></span><br><span class="line">	<span class="comment">// len : 向第一个参数传递的地址信息的字节数,IPv4时为4,IPv6时为16。 </span></span><br><span class="line">	<span class="comment">// family : 传递地址族信息,IPv4时为AF_INET,IPv6时为AF_INET6。</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回 hostent 结构体变量地址值,失败时返回 NULL 指针。</span></span><br></pre></td></tr></table></figure>
<h1 id="基于Windows的实现"><a href="#基于Windows的实现" class="headerlink" title="基于Windows的实现"></a>基于Windows的实现</h1><p>Windows 也有类似的函数，用法与 Linux 完全一致。</p>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><h2 id="gethostbyname-c"><a href="#gethostbyname-c" class="headerlink" title="gethostbyname.c"></a>gethostbyname.c</h2><p>此程序用于演示 gethostbyname 函数的应用及 hostent 结构体变量的特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span> *host;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;addr&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!host)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;gethost... error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_aliases[i]; i++)    <span class="comment">// 注意这里遍历以 null 结尾的数组的方式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d: %s \n&quot;</span>, i + <span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">           (host-&gt;h_addrtype == AF_INET) ? <span class="string">&quot;AF_INET&quot;</span> : <span class="string">&quot;AF_INET6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s \n&quot;</span>, i + <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr *)host-&gt;h_addr_list[i]));  <span class="comment">// 注意这里需要调用 inet_ntoa 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gethostbyaddr-c"><a href="#gethostbyaddr-c" class="headerlink" title="gethostbyaddr.c"></a>gethostbyaddr.c</h2><p>此程序用于演示 gethostbyaddr 函数的应用及 hostent 结构体变量的特性。</p>
<p>此程序与上面的 gethostbyname.c 的差别只是用 gethostbyaddr 函数代替了 gethostbyname 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span> *host;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    host = <span class="built_in">gethostbyaddr</span>((<span class="type">char</span> *)&amp;addr.sin_addr, <span class="number">4</span>, AF_INET);</span><br><span class="line">    <span class="keyword">if</span> (!host)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;gethost... error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d: %s \n&quot;</span>, i + <span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">           (host-&gt;h_addrtype == AF_INET) ? <span class="string">&quot;AF_INET&quot;</span> : <span class="string">&quot;AF_INET6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s \n&quot;</span>, i + <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr *)host-&gt;h_addr_list[i]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>地址族与数据序列</title>
    <url>/2024/06/05/%E5%9C%B0%E5%9D%80%E6%97%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="分配给套接字的IP地址和端口号"><a href="#分配给套接字的IP地址和端口号" class="headerlink" title="分配给套接字的IP地址和端口号"></a>分配给套接字的IP地址和端口号</h1><p>IPV4地址为4字节，IPv6 是 16 字节地址族。</p>
<p>端口号是 2 字节，范围是 0 ~ 65535。其中 0 ~ 1023 是熟知端口号。</p>
<p>同一协议族端口号不能重复，TCP 套接字和 UDP 套接字不会共用端口号，所以两者之间允许重复。</p>
<h1 id="地址信息的表示"><a href="#地址信息的表示" class="headerlink" title="地址信息的表示"></a>地址信息的表示</h1><h2 id="表示IPV4地址的结构体sockaddr-in"><a href="#表示IPV4地址的结构体sockaddr-in" class="headerlink" title="表示IPV4地址的结构体sockaddr_in"></a>表示IPV4地址的结构体sockaddr_in</h2><p>下面这个结构体将作为地址信息传递给 bind 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span> </span><br><span class="line">	<span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族 </span></span><br><span class="line">	<span class="type">uint16_t</span> sin_port; <span class="comment">// 16 位端口号 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// 表示 32 位 IP 地址的结构体 </span></span><br><span class="line">	<span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">// 不使用 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中用于表示 IP 地址的结构体 in_addr 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span> </span><br><span class="line">	<span class="type">in_addr_t</span> s_addr; <span class="comment">// 32 位 IP 地址，实际位为 uint32_t 类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员分析"><a href="#成员分析" class="headerlink" title="成员分析"></a>成员分析</h2><h3 id="sin-family"><a href="#sin-family" class="headerlink" title="sin_family"></a>sin_family</h3><p>不同协议族使用的地址族不同，如 PF_INET(IPv4 协议族) 对应的地址族是 AF_INET( IPv4 地址族)。<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/jZdd/891X163/dress_Family.png" alt="891X163&#x2F;dress_Family.png"></p>
<h3 id="成员sin-port"><a href="#成员sin-port" class="headerlink" title="成员sin_port"></a>成员sin_port</h3><p>以网络字节序保存 16 位端口号。</p>
<h3 id="成员sin-addr"><a href="#成员sin-addr" class="headerlink" title="成员sin_addr"></a>成员sin_addr</h3><p>类型为 in_addr，in_addr 的成员 s_addr 按网络字节序保存 32 位 IP 地址。</p>
<h3 id="成员sin-zero"><a href="#成员sin-zero" class="headerlink" title="成员sin_zero"></a>成员sin_zero</h3><p>无特殊含义。只是为了使结构体 sockaddr_in 的大小与 sockaddr 结构体一致而插入的成员，必须填充为 0</p>
<h2 id="sockaddr-in的传递"><a href="#sockaddr-in的传递" class="headerlink" title="sockaddr_in的传递"></a>sockaddr_in的传递</h2><p>bind 的第二个参数期望得到的是 sockaddr 结构体变量的地址值，但是 sockaddr 的成员填充起来比较麻烦，因此使用 sockaddr_in 结构体来代替它。</p>
<p>使用 sockaddr_in 结构体生成的字节流也符合 bind 函数的要求，只需在传递地址时转换为 sockaddr* 类型即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> </span><br><span class="line">... </span><br><span class="line"><span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) </span><br><span class="line">	error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="sockaddr结构体"><a href="#sockaddr结构体" class="headerlink" title="sockaddr结构体"></a>sockaddr结构体</h2><p>sockaddr 结构体定义如下，它是通用的结构体，并非只为 IPv4 设计，而 sockaddr_in 是保存 IPv4 地址信息的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span> </span><br><span class="line">	<span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族 </span></span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// 地址信息 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络字节序和地址变换"><a href="#网络字节序和地址变换" class="headerlink" title="网络字节序和地址变换"></a>网络字节序和地址变换</h1><h2 id="字节序与网络字节序"><a href="#字节序与网络字节序" class="headerlink" title="字节序与网络字节序"></a>字节序与网络字节序</h2><p>CPU 向内存保存数据的方式有两种：</p>
<ol>
<li>大端序：高位字节存放到低位地址。网络字节序为大端序。</li>
<li>小端序：高位字节存放到高位地址。目前主流的 Intel 系列 CPU 按小端序方式保存数据。</li>
</ol>
<p>在使用网络发送数据时要先把数据转化成大端序，接收时也要先转换为主机字节序。</p>
<h2 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h2><p>htons 中的 h 代表主机字节序，n 代表网络字节序。</p>
<p>s 代表 short 类型，处理 2 字节数据，用于端口号转换；l 代表 long 类型（Linux 中 long 占用 4 字节），处理 4 字节数据，用于 IP 地址转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;short 类型，用于端口号的转换&#x27;</span> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>;</span><br><span class="line"> <span class="string">&#x27;long 类型，用于 IP 地址的转换&#x27;</span> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>除了向 sockaddr_in 结构体变量填充数据时需要进行字节序转换外，其他情况无需考虑字节序问题，会自动转换。</p>
<h1 id="网络地址的初始化和分配"><a href="#网络地址的初始化和分配" class="headerlink" title="网络地址的初始化和分配"></a>网络地址的初始化和分配</h1><p>sockaddr_in 中保存地址信息的成员是 32 位整型，而一般我们描述 IP 地址时用的是字符串格式的点分十进制表示法，因此需要将字符串形式的 IP 地址转换为 32 位整型数据。</p>
<p>有两个函数可以完成以上功能：inet_addr 函数和 inet_aton 函数</p>
<h2 id="inet-addr函数"><a href="#inet-addr函数" class="headerlink" title="inet_addr函数"></a>inet_addr函数</h2><p>inet_addr 函数在转换类型的同时也会完成网络字节序的转换，它还可以检测无效的 IP 地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>)</span>; </span><br><span class="line"><span class="comment">// 功能：将字符串形式的 IP 地址转换为 32 位整型数据并返回。 </span></span><br><span class="line"><span class="comment">// 返回值：成功时返回 32 位大端序整型值，失败时返回 INADDR_NONE。</span></span><br></pre></td></tr></table></figure>
<h2 id="inet-aton函数"><a href="#inet-aton函数" class="headerlink" title="inet_aton函数"></a>inet_aton函数</h2><p>inet_aton 函数和 inet_addr 函数的功能相同，也是将字符串形式的 IP 地址转换为 32 位网络字节序整数，但是它利用了 in_addr 结构体，使用频率更高。</p>
<p>inet_aton 需要传递一个 in_addr 类型结构体的指针，它会将转换结果直接放入该指针所指的 in_addr 结构体中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>, <span class="keyword">struct</span> in_addr* addr)</span>; </span><br><span class="line"><span class="comment">// 功能：将字符串形式的 IP 地址转换为 32 位网络字节序整数并存储到 addr 中。 </span></span><br><span class="line"><span class="comment">// 返回值：成功时返回 1，失败时返回 0</span></span><br></pre></td></tr></table></figure>
<h2 id="inet-ntoa函数"><a href="#inet-ntoa函数" class="headerlink" title="inet_ntoa函数"></a>inet_ntoa函数</h2><p>inet_ntoa 函数与 inet_aton 函数相反，它将网络字节序的整数型 IP 地址转换为字符串形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr adr)</span>; </span><br><span class="line"><span class="comment">// 功能：将网络字节序的整数型 IP 地址转换为字符串形式 </span></span><br><span class="line"><span class="comment">// 返回值：成功时返回转换的字符串地址值，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>该函数使用时要小心：返回值类型为 char 指针，返回字符串地址意味着字符串已保存到内存中，但该函数是在内部申请了内存并保存了字符串，因此如果再次调用 inet_ntoa 函数，也有可能覆盖之前保存的字符串信息。</p>
<p>因此要将返回的字符串信息复制到其他内存空间。</p>
<h2 id="网络地址初始化"><a href="#网络地址初始化" class="headerlink" title="网络地址初始化"></a>网络地址初始化</h2><p>下面是服务器端套接字创建过程中常见的网络地址信息初始化方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span> </span><br><span class="line"><span class="type">char</span> *serv_ip = <span class="string">&quot;211.217.168.13&quot;</span>; <span class="comment">// 声明 IP 地址字符串 </span></span><br><span class="line"><span class="type">char</span> *serv_port = <span class="string">&quot;9190&quot;</span>; <span class="comment">// 声明端口号字符串 </span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)); <span class="comment">// 结构体变量 addr 的所有成员初始化为 0，主要是为了将 sockaddr_in 的成员 sin_zero 初始化为 0。 </span></span><br><span class="line">addr.sin_family = AF_INET; <span class="comment">// 指定地址族 </span></span><br><span class="line">addr.sin_addr.s_addr = inet_addr(serv_ip); <span class="comment">// 基于字符串的 IP 地址初始化 </span></span><br><span class="line">addr.sin_port = htons(atoi(serv_port)); <span class="comment">// 基于字符串的端口号初始化</span></span><br></pre></td></tr></table></figure>
<p>服务器端和客户端都要进行网络地址信息的初始化，但目的不同：</p>
<ol>
<li>服务器端要将声明的 sockaddr_in 结构体变量初始化为自己的 IP 地址和端口号，用于在 bind 函数中与自己的套接字相绑定。</li>
<li>客户端也要将声明的 sockaddr_in 结构体变量初始化为服务器端的 IP 地址和端口号，用于在 connect 函数中向服务器发起连接请求。</li>
</ol>
<h2 id="INADDR-ANY"><a href="#INADDR-ANY" class="headerlink" title="INADDR_ANY"></a>INADDR_ANY</h2><p>可以用常数 INADDR_ANY 来获取服务器端的 IP 地址</p>
<p><code>addr.sin_addr.s_addr = htonl(INADDR_ANY); // INADDR_ANY 相当于主机字节序的 32 位整型 IP 地址</code></p>
<p>使用 INADDRY_ANY，如果同一个计算机具有多个 IP 地址，那么可以从不同 IP 地址（的同一端口号）接收数据，因此服务器端中优先使用 INADDR_ANY，而客户端不应该采用。</p>
<h1 id="基于Windows的实现"><a href="#基于Windows的实现" class="headerlink" title="基于Windows的实现"></a>基于Windows的实现</h1><p>在 Windows 中使用 htons、inet_addr、inet_ntoa 函数的方式与在 Linux 中相同，但是要运行它们都需要在项目中添加 ws2_32.lib 库，再将 SDL 检查设为否。</p>
<p>注意：Windows 系统中没有 inet_ntoa 函数，因此要将点分十进制字符串格式的 IP 地址转换为整型只能使用 inet_addr 函数。</p>
<p>WSAStringToAddress&amp;WSAAddressToString</p>
<p>WinSock2.h 增加了两个函数：WSAStringToAddress 和 WSAAddressToString，它们的功能和 inet_addr 函数、inet_ntoa 函数相同，优点是可以用于 IPv4、IPv6 等多种协议，缺点是只能用于 Windows 系统，不利于在 Windows 和 Linux 之间移植，一般使用较少。</p>
<p>这两个函数的详细定义及使用方法详见原书相关章节。</p>
<h1 id="POSIX定义的数据类型"><a href="#POSIX定义的数据类型" class="headerlink" title="POSIX定义的数据类型"></a>POSIX定义的数据类型</h1><p>POSIX（可移植操作系统接口）是为 UNIX 系列操作系统设立的标准，它定义了一些数据类型。</p>
<p>常见的这些基类类型如 int32_t 等位于 sys&#x2F;types.h 文件中，套接字相关的类型位于 sys&#x2F;socket.h 文件中。<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/tAYy/890X345/data_structure_in_POSIX.png" alt="890X345&#x2F;data_structure_in_POSIX.png"></p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="endian-conv-c"><a href="#endian-conv-c" class="headerlink" title="endian_conv.c"></a>endian_conv.c</h2><p>这是一个练习网络字节序与主机字节序之间的转换的程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> host_port = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> net_port;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> host_addr = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> net_addr;</span><br><span class="line"></span><br><span class="line">    net_port = htons(host_port);</span><br><span class="line">    net_addr = htonl(host_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host ordered port: %#x \n&quot;</span>, host_port);         <span class="comment">// 打印结果：0x1234</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network ordered port: %#x \n&quot;</span>, net_port);       <span class="comment">// 打印结果：0x3412</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host ordered address: %#x \n&quot;</span>, host_addr);      <span class="comment">// 打印结果：0x12345678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network ordered address: %#x \n&quot;</span>, net_addr);    <span class="comment">// 打印结果：0x78563412</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inet-addr-c"><a href="#inet-addr-c" class="headerlink" title="inet_addr.c"></a>inet_addr.c</h2><p>此程序用来了解 inet_addr 函数的用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *addr1 = <span class="string">&quot;1.2.3.4&quot;</span>;    </span><br><span class="line">    <span class="type">char</span> *addr2 = <span class="string">&quot;1.2.3.256&quot;</span>;   <span class="comment">// 错误的 IP 地址：一个字节能表示的最大整数是 255</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> conv_addr = inet_addr(addr1);  <span class="comment">// 将 &quot;1.2.3.4&quot; 转换为 0x4030201 并返回</span></span><br><span class="line">    <span class="keyword">if</span> (conv_addr == INADDR_NONE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occured! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#lx \n&quot;</span>, conv_addr);  </span><br><span class="line"></span><br><span class="line">    conv_addr = inet_addr(addr2);   <span class="comment">// 因为 IP 地址无效而返回 INADDR_NONE</span></span><br><span class="line">    <span class="keyword">if</span> (conv_addr == INADDR_NONE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occured! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#lx \n\n&quot;</span>, conv_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inet-aton-c"><a href="#inet-aton-c" class="headerlink" title="inet_aton.c"></a>inet_aton.c</h2><p>此程序用来了解 inet_aton 函数的用法，inet_aton 函数可以将字符串形式的 IP 地址转换为 32 位网络字节序整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *addr = <span class="string">&quot;127.232.124.79&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inet_aton(addr, &amp;addr_inet.sin_addr))      <span class="comment">// 注意 inet_aton 的用法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Conversion error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#x \n&quot;</span>, addr_inet.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inet-ntoa-c"><a href="#inet-ntoa-c" class="headerlink" title="inet_ntoa.c"></a>inet_ntoa.c</h2><p>此程序用来了解 inet_ntoa 函数的用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr1</span>, <span class="title">addr2</span>;</span></span><br><span class="line">    <span class="type">char</span> *str_ptr;</span><br><span class="line">    <span class="type">char</span> str_arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    addr1.sin_addr.s_addr = htonl(<span class="number">0x1020304</span>);</span><br><span class="line">    addr2.sin_addr.s_addr = htonl(<span class="number">0x1010101</span>);</span><br><span class="line"></span><br><span class="line">    str_ptr = inet_ntoa(addr1.sin_addr);</span><br><span class="line">    <span class="built_in">strcpy</span>(str_arr, str_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation1: %s \n&quot;</span>, str_ptr);</span><br><span class="line"></span><br><span class="line">    inet_ntoa(addr2.sin_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation2: %s \n&quot;</span>, str_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation3: %s \n&quot;</span>, str_arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于TCP的服务器端和客户端-2</title>
    <url>/2024/06/08/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF-2/</url>
    <content><![CDATA[<h1 id="回声客户端的完美实现"><a href="#回声客户端的完美实现" class="headerlink" title="回声客户端的完美实现"></a>回声客户端的完美实现</h1><p>服务端没有问题</p>
<p>回声客户端的问题实际上就是没有考虑拆包和粘包的情况。</p>
<h2 id="回声客户端问题的解决方法"><a href="#回声客户端问题的解决方法" class="headerlink" title="回声客户端问题的解决方法"></a>回声客户端问题的解决方法</h2><p>解决方法的核心：提前确定接收数据的大小。</p>
<p>客户端上一次使用 write 从套接字发送了多少字节，紧接着就使用 read 从套接字读取多少字节。</p>
<p>程序示例见 echo_client2.c</p>
<h2 id="定义应用层协议"><a href="#定义应用层协议" class="headerlink" title="定义应用层协议"></a>定义应用层协议</h2><p>上面的回声客户端中，提前就知道要接收的数据长度，但是一般是不知道的。这种情况下，要解决拆包和粘包的问题，就要定义应用层协议。</p>
<p>应用层协议实际就是在服务器端&#x2F;客户端的实现过程中逐步定义的规则的集合。</p>
<p>在应用层协议中可以定好数据边界的表示方法、数据的长度范围等。</p>
<h1 id="计算器服务器端-客户端示例"><a href="#计算器服务器端-客户端示例" class="headerlink" title="计算器服务器端&#x2F;客户端示例"></a>计算器服务器端&#x2F;客户端示例</h1><p>程序内容见 op_client.c 和 op_server.c。</p>
<h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h2><p>服务器从客户端获得操作数和运算符信息，完成计算后把结果传回客户端。</p>
<p>客户端运行方式及运行结果如图所示：<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/bMlH/456X158/run_op-client.png" alt="456X158&#x2F;run_op-client.png"></p>
<h2 id="程序实现方法"><a href="#程序实现方法" class="headerlink" title="程序实现方法"></a>程序实现方法</h2><p>为了实现以上功能，定义了一个简单的应用层协议，用来约定在服务器端和客户端之间传输数据的规则。</p>
<p>协议内容包括：</p>
<ol>
<li>客户端用 1 个字节整数形式传递操作数的个数。</li>
<li>客户端向服务器端传送的每个操作数占用 4 字节。</li>
<li>传递完操作数后紧跟着传递一个占用 1 字节的运算符。</li>
<li>服务器端以 4 字节整数向客户端传回运算结果。</li>
<li>客户端得到运算结果后终止与服务器端的连接。</li>
</ol>
<h1 id="TCP原理"><a href="#TCP原理" class="headerlink" title="TCP原理"></a>TCP原理</h1><h2 id="TCP套接字中的IO缓冲"><a href="#TCP套接字中的IO缓冲" class="headerlink" title="TCP套接字中的IO缓冲"></a>TCP套接字中的IO缓冲</h2><p>在使用 read&#x2F;write 函数对套接字进行读写数据时，实际上读写的是套接字输入&#x2F;输出缓冲中的内容。</p>
<p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/fPlt/741X292/true_IO_in_TCP.png" alt="741X292&#x2F;true_IO_in_TCP.png"><br>套接字 I&#x2F;O 缓冲的特性：</p>
<ol>
<li>I&#x2F;O 缓冲在每个套接字中单独存在。</li>
<li>I&#x2F;O 缓冲在创建套接字时自动生成。</li>
<li>即使关闭套接字也会继续传递输出缓冲中遗留的数据。</li>
<li>关闭套接字将丢失输入缓冲中的数据</li>
</ol>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><h2 id="echo-client2-c"><a href="#echo-client2-c" class="headerlink" title="echo_client2.c"></a>echo_client2.c</h2><p>此程序是回声客户端的完美实现，它记录了发送给服务器端的数据的长度，然后从套接字读取相同长度的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, recv_len, recv_cnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(message, BUF_SIZE, stdin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        str_len = <span class="built_in">write</span>(sock, message, <span class="built_in">strlen</span>(message));  <span class="comment">// 发送了 str_len 个字节</span></span><br><span class="line">        recv_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (recv_len &lt; str_len)</span><br><span class="line">        &#123;</span><br><span class="line">            recv_cnt = <span class="built_in">read</span>(sock, &amp;message[recv_len], BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (recv_cnt == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">error_handling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">            recv_len += recv_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="op-client-c"><a href="#op-client-c" class="headerlink" title="op_client.c"></a>op_client.c</h2><p>这是计算器客户端的实现。</p>
<p>注意两个地方：</p>
<ol>
<li>应用层协议的定义和实现。</li>
<li>在同一个数组中保存并传输多种数据类型的方式：将数组声明为 char 类型，在向数组读写内容时转换指针的类型。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPSZ 4 <span class="comment">// 定义每个操作数在 TCP 报文中占用的字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> opmsg[BUF_SIZE]; <span class="comment">// opmsg 用来存储要发送的数据，注意是 char 类型数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="type">int</span> operand_count, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)))</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connecting..........\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operand count: &quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;operand_count);</span><br><span class="line">    opmsg[<span class="number">0</span>] = (<span class="type">char</span>)operand_count; <span class="comment">// 数据的第一个字节存储操作数的数量，注意要将变量类型转换为 char。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; operand_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Operand %d: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="type">int</span> *)&amp;opmsg[i * OPSZ + <span class="number">1</span>]); <span class="comment">// 从第二个字节开始每四个字节存储一个操作数，向数组存数据时先取地址再转换类型。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fgetc</span>(stdin);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operator: &quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;opmsg[operand_count * OPSZ + <span class="number">1</span>]); <span class="comment">// 再用一个字节存储运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(sock, opmsg, operand_count * OPSZ + <span class="number">2</span>); <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="built_in">read</span>(sock, &amp;result, OPSZ);                    <span class="comment">// 接收运算结果：运算结果是一个 4 字节的操作数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Operation result: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="op-server-c"><a href="#op-server-c" class="headerlink" title="op_server.c"></a>op_server.c</h2><p>这是计算器服务器端的实现。</p>
<p>原书中这里有一个问题，如果决定要用一个字节来接收客户端发送的操作数个数，那么就应该用 char 类型的变量来接收，而不是 int 类型。</p>
<p>因为int类型的变量在某些平台上可能占用4个字节，而char类型的变量只占用1个字节，这样会导致接收的数据不正确。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPSZ 4</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> operand_count, <span class="type">int</span> operands[], <span class="type">char</span> <span class="keyword">operator</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">int</span> clnt_addr_sz;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_addr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_addr, &amp;clnt_addr_sz)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">error_handling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> op_cnt_char;</span><br><span class="line">        <span class="type">int</span> operand_count;</span><br><span class="line">        <span class="built_in">read</span>(clnt_sock, &amp;op_cnt_char, <span class="number">1</span>); <span class="comment">// 读取1个字节到 char 变量中</span></span><br><span class="line">        operand_count = (<span class="type">int</span>)op_cnt_char; <span class="comment">// 然后再转换为 int</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> operands[BUF_SIZE];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; operand_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(clnt_sock, &amp;operands[i * OPSZ], OPSZ); <span class="comment">// 根据操作数数量，依次读取操作数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="keyword">operator</span>;</span><br><span class="line">        <span class="built_in">read</span>(clnt_sock, &amp;<span class="keyword">operator</span>, <span class="number">1</span>); <span class="comment">// 读取运算符</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">calculate</span>(operand_count, (<span class="type">int</span> *)operands, <span class="keyword">operator</span>);</span><br><span class="line">        <span class="built_in">write</span>(clnt_sock, (<span class="type">char</span> *)&amp;result, <span class="built_in">sizeof</span>(result)); <span class="comment">// 发送计算结果</span></span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> operand_count, <span class="type">int</span> operands[], <span class="type">char</span> <span class="keyword">operator</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = operands[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">operator</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; operand_count; i++)</span><br><span class="line">            result += operands[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; operand_count; i++)</span><br><span class="line">            result -= operands[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; operand_count; i++)</span><br><span class="line">            result *= operands[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于UDP的服务器端和客户端</title>
    <url>/2024/06/09/%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="理解UDP"><a href="#理解UDP" class="headerlink" title="理解UDP"></a>理解UDP</h1><p>区分 TCP 与 UDP 的一个典型比喻：UDP 好比寄信，TCP 好比打电话：</p>
<ol>
<li>UDP：寄信前要在信封上填好寄信人和收信人的地址，然后放进邮筒。不能确认对方是否收到信件，并且邮寄过程中信件可能丢失。</li>
<li>TCP：首先要拨打电话号码，打通后才能开始通话，但打通后的通话是可靠的。</li>
</ol>
<p>TCP 和 UDP 最重要的区别在于流控制。</p>
<p>理解：这里的流控制应该包含了 TCP 的可靠传输、流量控制、拥塞控制等机制，这些机制都是在流上实现的。</p>
<p>TCP 比 UDP 更可靠，UDP 更简洁，速度更快。</p>
<h2 id="UDP使用"><a href="#UDP使用" class="headerlink" title="UDP使用"></a>UDP使用</h2><p>网络实时传输多媒体数据一般使用 UDP。</p>
<p>TCP 比 UDP 慢的两个原因：</p>
<ol>
<li>TCP 数据传输前后要进行连接的建立与释放。</li>
<li>TCP 数据传输过程中为了保证可靠性而添加的流控制。</li>
</ol>
<p>当收发的数据量小但需要频繁连接时，UDP 的高效体现地更明显。</p>
<h1 id="实现基于UDP的服务器端-客户端"><a href="#实现基于UDP的服务器端-客户端" class="headerlink" title="实现基于UDP的服务器端&#x2F;客户端"></a>实现基于UDP的服务器端&#x2F;客户端</h1><p>因为 UDP 是无连接的，所以在编程时不需要调用 listen 函数和 accept 函数。</p>
<p>UDP 套接字编程中只有创建套接字和数据交换两个过程。</p>
<h2 id="UDP服务器端和客户端均只需-1-个套接字"><a href="#UDP服务器端和客户端均只需-1-个套接字" class="headerlink" title="UDP服务器端和客户端均只需 1 个套接字"></a>UDP服务器端和客户端均只需 1 个套接字</h2><p>TCP 中，服务器端和客户端的套接字是一对一的关系，服务器端每向一个客户端提供服务，就需要分配一个新的套接字。</p>
<p>而 UDP 的服务器端和客户端均只需 1 个套接字，服务器端只要有一个 UDP 套接字就可以和多台主机通信。</p>
<h2 id="基于UDP的数据IO函数"><a href="#基于UDP的数据IO函数" class="headerlink" title="基于UDP的数据IO函数"></a>基于UDP的数据IO函数</h2><p>UDP 套接字不会保持连接状态，因此每次传输数据时都要添加目标地址信息（相当于寄信前在信封上写收信地址）。</p>
<h3 id="发送UDP数据的函数"><a href="#发送UDP数据的函数" class="headerlink" title="发送UDP数据的函数"></a>发送UDP数据的函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span>* buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* to, <span class="type">socklen_t</span> addrlen)</span></span>; </span><br><span class="line">	<span class="comment">// 功能：向 to 中所指明的目标地址发送数据。 </span></span><br><span class="line">	<span class="comment">// 参数：sock：UDP 套接字文件描述符; buff：用户保存接收的数据; nbytes：可接收的最大字节数; </span></span><br><span class="line">	<span class="comment">// flags：可选项参数，没有则为 0; to：包含目标地址信息; addrlen：包含目标地址信息的结构体变量的长度 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回接收的字节数，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>
<h3 id="接收-UDP-数据的函数"><a href="#接收-UDP-数据的函数" class="headerlink" title="接收 UDP 数据的函数"></a>接收 UDP 数据的函数</h3><p>理解：接收端本来是不知道发送端的地址的，但调用完 recvfrom 函数后，发送端的地址信息就会存储到参数 from 指向的结构体中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span>* buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* from, <span class="type">socklen_t</span> *addrlen)</span></span>; </span><br><span class="line">	<span class="comment">// 功能：从 from 中所指明的地址接收数据。 </span></span><br><span class="line">	<span class="comment">// 参数：sock：UDP 套接字文件描述符; buff：待传输的数据; nbytes：待传输的数据长度（单位是字节）; </span></span><br><span class="line">	<span class="comment">// flags：可选项参数，没有则为 0; from：用来存储发送端的地址信息; addrlen：包含发送端地址信息的结构体变量的长度 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回传输的字节数，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>
<h2 id="UDP客户端套接字的地址分配"><a href="#UDP客户端套接字的地址分配" class="headerlink" title="UDP客户端套接字的地址分配"></a>UDP客户端套接字的地址分配</h2><p>在 TCP 的客户端中 conncect 函数会自动完成给套接字分配 IP 地址和端口号的过程，UDP 中则是 sendto 函数来完成此功能。</p>
<p>如果调用 sendto 函数时发现尚未给套接字分配地址信息，就会在首次调用 sendto 函数时给套接字分配 IP 地址和端口。</p>
<h1 id="UDP的数据传输特性和调用connect函数"><a href="#UDP的数据传输特性和调用connect函数" class="headerlink" title="UDP的数据传输特性和调用connect函数"></a>UDP的数据传输特性和调用connect函数</h1><h2 id="存在数据边界的UDP套接字"><a href="#存在数据边界的UDP套接字" class="headerlink" title="存在数据边界的UDP套接字"></a>存在数据边界的UDP套接字</h2><p>UDP 套接字编程时，接收端输入函数的调用次数必须和发送端输出函数的调用次数相同，这样才能接收完发送端发送的数据。</p>
<h2 id="已连接UDP套接字和未连接UDP套接字"><a href="#已连接UDP套接字和未连接UDP套接字" class="headerlink" title="已连接UDP套接字和未连接UDP套接字"></a>已连接UDP套接字和未连接UDP套接字</h2><p>通过 sendto 函数传输数据的过程包括三个阶段：</p>
<ol>
<li>向UDP套接字注册目标IP和端口号（注意：是将 UDP 套接字与目标的地址信息相关联，不是给 UDP 分配地址信息。前者每次 sendto 都会执行，后者只有首次调用且套接字尚未分配地址时才会执行一次）。</li>
<li>传输数据</li>
<li>删除UDP套接字中注册的目标地址信息</li>
</ol>
<p>当多次通过 sendto 向同一个目标发送信息时，每次 sendto 都进行上面的步骤 1 和 3，就会很浪费时间。</p>
<p>因此当要长时间与同一主机通信时，将 UDP 变为已连接套接字会提高效率。</p>
<h2 id="创建已连接UDP套接字"><a href="#创建已连接UDP套接字" class="headerlink" title="创建已连接UDP套接字"></a>创建已连接UDP套接字</h2><p>使用 connect 函数创建已连接 UDP 套接字。</p>
<p><code>connect(sock, (struct sockaddr*)&amp;adr, sizeof(adr)); // 注意：adr 是目标的地址信息</code></p>
<p>使用已连接的 UDP 套接字进行通信时， sendto 函数就不会再执行步骤 1 和步骤 3，每次只要传输数据即可。</p>
<p>并且已连接的 UDP 套接字也可以通过 write、read 函数进行通信。</p>
<p>使用已连接 UPD 套接字的例子见程序实例中的 uecho_con_client.c。</p>
<h1 id="windows实现"><a href="#windows实现" class="headerlink" title="windows实现"></a>windows实现</h1><p>Windows 下也有 sendto 和 recvfrom 函数，用法和 linux 下的版本一样。</p>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><h2 id="uecho-server-c"><a href="#uecho-server-c" class="headerlink" title="uecho_server.c"></a>uecho_server.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;UDP socket creation error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">        str_len = <span class="built_in">recvfrom</span>(serv_sock, message, BUF_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, clnt_adr_sz); <span class="comment">// 接收数据同时获取发送端地址</span></span><br><span class="line">        <span class="built_in">sendto</span>(serv_sock, message, str_len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, clnt_adr_sz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock); <span class="comment">// 上面的 while 是无限循环，这里的 colse 函数没什么实际意义。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="xxxxxxxxxx93-1-include-2-include-3-include-4-include-5-include-6-include-7​8-define-BUF-SIZE-509-define-OPSZ-410void-error-handling-char-message-11int-calculate-int-operand-count-int-operands-char-operator-12​13int-main-int-argc-char-argv-14-15-int-serv-sock-clnt-sock-16-struct-sockaddr-in-serv-addr-clnt-addr-17-int-clnt-addr-sz-18-char-message-BUF-SIZE-19​20-if-argc-2-21-22-printf-“Usage-s-“-argv-0-23-exit-1-24-25​26-serv-sock-socket-PF-INET-SOCK-STREAM-0-27​28-memset-serv-addr-0-sizeof-serv-addr-29-serv-addr-sin-family-AF-INET-30-serv-addr-sin-addr-s-addr-htonl-INADDR-ANY-31-serv-addr-sin-port-htons-atoi-argv-1-32​33-if-bind-serv-sock-struct-sockaddr-serv-addr-sizeof-serv-addr-1-34-error-handling-“bind-error”-35​36-if-listen-serv-sock-5-1-37-error-handling-“listen-error”-38​39-clnt-addr-sz-sizeof-clnt-addr-40-for-int-i-0-i-5-i-41-42-if-clnt-sock-accept-serv-sock-struct-sockaddr-clnt-addr-clnt-addr-sz-1-43-error-handling-“accept-error”-44​45-char-op-cnt-char-46-int-operand-count-47-read-clnt-sock-op-cnt-char-1-读取1个字节到-char-变量中48-operand-count-int-op-cnt-char-然后再转换为-int49​50-char-operands-BUF-SIZE-51-for-int-i-0-i-operand-count-i-52-53-read-clnt-sock-operands-i-OPSZ-OPSZ-根据操作数数量，依次读取操作数54-55​56-char-operator-57-read-clnt-sock-operator-1-读取运算符58​59-int-result-calculate-operand-count-int-operands-operator-60-write-clnt-sock-char-result-sizeof-result-发送计算结果61-close-clnt-sock-62-63-close-serv-sock-64-return-0-65-66​67int-calculate-int-operand-count-int-operands-char-operator-68-69-int-result-operands-0-70-switch-operator-71-72-case-‘-’-73-for-int-i-1-i-operand-count-i-74-result-operands-i-75-break-76-case-‘-‘-77-for-int-i-1-i-operand-count-i-78-result-operands-i-79-break-80-case-‘‘-81-for-int-i-1-i-operand-count-i-82-result-operands-i-83-break-84-85-return-result-86-87​88void-error-handling-char-message-89-90-fputs-message-stderr-91-fputc-‘-n’-stderr-92-exit-1-93-cpp"><a href="#xxxxxxxxxx93-1-include-2-include-3-include-4-include-5-include-6-include-7​8-define-BUF-SIZE-509-define-OPSZ-410void-error-handling-char-message-11int-calculate-int-operand-count-int-operands-char-operator-12​13int-main-int-argc-char-argv-14-15-int-serv-sock-clnt-sock-16-struct-sockaddr-in-serv-addr-clnt-addr-17-int-clnt-addr-sz-18-char-message-BUF-SIZE-19​20-if-argc-2-21-22-printf-“Usage-s-“-argv-0-23-exit-1-24-25​26-serv-sock-socket-PF-INET-SOCK-STREAM-0-27​28-memset-serv-addr-0-sizeof-serv-addr-29-serv-addr-sin-family-AF-INET-30-serv-addr-sin-addr-s-addr-htonl-INADDR-ANY-31-serv-addr-sin-port-htons-atoi-argv-1-32​33-if-bind-serv-sock-struct-sockaddr-serv-addr-sizeof-serv-addr-1-34-error-handling-“bind-error”-35​36-if-listen-serv-sock-5-1-37-error-handling-“listen-error”-38​39-clnt-addr-sz-sizeof-clnt-addr-40-for-int-i-0-i-5-i-41-42-if-clnt-sock-accept-serv-sock-struct-sockaddr-clnt-addr-clnt-addr-sz-1-43-error-handling-“accept-error”-44​45-char-op-cnt-char-46-int-operand-count-47-read-clnt-sock-op-cnt-char-1-读取1个字节到-char-变量中48-operand-count-int-op-cnt-char-然后再转换为-int49​50-char-operands-BUF-SIZE-51-for-int-i-0-i-operand-count-i-52-53-read-clnt-sock-operands-i-OPSZ-OPSZ-根据操作数数量，依次读取操作数54-55​56-char-operator-57-read-clnt-sock-operator-1-读取运算符58​59-int-result-calculate-operand-count-int-operands-operator-60-write-clnt-sock-char-result-sizeof-result-发送计算结果61-close-clnt-sock-62-63-close-serv-sock-64-return-0-65-66​67int-calculate-int-operand-count-int-operands-char-operator-68-69-int-result-operands-0-70-switch-operator-71-72-case-‘-’-73-for-int-i-1-i-operand-count-i-74-result-operands-i-75-break-76-case-‘-‘-77-for-int-i-1-i-operand-count-i-78-result-operands-i-79-break-80-case-‘‘-81-for-int-i-1-i-operand-count-i-82-result-operands-i-83-break-84-85-return-result-86-87​88void-error-handling-char-message-89-90-fputs-message-stderr-91-fputc-‘-n’-stderr-92-exit-1-93-cpp" class="headerlink" title="xxxxxxxxxx93 1#include &lt;stdio.h&gt;2#include &lt;stdlib.h&gt;3#include &lt;string.h&gt;4#include &lt;unistd.h&gt;5#include &lt;arpa&#x2F;inet.h&gt;6#include &lt;sys&#x2F;socket.h&gt;7​8#define BUF_SIZE 509#define OPSZ 410void error_handling(char *message);11int calculate(int operand_count, int operands[], char operator);12​13int main(int argc, char *argv[])14{15    int serv_sock, clnt_sock;16    struct sockaddr_in serv_addr, clnt_addr;17    int clnt_addr_sz;18    char message[BUF_SIZE];19​20    if (argc !&#x3D; 2)21    {22        printf(“Usage : %s “, argv[0]);23        exit(1);24    }25​26    serv_sock &#x3D; socket(PF_INET, SOCK_STREAM, 0);27​28    memset(&amp;serv_addr, 0, sizeof(serv_addr));29    serv_addr.sin_family &#x3D; AF_INET;30    serv_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);31    serv_addr.sin_port &#x3D; htons(atoi(argv[1]));32​33    if (bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &#x3D;&#x3D; -1)34        error_handling(“bind() error”);35​36    if (listen(serv_sock, 5) &#x3D;&#x3D; -1)37        error_handling(“listen() error”);38​39    clnt_addr_sz &#x3D; sizeof(clnt_addr);40    for (int i &#x3D; 0; i &lt; 5; i++)41    {42        if ((clnt_sock &#x3D; accept(serv_sock, (struct sockaddr *)&amp;clnt_addr, &amp;clnt_addr_sz)) &#x3D;&#x3D; -1)43            error_handling(“accept() error”);44​45        char op_cnt_char;46        int operand_count;47        read(clnt_sock, &amp;op_cnt_char, 1); &#x2F;&#x2F; 读取1个字节到 char 变量中48        operand_count &#x3D; (int)op_cnt_char; &#x2F;&#x2F; 然后再转换为 int49​50        char operands[BUF_SIZE];51        for (int i &#x3D; 0; i &lt; operand_count; i++)52        {53            read(clnt_sock, &amp;operands[i * OPSZ], OPSZ); &#x2F;&#x2F; 根据操作数数量，依次读取操作数54        }55​56        char operator;57        read(clnt_sock, &amp;operator, 1); &#x2F;&#x2F; 读取运算符58​59        int result &#x3D; calculate(operand_count, (int *)operands, operator);60        write(clnt_sock, (char )&amp;result, sizeof(result)); &#x2F;&#x2F; 发送计算结果61        close(clnt_sock);62    }63    close(serv_sock);64    return 0;65}66​67int calculate(int operand_count, int operands[], char operator)68{69    int result &#x3D; operands[0];70    switch (operator)71    {72    case ‘+’:73        for (int i &#x3D; 1; i &lt; operand_count; i++)74            result +&#x3D; operands[i];75        break;76    case ‘-‘:77        for (int i &#x3D; 1; i &lt; operand_count; i++)78            result -&#x3D; operands[i];79        break;80    case ‘‘:81        for (int i &#x3D; 1; i &lt; operand_count; i++)82            result *&#x3D; operands[i];83        break;84    }85    return result;86}87​88void error_handling(char *message)89{90    fputs(message, stderr);91    fputc(‘\n’, stderr);92    exit(1);93}cpp"></a>xxxxxxxxxx93 1#include &lt;stdio.h&gt;2#include &lt;stdlib.h&gt;3#include &lt;string.h&gt;4#include &lt;unistd.h&gt;5#include &lt;arpa&#x2F;inet.h&gt;6#include &lt;sys&#x2F;socket.h&gt;7​8#define BUF_SIZE 509#define OPSZ 410void error_handling(char *message);11int calculate(int operand_count, int operands[], char operator);12​13int main(int argc, char *argv[])14{15    int serv_sock, clnt_sock;16    struct sockaddr_in serv_addr, clnt_addr;17    int clnt_addr_sz;18    char message[BUF_SIZE];19​20    if (argc !&#x3D; 2)21    {22        printf(“Usage : %s <port>“, argv[0]);23        exit(1);24    }25​26    serv_sock &#x3D; socket(PF_INET, SOCK_STREAM, 0);27​28    memset(&amp;serv_addr, 0, sizeof(serv_addr));29    serv_addr.sin_family &#x3D; AF_INET;30    serv_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);31    serv_addr.sin_port &#x3D; htons(atoi(argv[1]));32​33    if (bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &#x3D;&#x3D; -1)34        error_handling(“bind() error”);35​36    if (listen(serv_sock, 5) &#x3D;&#x3D; -1)37        error_handling(“listen() error”);38​39    clnt_addr_sz &#x3D; sizeof(clnt_addr);40    for (int i &#x3D; 0; i &lt; 5; i++)41    {42        if ((clnt_sock &#x3D; accept(serv_sock, (struct sockaddr *)&amp;clnt_addr, &amp;clnt_addr_sz)) &#x3D;&#x3D; -1)43            error_handling(“accept() error”);44​45        char op_cnt_char;46        int operand_count;47        read(clnt_sock, &amp;op_cnt_char, 1); &#x2F;&#x2F; 读取1个字节到 char 变量中48        operand_count &#x3D; (int)op_cnt_char; &#x2F;&#x2F; 然后再转换为 int49​50        char operands[BUF_SIZE];51        for (int i &#x3D; 0; i &lt; operand_count; i++)52        {53            read(clnt_sock, &amp;operands[i * OPSZ], OPSZ); &#x2F;&#x2F; 根据操作数数量，依次读取操作数54        }55​56        char operator;57        read(clnt_sock, &amp;operator, 1); &#x2F;&#x2F; 读取运算符58​59        int result &#x3D; calculate(operand_count, (int *)operands, operator);60        write(clnt_sock, (char <em>)&amp;result, sizeof(result)); &#x2F;&#x2F; 发送计算结果61        close(clnt_sock);62    }63    close(serv_sock);64    return 0;65}66​67int calculate(int operand_count, int operands[], char operator)68{69    int result &#x3D; operands[0];70    switch (operator)71    {72    case ‘+’:73        for (int i &#x3D; 1; i &lt; operand_count; i++)74            result +&#x3D; operands[i];75        break;76    case ‘-‘:77        for (int i &#x3D; 1; i &lt; operand_count; i++)78            result -&#x3D; operands[i];79        break;80    case ‘</em>‘:81        for (int i &#x3D; 1; i &lt; operand_count; i++)82            result *&#x3D; operands[i];83        break;84    }85    return result;86}87​88void error_handling(char *message)89{90    fputs(message, stderr);91    fputc(‘\n’, stderr);92    exit(1);93}cpp</port></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, from_adr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Insert message(q to quit): &quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(message, <span class="built_in">sizeof</span>(message), stdin);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sendto</span>(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">        adr_sz = <span class="built_in">sizeof</span>(from_adr);</span><br><span class="line">        str_len = <span class="built_in">recvfrom</span>(sock, message, BUF_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;from_adr, &amp;adr_sz);</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uecho-con-client-c"><a href="#uecho-con-client-c" class="headerlink" title="uecho_con_client.c"></a>uecho_con_client.c</h2><p>这是一个使用已连接 UDP 套接字的例子，在前面的 uecho_client.c 的基础上修改得到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">socklen_t</span> adr_sz; <span class="comment">// 实际上已不需要这个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, from_adr; <span class="comment">// from_adr 也不再需要</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 将套接字变为已连接套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Insert message(q to quit): &quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(message, <span class="built_in">sizeof</span>(message), stdin);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(sock, message, <span class="built_in">strlen</span>(message));  <span class="comment">// 使用 write 代替了 sendto 函数</span></span><br><span class="line">        str_len = <span class="built_in">read</span>(sock, message, <span class="built_in">sizeof</span>(message) - <span class="number">1</span>); <span class="comment">// 使用 read 代替了 recvfrom 函数</span></span><br><span class="line"></span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程服务器端</title>
    <url>/2024/07/08/%E5%A4%9A%E7%A7%8DIO%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>本章笔记简略</p>
<span id="more"></span>

<h1 id="send和recv函数"><a href="#send和recv函数" class="headerlink" title="send和recv函数"></a>send和recv函数</h1><p>注意：send、recv 函数位于头文件 sys&#x2F;socket.h 中，是专用于套接字收发数据的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>; </span><br><span class="line">            <span class="comment">// 功能：通过套接字 sockfd 向连接方发送数据</span></span><br><span class="line">            <span class="comment">// 参数：sockfd：套接字文件描述符；buf：待传输数据；nbytes：要传输的字节数；flags：传输数据时用到的选项，一般可以写 0。</span></span><br><span class="line">            <span class="comment">// 返回值：成功时返回发送的字节数（遇到文件尾 EOF 时返回 0），失败时返回 -1 并设置 errno</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>; </span><br><span class="line">            <span class="comment">// 功能：从套接字 sockfd 接收数据</span></span><br><span class="line">            <span class="comment">// 参数：sockfd：套接字文件描述符；buf：保存接收的数据；nbytes：可接收的最大字节数；flags：传输数据时用到的选项，一般可以写 0。</span></span><br><span class="line">            <span class="comment">// 返回值：成功时返回接收的字节数（遇到文件尾 EOF 时返回 0），失败时返回 -1 并设置 errno</span></span><br></pre></td></tr></table></figure>
<p>send 和 recv 函数也是默认阻塞的，可以通过给 flags 参数传递 MSG_DONTWAIT 来修改为非阻塞模式。</p>
<p>flags有以下可选项：<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251012/YVA7/932X256/flags_choices.png" alt="932X256&#x2F;flags_choices.png"></p>
<h2 id="MSG-OOB：发送紧急消息"><a href="#MSG-OOB：发送紧急消息" class="headerlink" title="MSG_OOB：发送紧急消息"></a>MSG_OOB：发送紧急消息</h2><p>MSG_OOB可选项就用于创建特殊发送方法和通道以发送紧急消息。</p>
<p>设置该选项后，TCP包中将URG位设置为1，,并通过紧急指针表示紧急消息所在位置。</p>
<p>传递的紧急消息只有1字节，除紧急指针的前面1个字节外,数据接收方将通过调用常用输入函数读取剩余部分</p>
<p>紧急消息的意义在于督促消息处理,而非紧急传输形式受限的消息。</p>
<h1 id="readv-writev函数"><a href="#readv-writev函数" class="headerlink" title="readv &amp; writev函数"></a>readv &amp; writev函数</h1><p>readv 和 writev 可以对数据进行整合传输及发送。具体而言：</p>
<ol>
<li>writev 可以将分散保存在多个缓冲中的数据一并发送。</li>
<li>readv 函数可以由多个缓存分别接收数据。</li>
</ol>
<p>适当使用 readv 和 writev 函数可以减少 I&#x2F;O 函数的调用次数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovec* iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line">                <span class="comment">// 功能：将 iov 缓冲区的数据进行整合并发送.</span></span><br><span class="line">                <span class="comment">// 参数：filedes：套接字文件描述符；iov：iovec 结构体数组的地址值；iovcnt 表示第二个参数的数组长度。</span></span><br><span class="line">                <span class="comment">// 返回值：成功时返回发送的字节数，失败时返回 -1。</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovec* iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line">                <span class="comment">// 功能：从 filedes 读取数据并存储到多个缓冲区中.</span></span><br><span class="line">                <span class="comment">// 参数：filedes：套接字文件描述符；iov：iovec 结构体数组的地址值；iovcnt 表示第二个参数的数组长度。</span></span><br><span class="line">                <span class="comment">// 返回值：成功时返回接收的字节数，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>
<p>iovec 结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>* iov_base; <span class="comment">// 指向缓冲区的指针</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">// 缓冲区的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>哪种情况适合使用readv和writev函数?实际上,能使用该函数的所有情况都适用。</p>
<p>例如,需要传输的数据分别位于不同缓冲(数组)时,需要多次调用write函数。此时可以通过1次writev 函数调用替代操作,当然会提高效率。同样,需要将输入缓冲中的数据读入不同位置时,可以不 必多次调用read函数,而是利用1次readv函数就能大大提高效率。</p>
<p>但其更大的意义在于减少数据包个数。</p>
<p>考虑下面这种场景：<br>	待发送的数据分别存在3个不同的地方,此时如果使用write函数则需要3次函数调用。<br>		<br>	但若为提高速度而关闭了Nagle算法,则极有可能通过3个数据包传递数据。<br>	<br>	反之,若使用writev 函数将所有数据一次性写入输出缓冲,则很有可能仅通过1个数据包传输数据。<br>再考虑一种情况:<br>	将不同位置的数据按照发送顺序移动(复制)到1个大数组,并通过1次 write函数调用进行传输。<br>	<br>	这种方式是否与调用writev函数的效果相同?当然!但使用writev函数更为便利。</p>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程服务器端的实现</title>
    <url>/2024/07/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="线程创建及运行"><a href="#线程创建及运行" class="headerlink" title="线程创建及运行"></a>线程创建及运行</h1><p>下面的线程创建方法符合 POSIX 规范，不仅适用于 Linux，也适用于大部分 UNIX 系列的操作系统。</p>
<p>线程具有单独的执行流，因此要单独定义线程的 main 函数，还要请求操作系统在单独的执行流中执行该函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* <span class="keyword">restrict</span> thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* <span class="keyword">restrict</span> attr, <span class="type">void</span>*(* start_routine)(<span class="type">void</span> *), <span class="type">void</span>* <span class="keyword">restrict</span> arg)</span>;</span><br><span class="line">        <span class="comment">// 功能：创建线程并设置该线程的入口函数，然后运行该线程。</span></span><br><span class="line">        <span class="comment">// 参数：thread：用于保存新创建的线程 ID；attr：用于传递线程属性，当 attr 值为 NULL，创建默认属性的线程；</span></span><br><span class="line">                <span class="comment">// start_routine：相当于线程的 main 函数； arg：传递 start_routine 函数的参数信息。</span></span><br><span class="line">        <span class="comment">// 返回值：成功时返回 0，失败时返回其他值。</span></span><br></pre></td></tr></table></figure>
<h2 id="restrict-关键字"><a href="#restrict-关键字" class="headerlink" title="restrict 关键字"></a>restrict 关键字</h2><p>restrict 是 C99 引入的一种类型限定符，它告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</p>
<h2 id="使用线程相关函数时的注意事项"><a href="#使用线程相关函数时的注意事项" class="headerlink" title="使用线程相关函数时的注意事项"></a>使用线程相关函数时的注意事项</h2><p>注意：由于 pthread 库不是 Linux 系统默认的库，链接时需要使用静态库 libpthread.a，所以当使用了线程相关的函数后，在编译时要加 -lpthread 选项以声明需要连接线程库，这样才能调用头文件 pthread.h 中声明的函数。</p>
<p>否则会报错：对 pthread_create 未定义的引用。</p>
<h2 id="控制线程的执行流"><a href="#控制线程的执行流" class="headerlink" title="控制线程的执行流"></a>控制线程的执行流</h2><p>在程序实例 thread1.c 中，使用 sleep 函数来控制线程的执行流，这种方法并不好。</p>
<p>应该使用 pthread_join 函数来控制线程的执行流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** status)</span>;</span><br><span class="line">        <span class="comment">// 功能：等待线程 thread 的终止，并获取线程 main 函数的返回值。</span></span><br><span class="line">        <span class="comment">// 参数：thread：要等待的线程 ID；status：用于保存线程的 main 函数返回值的指针变量的地址值。</span></span><br><span class="line">        <span class="comment">// 返回值：成功时返回 0，失败时返回其他值。</span></span><br></pre></td></tr></table></figure>
<p>调用 pthread_join 函数的进程或线程会进入等待状态，直到 ID 为 thread（第一个参数）的线程终止。</p>
<h2 id="可在临界区内调用的函数"><a href="#可在临界区内调用的函数" class="headerlink" title="可在临界区内调用的函数"></a>可在临界区内调用的函数</h2><p>根据临界区是否引起问题，可以将函数分为两类：</p>
<ol>
<li>线程安全函数：被多个线程同时调用时不会发生竞争。又称可重入函数。</li>
<li>非线程安全函数：被多个线程同时调用时可能发生竞争。又称不可重入函数。</li>
</ol>
<p>大多数标准函数都是线程安全函数（即可重入函数），其他非线程安全的函数也提供了具有相同功能的线程安全的函数，对应的线程安全函数的后缀会加上 “_r”。</p>
<p>如 gethostbyname 就是非线程安全函数，它对应的线程安全版本如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname)</span>;   <span class="comment">// 非线程安全函数</span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="keyword">struct</span> hostent* result, <span class="type">char</span>* buffer, <span class="type">int</span> buflen, <span class="type">int</span>* h_errnop)</span>; <span class="comment">// 对应的线程安全版本。</span></span><br></pre></td></tr></table></figure>

<p>标准函数中非线程安全函数对应的线程安全版本调用更复杂，其函数名、参数都不同，但是程序员并不需要手动去调用。</p>
<p>_ REENTRANT</p>
<p>定义宏 _ REENTRANT 即可自动将非线程安全函数转换为对应的线程安全版本。</p>
<p>宏 _ REENTRANT 有两种定义方法：</p>
<ol>
<li>声明头文件前定义 _ REENTRANT 宏。</li>
<li>不使用 #define 定义宏，而是 直接在编译时添加 -D_REENTRANT 选项来定义宏。</li>
</ol>
<h2 id="工作线程模型"><a href="#工作线程模型" class="headerlink" title="工作线程模型"></a>工作线程模型</h2><p>工作线程模型即主线程不负责具体的计算工作，而是创建工作线程来完成工作。</p>
<p>使用工作线程模型的例子见程序实例的 thread3.c。该例子中存在临界区相关问题。</p>
<p>thread4.c 进一步放大了临界区问题。</p>
<h1 id="线程存在的问题和临界区"><a href="#线程存在的问题和临界区" class="headerlink" title="线程存在的问题和临界区"></a>线程存在的问题和临界区</h1><p>任何内存空间——只要是同时被访问——都可能发生问题。</p>
<p>问题：线程 1 访问了全局变量 n 后对其进行了修改，但是在线程 1 将修改完的值写入变量 n 之前，CPU 切换到了线程 2，线程 2 就会读到修改前的全局变量 n，发生错误。</p>
<p>解决问题的方式：线程同步。即线程 1 访问全局变量 n 时应该阻止其他线程访问。</p>
<p>临界区位置</p>
<p>临界区：函数中同时运行多个线程时会引起问题的代码块。</p>
<p>临界区通常位于由线程运行的函数内部。</p>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于TCP的服务器端和客户端-1</title>
    <url>/2024/06/13/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="套接字可选项和I-O缓冲大小"><a href="#套接字可选项和I-O缓冲大小" class="headerlink" title="套接字可选项和I&#x2F;O缓冲大小"></a>套接字可选项和I&#x2F;O缓冲大小</h1><h2 id="套接字的多种可选项"><a href="#套接字的多种可选项" class="headerlink" title="套接字的多种可选项"></a>套接字的多种可选项</h2><p>套接字可选项分为 IPPROTO_IP、IPPROTO_TCP、SOL_SOCKET 三层，各层的含义为：</p>
<ol>
<li>IPPROTO_IP：IP协议相关事项</li>
<li>IPPROTO_TCP：TCP协议相关事项</li>
<li>SOL_SOCKET：套接字相关的通用事项</li>
</ol>
<p>下面为部分可选项：<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251012/yrgU/897X362/socket_select_1.png" alt="897X362&#x2F;socket_select_1.png"><br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251012/2M8H/904X132/socket_select_2.png" alt="904X132&#x2F;socket_select_2.png"></p>
<h2 id="getsockopt-setsockopt"><a href="#getsockopt-setsockopt" class="headerlink" title="getsockopt&amp;setsockopt"></a>getsockopt&amp;setsockopt</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span>* optval, <span class="type">socklen_t</span>* optlen)</span></span>; </span><br><span class="line">	<span class="comment">// 功能：读取套接字可选项 </span></span><br><span class="line">	<span class="comment">// 参数：sock：套接字文件描述符；level：可选项所属协议层；optname：要查看的可选项名称； </span></span><br><span class="line">	<span class="comment">// optval：用于保存查看结果的缓冲地址；optlen：调用函数后，optlen 会保存通过第四个参数返回的值的类型大小 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回 0，失败时返回 -1。 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span>* optval, <span class="type">socklen_t</span> optlen)</span></span>; </span><br><span class="line">	<span class="comment">// 功能：更改套接字可选项 </span></span><br><span class="line">	<span class="comment">// 参数：sock：套接字文件描述符；level：可选项所属协议层；optname：要更改的可选项名称； </span></span><br><span class="line">	<span class="comment">// optval：保存要更改的选项信息的缓冲地址；optlen：指明参数 optval 所指对象的大小 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回 0，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>
<p>有的可选项是只读的，不能修改。</p>
<p>注意两个函数中第四个参数 optlen 的类型是不一样的，一个是指针，一个是整型。</p>
<p>理解参数 optlen 的含义：如果 optval 指向的对象是 int 类型，那么 optlen 就等于 4。</p>
<h2 id="SO-SNDBUF-SO-RCVBUF"><a href="#SO-SNDBUF-SO-RCVBUF" class="headerlink" title="SO_SNDBUF&amp;SO_RCVBUF"></a>SO_SNDBUF&amp;SO_RCVBUF</h2><p>SO_SNDBUF 可选项表示输出缓冲大小相关信息，SO_RCVBUF 可选项表示输入缓冲大小相关信息。</p>
<p>这两个选项都是可读可写的。默认的输入输出缓冲大小可能在几万字节左右。</p>
<p>可以修改缓冲区大小，但是系统并不一定会完全按照我们的要求进行修改，修改结果可能会有所出入。</p>
<h1 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h1><h2 id="time-wait状态"><a href="#time-wait状态" class="headerlink" title="time_wait状态"></a>time_wait状态</h2><p>主动结束连接的一方会经历time_wait状态</p>
<h2 id="地址分配错误（bind-error）"><a href="#地址分配错误（bind-error）" class="headerlink" title="地址分配错误（bind() error）"></a>地址分配错误（bind() error）</h2><p>当使用 Ctrl+C 终止服务器程序时，服务器程序成为主动终止连接的一方，会经历 time-wait 状态。这时服务器之前所用的套接字是无法立即使用的（如果立即执行会发生 bind() error），只能等几分钟再执行或修改端口号（即修改套接字）。</p>
<p>客户端的 time-wait 状态无需关心，因为它的端口号是动态分配的。</p>
<h2 id="SO-REUSEADDR-1"><a href="#SO-REUSEADDR-1" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h2><p>有时需要立即重启服务器程序，这可以通过更改可选项 SO_REUSEADDR 的状态来实现。</p>
<p>SO_REUSEADDR 的默认值为 0，将其修改为 1 即可将 time-wait 状态下的套接字端口号重新分配给新的套接字。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> option = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">setsockopt</span>(serv_sock, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;option, <span class="built_in">sizeof</span>(option));</span><br></pre></td></tr></table></figure>
<h1 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h1><h2 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h2><p>Nagle 算法是应用于 TCP 层的一个简单算法：只有收到前一数据的 ACK 消息时，Nagle 算法才会发送下一数据。</p>
<p>TCP 默认使用 Nagle 算法，因此会最大限度地进行缓冲，直到收到 ACK 才将数据发送出去。</p>
<p>使用与否的差异如下：<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251012/cfrm/635X411/nagle_eaxmple.png" alt="635X411&#x2F;nagle_eaxmple.png"></p>
<ul>
<li>优点：可以避免产生大量网络流量。如果不使用 Nagle 算法，数据到达输出缓冲后立即发送出去，会产生多个体积很小的包（如上图所示），增加网络负载。</li>
<li>缺点：很多时候会降低传输速度。不使用 Nagle 算法时，数据无需等待 ACK 报文就可以发送出去，没有等待时间。在发送大文件数据时尤其明显。因为传输大文件数据无论是否使用 Nagle 算法都不会产生大量的小数据包，而不使用 Nagle 算法则不用等待 ACK 报文，速度更快。</li>
</ul>
<h2 id="如何禁用"><a href="#如何禁用" class="headerlink" title="如何禁用"></a>如何禁用</h2><p>可选项 TCP_NODELAY 默认为 0，表示开启 Nagle 算法，将其修改为 1 即可禁用 Nagle 算法。</p>
<p>禁用 Nagle 算法的方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt_val = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">setsockopt</span>(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="type">void</span>*)&amp;opt_val, <span class="built_in">sizeof</span>(opt_val));</span><br></pre></td></tr></table></figure>
<h1 id="基于windows实现"><a href="#基于windows实现" class="headerlink" title="基于windows实现"></a>基于windows实现</h1><p>套接字可选项及其相关内容与操作系统无关,特别是本章的可选项,它们是TCP套接字的相关内容,因此在Windows平台与Linux平台下并无区别</p>
<p>getsockopt中optval类型变成char指针。仅此唯一区别</p>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程服务器端</title>
    <url>/2024/07/05/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="进程概念及应用"><a href="#进程概念及应用" class="headerlink" title="进程概念及应用"></a>进程概念及应用</h1><p>并发的目的：网络程序中数据通信时间比 CPU 运算时间占比更大，通过并发编程可以更高效地利用 CPU；要同时为所有客户提供服务，以提高平均满意度。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ol>
<li>多进程服务器：创建多个进程以提供服务（不适用于 Windows，Windows 不支持）。</li>
<li>I&#x2F;O 多路复用服务器：通过捆绑并统一管理 I&#x2F;O 对象以提供服务</li>
<li>多线程服务器：生成与客户端等量的线程以提供服务。</li>
</ol>
<h1 id="进程和僵尸进程"><a href="#进程和僵尸进程" class="headerlink" title="进程和僵尸进程"></a>进程和僵尸进程</h1><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p>
<h2 id="销毁方法1：利用wait函数"><a href="#销毁方法1：利用wait函数" class="headerlink" title="销毁方法1：利用wait函数"></a>销毁方法1：利用wait函数</h2><p>为了销毁子进程，父进程应该主动请求获取子进程的返回值。</p>
<p>wait 函数会使程序阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* statloc)</span>; </span><br><span class="line">	<span class="comment">// 功能：等待子进程终止并回收终止的子进程。如果没有子进程终止会阻塞，一直等到有终止的子进程为止。 </span></span><br><span class="line">	<span class="comment">// 参数：statloc 用来接收子进程终止时传递的返回值 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回终止的子进程 ID，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>statloc 参数不便直接访问，可以通过下列宏来获取 statloc 中的状态信息：</p>
<ol>
<li>WIFEXITED：子进程正常终止时返回 true。</li>
<li>WEXITSTATUTS：返回子进程的返回值。</li>
</ol>
<p>因此在调用 wait 函数后应接着编写如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait(&amp;status); </span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status)) <span class="comment">// 如果子进程正常终止 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Normal termination!&quot;</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Child pass num: %d\n&quot;</span>, WEXITSTATUS(status)); <span class="comment">// 打印子进程的返回值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁方法2：使用waitpid函数"><a href="#销毁方法2：使用waitpid函数" class="headerlink" title="销毁方法2：使用waitpid函数"></a>销毁方法2：使用waitpid函数</h2><p>waitpid 函数可以通过选项设置选择是否阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* statloc, <span class="type">int</span> options)</span>; </span><br><span class="line">	<span class="comment">// 功能：等待指定的子进程终止并回收终止的子进程。 </span></span><br><span class="line">	<span class="comment">// 参数：pid：等待终止的目标子进程的 ID，如果 pid 为 -1，则和 wait 函数相同，可以等待任意子进程终止； </span></span><br><span class="line">	<span class="comment">// statloc 用来接收子进程终止时传递的返回值；options：如果传递常量 WNOHANG，则不会阻塞，如果没有终止的子进程会返回 0。 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回终止的子进程 ID 或 0，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<h1 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h1><h2 id="信号与signal函数"><a href="#信号与signal函数" class="headerlink" title="信号与signal函数"></a>信号与signal函数</h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signo, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line">	<span class="comment">// 功能：指定函数 func 为信号 signo 的信号处理程序。 </span></span><br><span class="line">	<span class="comment">// 参数：signo 为信号值；func 为函数声明形如 void func(int) 的函数指针。 </span></span><br><span class="line">	<span class="comment">// 返回值：返回一个函数指针，函数指针指向的函数类型形如 void func(int);</span></span><br></pre></td></tr></table></figure>
<p>信号处理程序应该只有一个参数且参数类型为 int，返回值类型是 void。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span>; </span><br><span class="line">signal(SIGALRM, timeout); <span class="comment">// signal 的调用实例，timeout 是函数的名字。</span></span><br></pre></td></tr></table></figure>

<p>常用信号：</p>
<ol>
<li>SIGALRM：到了 alarm 函数设定的时间点会发送此信号。</li>
<li>SIGINT：输入 CTRL+C。</li>
<li>SIGCHLD：子进程终止。</li>
</ol>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span>; </span><br><span class="line">	<span class="comment">// 功能：指定信号的信号处理程序。 </span></span><br><span class="line">	<span class="comment">// 参数：signo：信号值；act：存储函数指针的结构体变量指针；oldact：sigaction() 会将之前注册的信号处理函数的信息放到此参数中，如果不需要可以传递 null。 </span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回 0，失败时返回 -1。</span></span><br></pre></td></tr></table></figure>

<p>sigaction结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span> </span><br><span class="line">	<span class="type">void</span> (*sa_handler)(<span class="type">int</span>); <span class="comment">// 保存信号处理函数的指针。 </span></span><br><span class="line">	<span class="type">sigset_t</span> sa_mask; <span class="comment">// 用于指定信号相关的选项和特性，设为 0 即可。 </span></span><br><span class="line">	<span class="type">int</span> sa_flags; <span class="comment">// 指定信号相关的选项和特性，设为 0 即可。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sigaction函数的使用案例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span>;        <span class="comment">// 声明信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span>         <span class="comment">// 定义并初始化 sigaction 结构体</span></span><br><span class="line">act.sa_handler = timeout;     <span class="comment">// 设置信号处理函数</span></span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">sigaction(SIGALRM, &amp;act, <span class="number">0</span>);  <span class="comment">// 将信号与信号处理函数绑定。</span></span><br></pre></td></tr></table></figure>
<h2 id="利用信号处理技术消灭僵尸进程"><a href="#利用信号处理技术消灭僵尸进程" class="headerlink" title="利用信号处理技术消灭僵尸进程"></a>利用信号处理技术消灭僵尸进程</h2><p>进程终止时将产生SIGCHLD信号。</p>
<p>因此编写一个信号处理函数，然后设置等待的信号为SIGCHLD即可</p>
<h1 id="基于多任务的并发服务器"><a href="#基于多任务的并发服务器" class="headerlink" title="基于多任务的并发服务器"></a>基于多任务的并发服务器</h1><h2 id="基于进程的并发服务器模型"><a href="#基于进程的并发服务器模型" class="headerlink" title="基于进程的并发服务器模型"></a>基于进程的并发服务器模型</h2><p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251012/KV58/539X334/concurrent_server_model.png" alt="539X334&#x2F;concurrent_server_model.png"></p>
<h2 id="响应过程"><a href="#响应过程" class="headerlink" title="响应过程"></a>响应过程</h2><ol>
<li>回声服务器端(父进程)通过调用accept函数受理连接请求。 </li>
<li>此时获取的套接字文件描述符创建并传递给子进程。 </li>
<li>子进程利用传递来的文件描述符提供服务。</li>
</ol>
<h2 id="fork后的情况"><a href="#fork后的情况" class="headerlink" title="fork后的情况"></a>fork后的情况</h2><p>在执行fork后，父进程将2个套接字(一个 是服务器端套接字,另一个是与客户端连接的套接字)文件描述符复制给子进程。 </p>
<p>调用fork函数时复制父进程的所有资源,因此有些人可能认为也会同时复制套接字。</p>
<p>但套接字并非进程所有——从严格意义上说,套接字属于操作系统——只是进程拥有代表相应套接字的文件描述符。</p>
<p>即使不这样理解,仅因为如下原因, 复制套接字也并不合理。 “复制套接字后,同一端口将对应多个套接字。” </p>
<p>因此调用fork函数后,只是父子进程2个文件描述符指向同一套接字。</p>
<p>因此只有两个文件描述符都终止后才能销毁套接字。所以最好在调用fork后，先将无关的套接字文件描述符关掉（比如父进程的）</p>
<h1 id="分割TCP的I-O程序"><a href="#分割TCP的I-O程序" class="headerlink" title="分割TCP的I&#x2F;O程序"></a>分割TCP的I&#x2F;O程序</h1><p>可以通过多进程分割数据的收发过程，使得不同进程分别负责输入和输出。如父进程负责接收数据，子进程负责发送数据。</p>
<p>分割 I&#x2F;O 的优点有提高数据传输率、使程序更简单等。</p>
<h2 id="回声客户端的I-O程序分割"><a href="#回声客户端的I-O程序分割" class="headerlink" title="回声客户端的I&#x2F;O程序分割"></a>回声客户端的I&#x2F;O程序分割</h2><p>程序实例见 echo_mpclient.c。</p>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><h2 id="echo-mpserver-c"><a href="#echo-mpserver-c" class="headerlink" title="echo_mpserver.c"></a>echo_mpserver.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span>; <span class="comment">// SIGCHLD 的信号处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span> <span class="comment">// 结构体 sigaction 用于存储信号处理函数</span></span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="type">int</span> str_len, state;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = read_childproc; <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    state = sigaction(SIGCHLD, &amp;act, <span class="number">0</span>); <span class="comment">// 绑定信号 SIGCHLD 与信号处理函数</span></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">        clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;new client connected...&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(clnt_sock);<span class="comment">// 无法创建子进程，则关闭套接字</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            close(serv_sock);</span><br><span class="line">            <span class="keyword">while</span> ((str_len = read(clnt_sock, buf, BUF_SIZE)) != <span class="number">0</span>) <span class="comment">// 子进程会一直提供回声服务，直到收到 EOF，即客户端调用了 close()。</span></span><br><span class="line">                write(clnt_sock, buf, str_len);</span><br><span class="line"></span><br><span class="line">            close(clnt_sock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close(clnt_sock); <span class="comment">// 父进程关闭与客户端连接的套接字</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG); <span class="comment">// 此函数一次最多回收一个子进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;removed proc id: %d \n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo-mpclient-c"><a href="#echo-mpclient-c" class="headerlink" title="echo_mpclient.c"></a>echo_mpclient.c</h2><p>这是分割了 I&#x2F;O 的回声客户端实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        write_routine(sock, buf);   <span class="comment">// 子进程发送数据</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        read_routine(sock, buf);    <span class="comment">// 父进程接收数据</span></span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> str_len = read(sock, buf, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">0</span>)       <span class="comment">// 循环读取直到读到文件结束符</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        buf[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            shutdown(sock, SHUT_WR);    <span class="comment">// 优雅地关闭套接字：只关闭输出流。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(sock, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字类型与协议设置</title>
    <url>/2024/06/04/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="套接字协议及其数据传输特性"><a href="#套接字协议及其数据传输特性" class="headerlink" title="套接字协议及其数据传输特性"></a>套接字协议及其数据传输特性</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>; </span><br><span class="line"><span class="comment">// domain：采取的协议族，一般为 PF_INET；type：数据传输方式，一般为 SOCK_STREAM；protocol：使用的协议，一般设为 0 即可。 </span></span><br><span class="line"><span class="comment">//成功时返回文件描述符，失败时返回 -1</span></span><br></pre></td></tr></table></figure>

<p>创建套接字的函数 socket 的三个参数的含义：</p>
<ol>
<li>domain：使用的协议族。一般只会用到 PF_INET，即 IPv4 协议族。</li>
<li>type：套接字类型，即套接字的数据传输方式。主要是两种：SOCK_STREAM（即 TCP）和 SOCK_（即 UDP）。</li>
<li>protocol：选择的协议。一般情况前两个参数确定后，protocol 也就确定了，所以设为 0 即可。</li>
</ol>
<p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/G6aT/899X237/protocol_Family.png" alt="899X237&#x2F;protocol_Family.png"></p>
<h2 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h2><p>同一个协议族可能有多种数据传输方式，因此在指定了 socket 的第一个参数后，还要指定第二个参数 type。</p>
<p>SOCK_STREAM 代表的是 TCP 协议，会创建面向连接的套接字</p>
<p>SOCK_DGRAM 代表的是 UDP 协议，会创建面向消息的套接字</p>
<h2 id="协议的最终选择"><a href="#协议的最终选择" class="headerlink" title="协议的最终选择"></a>协议的最终选择</h2><p>因为有这种情况：同一协议族中存在多个数据传输方式相同的协议，所以还需要第三个参数 protocol 来指定具体协议。</p>
<p>但是 PF_INET（IPv4 协议族）下的 SOCK_STREAM 传输方式只对应 IPPROTO_TCP 一种协议，SOCK_DGRAM 传输方式也只对应 IPPROTO_UDP 一种协议，所以参数 protocol 只要设为 0 即可。</p>
<h1 id="WIN平台下的实现和验证"><a href="#WIN平台下的实现和验证" class="headerlink" title="WIN平台下的实现和验证"></a>WIN平台下的实现和验证</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span> </span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>; </span><br><span class="line"><span class="comment">//参数种类与含义同 Linux 的 socket 函数完全相同 </span></span><br><span class="line"><span class="comment">//成功时返回 socket 句柄，失败时返回 INVALID_SOCKET。</span></span><br></pre></td></tr></table></figure>

<p>返回值类型 SOCKET 实际上就是 int 类型，而 INVALID_SOCKET 的实际值为 -1。故 winsock 中的 socket 函数的返回值类型与含义实际上和 Linux 中的 socket 函数也是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET sock = <span class="built_in">sock</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">if</span>( sock == INVALID_SOCKET ) <span class="built_in">ErrorHandling</span>(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="本章程序"><a href="#本章程序" class="headerlink" title="本章程序"></a>本章程序</h1><h2 id="tcp-server-c"><a href="#tcp-server-c" class="headerlink" title="tcp_server.c"></a>tcp_server.c</h2><p>与 ch1 中的 hello_server.c 完全相同。</p>
<h2 id="tcp-cilent-c"><a href="#tcp-cilent-c" class="headerlink" title="tcp_cilent.c"></a>tcp_cilent.c</h2><p>基于 ch1 中的 hello_client.c 修改而来，在前者基础上修改了 read 函数的调用方式：每次只读取一个字节，通过多次读取完成对接收到的数据的读取，验证面向连接的套接字没有数据边界这一特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family=AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, read_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read_len = <span class="built_in">read</span>(sock, &amp;message[idx++], <span class="number">1</span>)) <span class="comment">//只有当 read 函数读到了 EOF (即服务器端调用了 close 函数) 才会中止循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(read_len == <span class="number">-1</span>) <span class="built_in">ErrorHandling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">        str_len += read_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function read call count: %d \n&quot;</span>, str_len);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tcp-server-win-c"><a href="#tcp-server-win-c" class="headerlink" title="tcp_server_win.c"></a>tcp_server_win.c</h2><p>与 ch1 中的 hello_server_win.c 完全相同。</p>
<h2 id="tcp-client-win-c"><a href="#tcp-client-win-c" class="headerlink" title="tcp_client_win.c"></a>tcp_client_win.c</h2><p>和 tcp_client.c 类似，基于 ch1 中的 hello_client_win.c 修改而来，在前者基础上修改了 recv 函数的调用方式：每次只读取一个字节，通过多次读取完成对接收到的数据的读取，验证面向连接的套接字没有数据边界这一特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET sock;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line">    <span class="keyword">if</span>(sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family=AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==SOCKET_ERROR)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, read_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read_len = <span class="built_in">recv</span>(sock, &amp;message[idx++], <span class="number">1</span>, <span class="number">0</span>)) <span class="comment">//只有当 recv 函数读到了 EOF (即服务器端调用了 closesocket 函数) 才会中止循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(read_len == <span class="number">-1</span>) <span class="built_in">ErrorHandling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">        str_len += read_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function recv call count: %d \n&quot;</span>, str_len);</span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈协程</title>
    <url>/2024/06/30/%E6%B5%85%E8%B0%88%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>探讨协程的底层实现，剖析开源库 libco 的实现，并在此基础之上实现一个简单的协程</p>
<span id="more"></span>
<h1 id="浅谈协程"><a href="#浅谈协程" class="headerlink" title="浅谈协程"></a>浅谈协程</h1><h2 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h2><p>协程就是用户态的线程，但是上下文切换的时机是靠调用方（写代码的开发人员）自身去控制的。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  <span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单线程中，上述函数的输出为：<code>1 2 3 x y z</code></p>
<p>如果我们用 libco 库将上面程序改造一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   co_yield_ct();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   co_yield_ct();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...  <span class="comment">// 主协程</span></span><br><span class="line">  co_resume(A);  <span class="comment">// 启动协程 A</span></span><br><span class="line">  co_resume(B);  <span class="comment">// 启动协程 B</span></span><br><span class="line">  co_resume(A);  <span class="comment">// 从协程 A 切出处继续执行</span></span><br><span class="line">  co_resume(B);  <span class="comment">// 从协程 B 切出处继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在单线程中，改造后的程序输出如下：<code>1 2 x 3 y z</code></p>
<p>xxxxxxxxxx23 1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3​4vector<string> vec(25);5​6bool cmp(const string &amp;a, const string &amp;b){7    return a+b &gt; b+a;8}9​10int main(){11    int n;12    cin &gt;&gt; n;13    for(int i &#x3D; 0; i &lt; n; i++){14        cin &gt;&gt; vec[i];15    }16    sort(vec.begin(), vec.begin() + n, cmp);17    string ans;18    for(int i &#x3D; 0; i &lt; n; i++){19        ans +&#x3D; vec[i];20    }21    cout &lt;&lt; ans &lt;&lt; endl;22    return 0;23}cpp</string></p>
<p>函数 A() 和 B() 并不是一个执行完才执行另一个，而是产生了 “交叉执行“ 的效果，这就是通过协程实现的</p>
<h2 id="为什么不用线程而用协程"><a href="#为什么不用线程而用协程" class="headerlink" title="为什么不用线程而用协程"></a>为什么不用线程而用协程</h2><p>有些时候我们在执行一些操作（尤其是IO操作）时，不希望去做“创建一个新的线程”这种重量级的操作来异步处理。而是希望：<strong>在当前线程执行中，暂时切换到其他任务中执行，同时在IO真正准备好了之后，再切换回来继续执行！</strong></p>
<p>相比于多开一个线程来操作，使用协程的好处：</p>
<ul>
<li><strong>减少了线程的重复高频创建；</strong></li>
<li><strong>尽量避免线程的阻塞；</strong></li>
<li><strong>提升代码的可维护与可理解性（毕竟不需要考虑多线程那一套东西了）</strong></li>
</ul>
<p>下面是一些协程的特点：</p>
<ul>
<li><strong>协程可以主动让出 CPU 时间片；（注意：不是当前线程让出 CPU 时间片，而是线程内的某个协程让出时间片供同线程内其他协程运行；）</strong></li>
<li><strong>协程可以恢复 CPU 上下文；当另一个协程继续执行时，其需要恢复 CPU 上下文环境；</strong></li>
<li><strong>协程有个管理者，管理者可以选择一个协程来运行，其他协程要么阻塞，要么ready，或者died；</strong></li>
<li><strong>运行中的协程将占有当前线程的所有计算资源；</strong></li>
<li><strong>协程天生有栈属性，而且是 lock free；</strong></li>
</ul>
<h1 id="协程的类别"><a href="#协程的类别" class="headerlink" title="协程的类别"></a>协程的类别</h1><p>根据是否存在<strong>调用栈</strong>，可以分为以下两类</p>
<ul>
<li>有栈协程：类似于内核态线程，不同协程间切换还是要切换上下文，只是不需要陷入内核。例如goroutine、libco</li>
<li>无栈协程：上下文放在公共内存中，切换时使用状态机来切换，而不切换对应的上下文（因为已经在堆里了），更轻量，例如：C++20、Rust、JavaScript 中的协程</li>
</ul>
<p>根据是否存在明显的调用关系，可以分为</p>
<ul>
<li>非对称协程：协程间有明显的调用关系</li>
<li>对称协程：无明显调用关系</li>
</ul>
<h2 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h2><p>开源库 libco 就是通过汇编语言实现的有栈协程库。</p>
<p>通过分析代码可以看到，无论是<code>co_yield</code>还是<code>co_resume</code>，在协程切出和恢复时，都调用了同一个函数<code>co_swap</code>，在这个函数中调用了 <code>coctx_swap</code> 来实现协程的切换，这一函数的原型是<br><code>void coctx_swap( coctx_t *,coctx_t* ) asm(&quot;coctx_swap&quot;);</code></p>
<p>两个参数都是 <code>coctx_t *</code> 指针类型，其中第一个参数表示要切出的协程，第二个参数表示切出后要进入的协程；</p>
<p>并不会像常规被调用函数一样创立新栈帧。而是通过调整 <code>%rsp</code> 的值来恢复新协程的栈，并利用了 <code>ret</code> 语句来实现修改指令寄存器 <code>%rip</code> 的目的，通过修改 <code>%rip</code> 来实现程序运行逻辑跳转；</p>
<blockquote>
<p>[!NOTE] %rip的修改<br>不能直接修改，只能通过call或ret来修改</p>
</blockquote>
<p><strong>整体上看来，协程的切换其实就是： cpu 寄存器内容特别是 <code>%rip</code> 和 <code>%rsp</code> 的写入和恢复，因为 cpu 的寄存器决定了程序从哪里执行（%rip) 和使用哪个地址作为堆栈 （%rsp）；</strong></p>
<h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>无栈协程本质上是一个状态机，从另一个角度上：<strong>同一协程切换的本质不过是指令指针寄存器的改变</strong></p>
<p>先来看一个使用libco的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">test</span><span class="params">(<span class="type">void</span>* para)</span></span>&#123; </span><br><span class="line">	<span class="built_in">co_enable_hook_sys</span>(); </span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">poll</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.</span> <span class="number">1000</span>); <span class="comment">// 协程切换执行权，1000ms后返回 </span></span><br><span class="line">	i++; </span><br><span class="line">	<span class="built_in">poll</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.</span> <span class="number">1000</span>); <span class="comment">// 协程切换执行权，1000ms后返回 </span></span><br><span class="line">	i--; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	stCoRoutine_t* routine; </span><br><span class="line">	<span class="built_in">co_create</span>(&amp;routine, <span class="literal">NULL</span>, test, <span class="number">0</span>); <span class="comment">// 创建一个协程 </span></span><br><span class="line">	<span class="built_in">co_resume</span>(routine); </span><br><span class="line">	<span class="built_in">co_eventloop</span>(<span class="built_in">co_get_epoll_ct</span>(),<span class="number">0</span>,<span class="number">0</span> ); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是无栈协程，实现相同逻辑的代码是怎么样的呢？</p>
<p>其实就是翻译成类似于以下状态机的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_coroutine</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="type">int</span> __state = <span class="number">0</span>; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MoveNext</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">switch</span>(__state) &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">frist</span>(); </span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">second</span>(); </span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">third</span>(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">frist</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i = <span class="number">0</span>; __state = <span class="number">1</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i++; _state = <span class="number">2</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i--; </span><br><span class="line">	&#125; </span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p><strong>把整个协程抽象成一个类，以原本需要执行切换的语句处为界限，把函数划分为几个部分，并在某一个部分执行完以后进行状态转移，在下一次调用此函数的时候就会执行下一部分</strong></p>
<p>这样就完全没有必要像有栈协程那样显式的执行上下文切换了，我们只需要一个简易的调度器来调度这些函数即可；</p>
<p>从执行时栈的角度来看：</p>
<p><strong>其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值；</strong></p>
<p><strong>而且相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别，这样也可以凸显出无栈协程的高效；</strong></p>
<h2 id="对称协程与非对称协程"><a href="#对称协程与非对称协程" class="headerlink" title="对称协程与非对称协程"></a>对称协程与非对称协程</h2><ul>
<li><strong>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移；</strong></li>
<li><strong>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系；</strong></li>
</ul>
<p>非对称协程就是拥有调用栈，而对称协程则是大家都平等，不需要调用栈，只需要一个数据结构存储未执行完的协程即可</p>
<p>我个人认为非对称协程相比之下更为符合认知，因为对称协程目前我不知道如何选择一个合适的协程来获得CPU执行权，正如上面所说，此协程可能正在等待事件；当然如果调度算法足够优秀的话，对称协程也是可取的；</p>
<h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="N-1-N-M-协程"><a href="#N-1-N-M-协程" class="headerlink" title="N:1 &amp; N:M 协程"></a>N:1 &amp; N:M 协程</h2><p>线程绑定的协程只有在对应线程运行的时候才有被执行的可能，如果对应线程中的某一个协程完全占有了当前线程，那么当前线程中的其他所有协程都不会被执行</p>
<p>协程的所有信息都保存在上下文（Contex）对象中，将不同上下文分发给不同的线程就可以实现协程的跨线程执行，如此，协程被阻塞的概率将减小；</p>
<p>借用 <a href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/bthread.md">BRPC</a> 中对 <code>N:M</code> 协程的介绍，来解释下什么是 <code>N:M</code> 协程：</p>
<p>常说的协程是指的N:1协程库，即所有协程运行在一个系统线程中，<strong>计算能力和各类eventloop库等价</strong></p>
<p>由于不跨线程，那么切换也不需要系统调用，受cache一致性的影响也比较小，可以非常快</p>
<p>但是代价是无法高效利用多核，而且代码必须非阻塞，否则所有协程都会卡住</p>
<p><code>bthread</code> 是一个 <code>M:N</code> 线程库，一个<code>bthread</code>被卡住不会影响其他<code>bthread</code>；</p>
<p>其中的关键技术有两点：</p>
<ul>
<li><strong>work stealing 调度；</strong></li>
<li><strong>butex；</strong></li>
</ul>
<p>前者让 bthread 更快地被调度到更多的核心上，后者让 bthread 和 pthread 可以相互等待和唤醒，这两点协程都不需要；</p>
<p>这么看来 貌似 bthread 自己实现了 golang 的 goroutine？</p>
<p>表面看起来的却如此：两者都实现了 M:N 用户态线程；</p>
<p>但是事实上， golang 中的 goroutine 的实现要更为复杂一些：</p>
<p>bthread 的设计比较接近 go 1.0 版本：OS 线程不会动态增加，在有大量的阻塞性 syscall 下，会有影响；</p>
<p>而 go 1.1 之后的设计就是动态增减 OS 线程，而且提供了 LockOSThread，可以让 goroutine 和 OS 线程 1:1；</p>
<h2 id="协程的组成"><a href="#协程的组成" class="headerlink" title="协程的组成"></a>协程的组成</h2><p>N:M模式下的协程其实就是可以由用户来确定调度顺序的用户态线程，对比系统线程可以分为以下几个模块：</p>
<ul>
<li>协程上下文：对应系统中的PCB&#x2F;TCB</li>
<li>保存协程上下文的容器：对应操作系统中保存 PCB&#x2F;TCB 的容器，一般是一个列表（在实际实现时，协程上下文容器可以使用一个也可以使用多个，比如：普通协程队列、定时的协程优先队列等</li>
<li>协程的执行器<ul>
<li>协程的调度器：对应操作系统中的进程、线程调度器</li>
<li>执行协程的worker线程，对应实际进程&#x2F;线程的CPU核心</li>
</ul>
</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>参照进程调度即可</p>
<h2 id="协程相关工具"><a href="#协程相关工具" class="headerlink" title="协程相关工具"></a>协程相关工具</h2><p>系统级线程有锁、条件变量等工具，</p>
<p><strong>系统级线程和协程处于不同的系统层级，所以两者的同步工具不完全通用，如果在协程中使用了线程的锁（例如：<code>std::mutex</code>），则整个线程将会被阻塞，当前线程将不会再调度与执行其他协程；</strong></p>
<h2 id="对CPU-IO的影响"><a href="#对CPU-IO的影响" class="headerlink" title="对CPU&#x2F;IO的影响"></a>对CPU&#x2F;IO的影响</h2><p>目的在于剔除线程的阻塞，提供CPU利用率</p>
<p>很多服务在处理业务时需要请求第三方服务，向第三方服务发起 RPC 调用；RPC 调用的网络耗时一般耗时在毫秒级别，RPC 服务的处理耗时也可能在毫秒级别，如果当前服务使用同步调用，即 RPC 返回后才进行后续逻辑，那么一条线程每秒处理的业务数量是可以估算的；</p>
<p>假设每次业务处理花费在 RPC 调用上的耗时是 20ms，那么一条线程一秒最多处理 50 次请求！</p>
<p>如果在等待 RPC 返回时当前线程没有被系统调度转换为 Ready 状态，那当前 CPU 核心就会空转，浪费了 CPU 资源！通过增加线程数量提高系统吞吐量的效果非常有限，而且创建大量线程也会造成其他问题！</p>
<p>协程虽然不一定能减少一次业务请求的耗时，但一定可以提升系统的吞吐量：</p>
<ul>
<li>当前业务只有一次第三方 RPC 的调用，那么协程不会减少业务处理的耗时，但可以提升 QPS；</li>
<li>当前业务需要多个第三方 RPC 调用，<strong>同时创建多个协程可以让多个 RPC 调用一起执行，则当前业务的 RPC 耗时由耗时最长的 RPC 调用决定；</strong></li>
</ul>
]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>Map和Reduce个人总结</title>
    <url>/2025/08/03/%E5%AF%B9MapReduce%E4%B8%80%E7%82%B9%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>MapReduce 是谷歌 2004 年（Google 内部是从 03 年写出第一个版本）发表的论文里提出的一个概念。虽然已经过去 15 年了，但现在回顾这个大数据时代始祖级别概念的背景、原理和实现，仍能获得对分布式系统的很多直觉性的启发，所谓温故而知新。</p>
<p>本人在学习hadoop和MapReduce以及了解了Spark，并且完成了一个小的项目后，决定写一个总结</p>
<span id="more"></span>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在 Google 的语境里，MapReduce 既是一种编程模型，也是支持该模型的一种分布式系统实现。</p>
<p>它的提出，让没有分布式系统背景的开发者，也能较轻松的利用大规模集群以高吞吐量的方式来处理海量数据。</p>
<p>其解决问题思路很值得借鉴：找到需求的痛点（如海量索引如何维护，更新和排名），对处理关键流程进行高阶抽象（分片 Map，按需 Reduce），以进行高效的系统实现（所谓量体裁衣）。</p>
<p>这其中，如何找到一个合适的计算抽象，是最难的部分，既要对需求有直觉般的了解，又要具有极高的计算机科学素养</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>谷歌当时作为互联网的最大入口，维护着世界全网索引，最早触到了数据量的天花板。即，哪怕针对很简单的业务逻辑：如从爬虫数据中生成倒排索引、将图状网页集合用不同方式组织、计算每个主机爬取的网页数量、给定日期的高频查询词汇等等，在全球互联网数据的尺度的加成下，也变的异常复杂。</p>
<p>这些复杂性包括：输入数据分散在非常多的主机上、计算耗资源太多单机难以完成、输出数据需要跨主机进行重新组织。为此，不得不针对每个需求重复构造专用系统，并耗费大量代码在分发数据和代码、调度和并行任务、应对机器故障和处理通信失败等问题上。</p>
<h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>map 和 reduce 的抽象灵感来自于函数式编程语言 Lisp，为什么选定这两个概念呢？这来源于谷歌人对其业务的高度提炼：</p>
<ol>
<li>输入可以切分成一个个逻辑的记录 （record）</li>
<li>对每个record执行某种<strong>映射</strong> （map）操作，生成一些键值对组成的中间结果（为什么要分键和值呢？为最后一步做铺垫，允许用户将中间结果以任意指定的方式 —— 键，来进行组织规约）</li>
<li>最后在具有相同键的中间结果子集上执行规约（reduce，包括排序，统计，提取最值等等）操作。</li>
</ol>
<p>另一个关键的特点在于对Map操作实现的约束，规定用户应该实现一个无副作用的map 操作。如此限制，好处有二，一是可以进行大规模并行执行，二是可以通过换地儿重试来屏蔽主机故障。</p>
<h2 id="抽象实现"><a href="#抽象实现" class="headerlink" title="抽象实现"></a>抽象实现</h2><p>map和reduce都是用户自定义函数。</p>
<p>map函数接收一个record,不过为了灵活，一般也组织为键值对，然后经过一定的操作后得到List&lt;key，value&gt;。</p>
<p>reduce 函数接受一个 key 和该 key 对应的所有中间结果 List &lt; value &gt;</p>
<p>考虑示例级程序：word_count</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    <span class="comment">// key: document name</span></span><br><span class="line">    <span class="comment">// value: document contents</span></span><br><span class="line">    <span class="keyword">for</span> each word w in value:</span><br><span class="line">      EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    <span class="comment">// key: a word</span></span><br><span class="line">    <span class="comment">// values: a list of counts</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each v in values:</span><br><span class="line">      result += ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有两个比较重要的点：</p>
<ol>
<li>中间变量需要网络传输，必然涉及到序列化。MapReduce 的最初版本选择是一切解释权归<strong>运行时的</strong>用户代码所有，我只是传 string。即，规定用户在 map 中将任何输出的中间结果对象都转换为 string，然后在 reduce 函数中接收该 Iterator &lt; string &gt;后，自行解析为自己想要的格式。当然，在后来的模仿框架如 Hadoop 中，序列化和解序列化部分被拿了出来，可以由用户来自定义实现来满足功能或性能上的需求</li>
<li>reduce接收的value集合被组织成迭代器。它是一个很简单的接口，包括 next 和 stop 两个语义。配合 for loop ，构成一个很强大的抽象。不管你底层是一个内存中的 List、还是文件内容、还是网络 IO 流，只要能在运行时知道如何得到下一条记录，什么时候时候停止，都能被 for 循环来利用，进行逐一处理。迭代器抽象的一个好处在于，不必将待迭代的内容一次加载到内存，可以对数据增量式的<strong>惰性加载</strong>。MapReduce 框架的此处实现也正是利用了该特性。</li>
</ol>
<h1 id="实现一览"><a href="#实现一览" class="headerlink" title="实现一览"></a>实现一览</h1><h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><p>输入由用户指定切分大小后，切分成M份，然后分散到不同机器上 (由于 GFS 的存在，也可能该输入 Block 本来就在那台机器上）。</p>
<p>然后每个机器并行跑用户定义的map，输出的中间结果由用户指定的key值范围切分为R份，</p>
<p>对于每个中间结果，通过 node label &#x3D; hash(key) mod R 决定其去处。<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251013/gJdB/1263X915/Execution_overview.png" alt="1263X915&#x2F;Execution_overview.png"></p>
<ol>
<li>首先将输入切分M份，每份通常16-64M，然后把这些分片分散到不同机器上（如果有 GFS 这种分布式文件系统配合的话，可能本来就分散着）。然后在每个机器上 fork 一份用户的代码<blockquote>
<pre><code>[!NOTE] 由于语言的区别，分发不同
比如谷歌的 C++，可能传输的是动态链接库；比如 Hadoop 的 Java 传的可能是 jar 包 （当然， 所有依赖也得传）；如果是 PySpark 的 Python 呢，可能用的就是神奇的 cloudpickle；总之，不同语言需要考虑的传输机制是不一样的，比如说动态语言和静态语言；此外，全局变量和外部依赖也是需要考虑的点
</code></pre>
</blockquote>
</li>
<li>对于Master节点，它的程序并不是用户的运行代码，而是负责安排这 M 个 map 任务和 R 个 reduce 任务。这需要考虑的是，worker 执行每个用户代码是单独启动一个进程，还是插入到系统 loop 中去执行。</li>
<li>对于执行Mapper任务的Worker，会读取被分配到的输入切片，解析出键值对流，送给用户定义的 map 函数。map 后产生的临时结果首先会缓存在内存中。</li>
<li>缓存的中间结果会被定期在执行 Map Task 的<strong>机器本地</strong>进行刷盘，并且按用户指定的 Partition 函数拆分成 R 个块，然后将这些位置信息发给 Master 节点。Master 负责通知相应的 Reduce Worker 以拉取对应数据。</li>
<li>Reduce Worker 收到这些中间结果的位置信息后，会通过 RPC 来拉取其对应的 Partition 的数据。对于某个 Reduce Worker 来说，待<strong>所有数据</strong>拉取完成后，会将其按照 key 来进行排序<blockquote>
<pre><code>[!NOTE] shuffle
 第4和第5步合起来就是Shuffle，涉及到外部排序、多机数据传输等耗时的操作。当数据量小的时候随便搞，但是大的时候就必须要优化
</code></pre>
</blockquote>
</li>
<li>等到中间数据排好序后，Reduce Woker 会对其进行扫描，然后将一个个 key 和其对应的值集合，即 &lt;k2, list (v2)&gt; 传给用户定制的 reduce 函数，然后将生成的结果追加到最终输出文件。对于谷歌来说，一般来说就是支持并行 append 的文件系统 GFS，好处在于可以多进程同时写结果</li>
<li>当所有 reduce 任务完成后，master 会唤醒用户进程，即在用户代码的视角，MapReduce 任务是阻塞的。</li>
</ol>
<p>一般而言，用户无需将最终结果的R个Partition合并，而是将其直接作为下一个 MapReduce 任务的输入。Spark RDD 的 partition 就是将这一特点<strong>概念化</strong>了，并且将每一步 MapReduce 输出也放内存中，不进行落盘，以降低连续 MapReduce 任务的延迟。</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>在 MapReduce 系统中，我们也会充分利用输入数据的 locality。只不过这次，<em>不是将数据加载过来，而是将程序调度过去</em>（<em><strong>Moving Computation is Cheaper than Moving Data</strong></em>）。</p>
<p>如果输入存在 GFS 上，表现形式将为一系列的逻辑 Block，每个 Block 可能会有几个（一般是三个）物理副本。对于输入每个逻辑 Block，我们可以在其某个物理副本所在机器上运行 Map Task（如果失败，就再换一个副本），由此来尽量减小网络数据传输。从而降低了延迟，节约了带宽。</p>
<h2 id="单点的Master"><a href="#单点的Master" class="headerlink" title="单点的Master"></a>单点的Master</h2><p>在分布式系统中，一个比较忌讳的问题就是单点。因为是牵一发而动全身，而 Master 就是这样一个单点。</p>
<p>当然单个机器的统计平均故障率并不高，但是一旦故障，那么整个集群都将不可用。但同时，有一个 Leader 节点会大大简化分布式系统的的设计；因此采用单点 Master 的系统反而是主流，</p>
<p>那势必需要开发一些其他手段来强化 master 的容错能力，比如说log + snapshot、比如说主从备份、比如说每次从 worker 心跳进行状态重建、比如说用其他实现了分布式一致性协议的系统来保存元信息等等。</p>
<h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Worker 由于数量大，有机器故障概率较大。</p>
<p>在分布式系统中，Master 获取 Workers 的信息，最常见便是<strong>心跳</strong>，既可以是 master ping worker，也可以反过来，也可以兼而有之。master 通过心跳发现某些 worker 不可到达后（可能是 worker 死掉了，也可能是网络出问题了等），就会将该 Worker 打个<strong>故障</strong>（failed）的标记。</p>
<p>之前已经调度到该故障 Worker 上的任务（Task） 很显然有两种类型： Map Task 和 Reduce Task。</p>
<ol>
<li><strong>对于 Map Task</strong>（<em>以下所提的 Task，肯定是从属于未结束的 Job</em>） ，不管成功与否，我们都要进行重试，因为一旦该 Worker 变为不可达，存于其上的中间结果也随之无法被 Reduce Task 获取。当然，我们可以在 Master 中多记点状态来减少对已完成的 Map Task 进行重试的概率。比如记下某个 Map Task 的输出是否已经都被 Reduce Task 拉取，以决定要不要对正常完成的 Map Task 进行重试</li>
<li>对于 <strong>Reduce Task</strong>，未完成的无疑要进行重试，已经完成的，由于其输出结果我们假设会写到全局分布式系统文件中（即某些机器挂了也不影响），就不会重试。</li>
</ol>
<h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>如果在实践中 Master 确实很少死掉，并且偶尔死掉造成所有正在运行的任务失败的后果也可以接受，那么就可以粗暴的实现为如果 Master 死掉，就简单通知所有正在运行的任务的用户代码任务失败了（比如返回非 0 值），然后有用户代码自行决定丢弃任务还是待集群重启后进行重试：</p>
<p>如果不能接受，那以下是增加容错性的办法：</p>
<ol>
<li><strong>snapshot + log</strong>：将 Master 的内存数据结构定期做快照（snapshot）同步到一个持久存储，可以写到外部或者同步到其他节点，可以一份也可以多份，但是时间间隔不好选，间隔太长容易造成恢复时状态丢失过多；间隔过短会加重系统负载。常用的辅助手段是记log，即对每个会改变系统的状态的操作进行记录，这样就可以选择长一点的快照间隔，恢复时，先加载快照，再叠加上快照点之后的日志。</li>
<li>主从备份：比如 Hadoop 原先的 secondary namenode，用属于不同容错阈两台机器都作为 Master，只不过一个用来响应请求，另一个用来实时同步状态。等某台机器故障发生时，立即将流量切换到另一个机器上。至于其同步机制，则是另一个可以考量的点。</li>
<li>状态外存：如果元数据量不大，可以用 Zookeeper 或者 etcd 这种实现了分布式一致性协议的集群来保存。由于这些集群本身具有容错能力，因此可以认为避免了单点故障。</li>
<li><strong>心跳恢复</strong>：重新启动一个 Master 后，利用所有 Worker 报上来的信息进行 Master 数据结构的重建。</li>
</ol>
<p><strong>容错也需要用户侧代码做配合</strong>。因为框架会对不成功的 map&#x2F;reduce 用户代码进行重试。这就要求，用户提供的 map&#x2F;reduce 逻辑符合<strong>确定性</strong>（<strong>Deterministic</strong>）：即函数的输出依赖且仅依赖于输入，而不取决任何其他隐形的输入或者状态。当然，这个蕴含了<strong>幂等性</strong>（<strong>Idempotency</strong>）：多次执行和一次执行效果一样；但是幂等性并不能推出确定性；假设有这么一个函数，它第一次执行造成了一些状态改变（比如某些释放资源的 dispose 函数），而后续发现状态已经改变过了就不再改变该状态，那么它符合幂等性；但是由于其含有隐式状态输入，不是确定性的。</p>
<p>如果 map&#x2F;reudce 函数是确定性的，那么框架就可以放心大胆重试了。某些条件下，幂等性也可以接受，比如保存隐式状态的地方很牢靠。举个栗子，我们依赖于一个文件锁做判断某个函数执行了一次或多次，如果该文件锁所依赖的文件系统很稳定，并且提供分布式一致性，那么就完全可以。如果是用 nfs 的一个文件做锁，来实现的所谓幂等性就值得商榷了</p>
<p>如果 map&#x2F;reduce 函数是确定性的，框架会通过其输出提交的原子性来进行幂等性保证。即，即使重试了多次，也和只执行了一次一样。具体来说，对于 Map Task，会产生 R 个临时文件，并在结束时将其位置发送给 Master；Master 在收到多次同一分片（split） 的位置信息时，如果该分片前面某次结果来源仍可用或者已经被消费，那么就忽略掉该请求后面的所有请求。对于 Reduce Task，其生成的结果也会先写成临时文件，然后依赖于底层文件系统的原子性的改名操作（<strong>原子性改名</strong>也是一个多进程竞争的经典的操作，因为生成文件过程比较长，不容易做成原子的，但是<strong>判断具有某名字的文件是否存在并改名</strong>却很容易做成原子的），在处理完成时改变为目的文件名。如果发现已经有一个具有该目的文件名的文件了，就放弃改名操作，从而保证了该 Reduce Task 只有一个成功输出的最终文件</p>
<h2 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h2><p>一个 MapReduce Job 中会产生 M+R 个 Task，具体 M 和 R 的值在运行之前可以由人进行配置。不同的系统实现可能会有发挥出最佳系统性能的不同配比；但是同时要兼顾业务需求，比如输入大小，输出文件个数等等。</p>
<h2 id="备份任务"><a href="#备份任务" class="headerlink" title="备份任务"></a>备份任务</h2><p>在实际业务中，由于某些主机原因常会出现<strong>长尾效应</strong>，即少数几个 Map&#x2F;Reduce Task 总是会巨慢的拖到最后，甚至拖得时间甚至是其他任务的几倍。</p>
<p>造成这些主机拖后腿的原因可以举出很多， 比如某个机器硬盘老化，读写速度变慢；调度器调度有问题，导致某些机器负载太高；又比如软件 bug 导致某些主机变慢等等</p>
<p>只要确定这些问题只发生在<strong>少数</strong>某些主机上，那么解决方法也很简单。在<strong>任务接近尾声</strong>的时候（比如统计剩余 task 的占比小于一个阈值时），对于每个仍然在跑的任务，分别额外调度一份到其他主机上，那么大概率会让这些任务提前完成，同一任务跑多次的处理逻辑，和容错重试造成跑多次是一致的，可以复用</p>
<h1 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h1><h2 id="Partitioner"><a href="#Partitioner" class="headerlink" title="Partitioner"></a>Partitioner</h2><p>默认来说，对 Map 输出的中间结果进行划分会使用类似于 hash(key) mod R这种应用无关的划分算法。但是有时候用户有需求将特定的一些 keys 路由到同一个 Reduce Task，比如说中间结果的 key 是 URL， 用户想按网站 host 进行汇总处理。这时候就需要将系统的这部分路由功能开放给用户，以满足用户的定制需求。</p>
<h2 id="Combiner"><a href="#Combiner" class="headerlink" title="Combiner"></a>Combiner</h2><p>如果该 Job 针对所有中间结果的 reduce 的操作满足<strong>结合律</strong>，那么指定 Combiner 会很能提高效率。拿的 Word Count 来说，数值的加法无疑满足结合律，也就是说，同一个单词的频次，在 Map Task 输出后进行加和（在 Map Work 上），还是在 Reduce Task 中进行加和（在 Reduce Worker 上），结果保持一致；而这样一来，由于一些中间结果对进行了 combine，Map Task 到 Reduce Task 间的传输数据量会小很多，从而提高整个 Job 的效率。</p>
<p>也可以看出，combine 函数一般和 reduce 函数是一样的，因为他们本质上是对 value set 执行了同一种操作，只不过执行时，执行的地点不一样，结合的顺序不一样。目的是为了减少中间结果传输量，加速任务执行过程。</p>
<h2 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader&#x2F;Writer"></a>Reader&#x2F;Writer</h2><p>如果不将定制输入输出的能力开放给用户，那么系统显然只能处理有限几种默认约定的格式。因此，<em>reader</em> 和 <em>writer</em> 接口本质上是系统和现实繁杂的业务之间的<strong>适配器（Adaptor）</strong>。它们让用户可以自行指定数据的_来源和去处_、<em>按需要理解输入内容_和_自由定制输出格式</em>。</p>
<p>一般来说，系统会内置提供一些常见的 Reader 和 Writer 的实现；包括按行读文本文件，读文件中键值，读数据库等等。然后用户可以实现这两个接口，进行更具体的定制。<em>系统常通过类似这种常用脚手架 + 进一步定制能力来提供 API</em>，下面的 Counter 也是如此。</p>
<h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>有些用户实现的 map&#x2F;reduce 函数会有一些副作用，比如说在执行任务中间输出一些文件、写一些数据库条目等等。一般来说这些副作用的原子性和幂等性需要用户自己来处理。因为如果输出介质不纳入 MapReduce 系统，系统是没有办法保证这些输出的幂等性和原子性的。</p>
<p>不过有的系统就这么干的，提供一些某种类型 &#x2F; 介质的状态或者数据存储，纳入系统中，并且提供一些容错和幂等的性质。好像 MillWheel 有类似的做法。但这样会大大加重系统的复杂性</p>
<h2 id="跳过坏记录"><a href="#跳过坏记录" class="headerlink" title="跳过坏记录"></a>跳过坏记录</h2><p>如果用户代码有 bug 或者某些输入有问题，会导致 Map 或者 Reduce 任务在运行时崩溃。当然这些 bug 或者输入能修则修，但是有些情况由于第三方库或者输入的原因，不能够进行修复。而在某些类型的任务，比如说训练数据集清洗、大型统计任务，丢几个是可以容忍的。针对这种情况，系统会提供一种模式，在这种模式中会跳过这些 Record 记录的执行。</p>
<p>具体实现上来说，也比较简单。可以给每个输入 Record 给个<strong>唯一编号</strong>（单次任务内唯一就行）；如果某个 Record 处理时挂掉了，就将其编号汇报给 Master。如果 Master 收到了某个 Record 超过一次的处理失败信息，就将其跳过。做的再细一点，还可以记下错误类型和信息进行比对，来确定这是否是一个确定性（deterministic）的错误，进而决定是否将其跳过。</p>
<h2 id="单机执行"><a href="#单机执行" class="headerlink" title="单机执行"></a>单机执行</h2><p>众所周知，分布式系统很难跟踪、调试；因为一个 Job 可能同时分散在数千台机器上进行执行。因此系统提供了本地运行 Job 的能力。可以针对小数据集输入对代码的正确性进行测试。由于在单机运行，<strong>就可以比较方便通过调试工具进行断点追踪</strong>。</p>
<h2 id="全局计数器"><a href="#全局计数器" class="headerlink" title="全局计数器"></a>全局计数器</h2><p>系统提供了一种计数服务，以统计某种事件的发生频次。比如用户想统计 Word Count 示例中所处理的全大写单词的总数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase = GetCounter(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line">  <span class="keyword">for</span> each word w in contents:</span><br><span class="line">    <span class="keyword">if</span> (IsCapitalized(w)):</span><br><span class="line">      uppercase-&gt;Increment();</span><br><span class="line">    EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从代码可以大致猜测其实现：定义的时候，需要给 Counter 指定一个 Id。然后在 Map&#x2F;Reudce 代码中可以通过该 Id 获取该 Counter 然后进行计数。每个 worker 机器上的计数信息会汇总到 Master 上，然后按 Counter 的 ID 进行加和，并且最终返回给用户</p>
<p><strong>系统会自动维持一些计数器</strong>，比如说所有已经处理的键值对的数量和所有已经产生的键值对数量。全局计数操作对于某些应用用处很大，比如说有的应用要求所有输入键值对和输出键值对的数量一样，如果没有全局计数，就无从验证；或者统计一些数据的全局比例等等。</p>
<h1 id="重排Shuffle操作"><a href="#重排Shuffle操作" class="headerlink" title="重排Shuffle操作"></a>重排Shuffle操作</h1><p>自 Spark 成名之后，shuffle 这个 MapReduce 中的语义得到了很多研究和实践。这是一个多机传输的耗时操作，其实现的高效性对系统的性能有着至关重要的作用，因此单独拿出一节来聊聊。</p>
<p>在 MapReduce 中就是指 Map Task 分片输出到 Reduce Task 按需拉取的这么一个过程。还拿 Word Count 为例，你想统计某个单词在所有文档中的总频次，但是这些单词分布在不同机器上的不同的 Map Task 输出里；而只有将所有同样单词的频次对聚集到同一台机器上，才能对其加和。<strong>这种将机器和子数据集对应关系按 key 打乱重组的操作，我们姑且称之为 shuffle。</strong></p>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Spark上基本继承了该语义，并且更通用化了。一个常见的例子是 join，即将两个 Table 间具有相同 key 的记录路由到同一台机器上，从而在所有机器上按 key 分片进行并行 join，从而大幅提高效率。类似于 join 这样的高阶操作，会使得底层的 Partition 不能继续在本机运行而不与其他 Partition 发生联系，因此 shuffle 也是 Spark 中划分 Stage 的一个分水岭</p>
<h2 id="MapReducer"><a href="#MapReducer" class="headerlink" title="MapReducer"></a>MapReducer</h2><ol>
<li>Map任务输出数据先放入内存缓冲区，缓冲区大小可用通过参数调整，默认100M，超过或者Map结束就写入磁盘</li>
<li>写入磁盘过程中，调用Partitioner进行分组和针对Key排序，按key的哈希值分配给Reduce节点</li>
<li>合并过程中也会进行排序等操作</li>
<li>Reduce根据自己的分区号，向Map任务机器上领取数据</li>
<li>领取到同一个分区来自不同map任务的结果文件后，采用归并排序进行合并</li>
<li>合并成大文件后，Shuffle阶段结束。开始Reduce的逻辑阶段</li>
</ol>
<p>可以使用Combiner组件</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>缺点：它是一个高吞吐，但是也高延迟的批量处理系统。并且不支持迭代。这也是后续 Spark，Flink 这样系统火热的动机。</li>
<li>文件系统：MapReduce 只有和 GFS 这样支持分块、多进程并发写的大文件系统配合才能发挥出更大的优势，优化输入和输出的性能。此外，这种分布式文件系统还会屏蔽底层节点故障</li>
<li>组织形式： MapReduce 是一个系统，需要部署到集群上，但它同时又是一个库，让用户代码和分布式集群进行交互而不太用关心分布式环境中的问题的一个库。每个任务需要写任务描述，然后提交给系统 —— 这是库常用的一种提交任务的手段。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据，hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>理解网络编程和套接字</title>
    <url>/2024/06/03/%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>对《TCP&#x2F;IP网络编程》第一章的简单总结</p>
<span id="more"></span>
<h1 id="理解网络编程和套接字"><a href="#理解网络编程和套接字" class="headerlink" title="理解网络编程和套接字"></a>理解网络编程和套接字</h1><h2 id="服务端套接字"><a href="#服务端套接字" class="headerlink" title="服务端套接字"></a>服务端套接字</h2><p>套接字编程所用的各函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domin, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">	<span class="comment">//功能：创建套接字</span></span><br><span class="line">	<span class="comment">// 参数：domin:一般为 PF_INET；type:数据传输方式，一般为 SOCK_STREAM；protocol:一般设为 0 即可</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">	<span class="comment">// 功能：为套接字分配地址信息</span></span><br><span class="line">	<span class="comment">// 参数：sockfd:要分配地址信息的套接字文件描述符；myaddr:存有地址信息的结构体变量指针；addrlen：第二个参数的长度</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(itn sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line">	<span class="comment">// 功能：将套接字转换为可接收连接的状态</span></span><br><span class="line">	<span class="comment">// 参数：sockfd:希望进入等待连接请求状态的套接字文件描述符；backlog:连接请求等待队列的长度，最多使 backlog 个连接请求进入队列</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">	<span class="comment">// 功能：受理连接请求等待队列中待处理的连接请求。</span></span><br><span class="line">	<span class="comment">// 参数：sock：服务器套接字的文件描述符；addr：用于保存发起连接请求的客户端地址信息；addrlen：第二个参数的长度</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回创建的套接字文件描述符，失败时返回 -1</span></span><br></pre></td></tr></table></figure>

<p>接受连接请求的服务器端套接字编程流程：</p>
<ol>
<li>调用socket函数创建套接字</li>
<li>调用bind函数为套接字分配IP地址和端口号</li>
<li>调用listen函数将套接字转换为可接收状态</li>
<li>调用 accept 函数受理连接请求。accept 会阻塞，直到有连接请求才会返回；</li>
<li>调用 read&#x2F;write 函数进行数据交换；</li>
<li>调用 close 函数断开连接；</li>
</ol>
<h2 id="客户端套接字"><a href="#客户端套接字" class="headerlink" title="客户端套接字"></a>客户端套接字</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>; </span><br><span class="line">			<span class="comment">// 功能：请求连接。 </span></span><br><span class="line">			<span class="comment">// 参数：sock：客户端套接字的文件描述符；serv_addr：保存目标服务器端地址信息的结构体指针；addrlen：第二个参数的长度（单位是字节） </span></span><br><span class="line">			<span class="comment">// 返回值：成功时返回 0，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>客户端请求连接步骤：</p>
<ol>
<li>调用socket函数创建套接字</li>
<li>调用connect函数请求连接</li>
<li>调用read&#x2F;write函数进行数据交换</li>
<li>调用close函数断开连接</li>
</ol>
<p>客户端的 IP 地址和端口在调用 connect 函数时自动分配，无需调用 bind 函数。</p>
<h1 id="基于Linux的文件操作符"><a href="#基于Linux的文件操作符" class="headerlink" title="基于Linux的文件操作符"></a>基于Linux的文件操作符</h1><p>Linux 中套接字描述符也是文件，因此通过套接字发送、接收数据就和读写文件一样，通过 read、write 这些函数来接收、发送数据。</p>
<p>文件描述符是系统分配给文件或套接字的整数。</p>
<p>0、1、2 分别由系统分配给了标准输入、标准输出和标准错误。</p>
<p>文件和套接字创建时才会被分配文件描述符。它们的文件描述符会从 3 开始按序递增。</p>
<p>下面是一些文件描述符的操作函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span> <span class="comment">// fcntl.h 和 unistd.h 包含的内容有些相似，包括 open 函数等。总之使用文件函数时将 fcntl.h 和 unistd.h 都 include 就可以了 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">		<span class="comment">// 功能：按照flag指定的模式打开文件</span></span><br><span class="line">		<span class="comment">// 参数：path：文件名的地址；flag：文件打开的模式</span></span><br><span class="line">		<span class="comment">// 成功时返回文件描述符，失败时返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>; </span><br><span class="line">		<span class="comment">// 功能：关闭 fd 对应的文件或套接字。当关闭一个套接字时会向对方发送 EOF。 </span></span><br><span class="line">		<span class="comment">// 参数：fd：文件或套接字的文件描述符。 </span></span><br><span class="line">		<span class="comment">// 返回值：成功时返回 0，失败时返回 -1</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line">		<span class="comment">// 功能：从文件 fd 读取数据。read 函数会阻塞，直到读取到数据或 EOF 才返回。 </span></span><br><span class="line">		<span class="comment">// 参数：fd：文件描述符；buf：保存要接收的数据；nbytes：要接收的最大字节数。 </span></span><br><span class="line">		<span class="comment">// 返回值：成功时返回接收的字节数（遇到文件尾则返回 0），失败时返回 -1</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>; </span><br><span class="line">		<span class="comment">// 功能：向文件 fd 输出数据。 </span></span><br><span class="line">		<span class="comment">// 参数：fd：文件描述符；buf：要传输的数据；nbytes：要传输的字节数。 </span></span><br><span class="line">		<span class="comment">// 返回值：成功时返回写入的字节数，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>size_t 的类型是 unsigned int，ssize_t 的类型是 signed int。<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/l3mm/906X266/file_open_mode.png" alt="906X266&#x2F;file_open_mode.png"></p>
<h1 id="基于Windows平台的实现"><a href="#基于Windows平台的实现" class="headerlink" title="基于Windows平台的实现"></a>基于Windows平台的实现</h1><p>Windows 套接字（简称 winsock）大部分是参考 UNIX 套接字设计的，与 Linux 套接字很相似但不完全相同。</p>
<p>大多数项目都是在 Linux 系统下开发服务器端，在 Windows 平台下开发客户端。</p>
<h3 id="为-Windows-套接字编程设置头文件和库"><a href="#为-Windows-套接字编程设置头文件和库" class="headerlink" title="为 Windows 套接字编程设置头文件和库"></a>为 Windows 套接字编程设置头文件和库</h3><p>要在 Windows 上进行套接字编程，需要：</p>
<ol>
<li>链接 ws2_32.lib 库。在 VS 中通过：项目&#x3D;&gt;属性&#x3D;&gt;配置属性&#x3D;&gt;链接器&#x3D;&gt;输入&#x3D;&gt;附加依赖项，添加 ws2_32.lib 库即可</li>
<li>导入头文件 WinSock2.h。Windows 中有一个 winsock.h 和一个 WinSock2.h。其中 WinSock2.h 是较新版本，用来代替前者的</li>
</ol>
<p>实际上在 windows 上还需要通过：项目&#x3D;&gt;属性&#x3D;&gt;配置属性&#x3D;&gt;C++ 将 SDL 检查设为否，否则运行会出错</p>
<h3 id="Winsock的初始化"><a href="#Winsock的初始化" class="headerlink" title="Winsock的初始化"></a>Winsock的初始化</h3><p>进行 Winsock 编程时，必须首先调用 WSAStartup 函数，设置程序中用到的 Winsock 版本，并初始化相应版本的库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested, LPWSADATA lpWSAData)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：初始化 Winsock 库</span></span><br><span class="line">    <span class="comment">// 参数：wVersionRequested：请求使用的 Winsock 版本；lpWSAData：指向 WSADATA 结构体变量的指针</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回错误代码</span></span><br></pre></td></tr></table></figure>
<p>两个参数的详细介绍：</p>
<ul>
<li>WORD wVersionRequested：WORD 类型是通过 typedef 定义的 unsigned short 类型。Winsock 中存在多个套接字版本，要选择需要的版本，0x0202 表示 2.2 版本。可以用 MAKEWORD(2, 2) 来构造版本号，它构造了 2.2 版本的表示值，即返回 0x0202。</li>
<li>LPWSADATA lpWSAData：LPWSADATA 是 WSADATA 类型的指针类型。没有特殊含义，只是为了调用函数，必须传递 WSADATA 类型变量的地址。</li>
</ul>
<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>下面这段代码几乎是 Winsock 编程的公式。在进行 Winsock 编程时直接按下述方式编写即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123; </span><br><span class="line">	WSADATA wsaData; </span><br><span class="line">	... </span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD9</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error&quot;</span>);</span><br><span class="line">	... </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 调用此函数，Winsock 相关库将还给操作系统，无法再调用 Winsock 相关函数。</span></span><br><span class="line">                <span class="comment">// 成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br></pre></td></tr></table></figure>

<h1 id="基于-Windows-的套接字相关函数"><a href="#基于-Windows-的套接字相关函数" class="headerlink" title="基于 Windows 的套接字相关函数"></a>基于 Windows 的套接字相关函数</h1><p>SOCKET 是 typedef 定义的整型类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：创建套接字</span></span><br><span class="line">    <span class="comment">// 参数：af：一般为 AF_INET；type：数据传输方式，一般为 SOCK_STREAM；protocol：一般设为 0 即可</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回套接字描述符，失败返回 INVALID_SOCKET</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">int</span> addrlen)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：为套接字分配地址信息</span></span><br><span class="line">    <span class="comment">// 参数：s：要分配地址信息的套接字描述符；myaddr：存有地址信息的结构体变量指针；addrlen：第二个参数的长度</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(SOCKET s, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：将套接字转换为可接收连接的状态</span></span><br><span class="line">    <span class="comment">// 参数：s：希望进入等待连接请求状态的套接字描述符；backlog：连接请求等待队列的长度，最多使 backlog 个连接请求进入队列</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：受理连接请求等待队列中待处理的连接请求。</span></span><br><span class="line">    <span class="comment">// 参数：s：服务器套接字的描述符；addr：用于保存发起连接请求的客户端地址信息；addrlen：第二个参数的长度</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回创建的套接字描述符，失败时返回 INVALID_SOCKET</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(SOCKET s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：请求连接。</span></span><br><span class="line">    <span class="comment">// 参数：s：客户端套接字的描述符；serv_addr：保存目标服务器端地址信息的结构体指针；addrlen：第二个参数的长度（单位是字节）</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closesocket</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：关闭 s 对应的套接字。当关闭一个套接字时会向对方发送 EOF。</span></span><br><span class="line">    <span class="comment">// 参数：s：套接字的描述符。</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv</span><span class="params">(SOCKET s, <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：从套接字 s 读取数据。recv 函数会阻塞，直到读取到数据或 EOF 才返回。</span></span><br><span class="line">    <span class="comment">// 参数：s：套接字描述符；buf：保存要接收的数据；len：要接收的最大字节数；flags：一般设为 0 即可</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回接收的字节数（遇到文件尾则返回 0），失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send</span><span class="params">(SOCKET s, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：向套接字 s 输出数据。</span></span><br><span class="line">    <span class="comment">// 参数：s：套接字描述符；buf：要传输的数据；len：要传输的字节数；flags：一般设为 0 即可</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回写入的字节数，失败时返回 SOCKET_ERROR</span></span><br></pre></td></tr></table></figure>
<h1 id="本章代码示例"><a href="#本章代码示例" class="headerlink" title="本章代码示例"></a>本章代码示例</h1><h2 id="hello-server-c"><a href="#hello-server-c" class="headerlink" title="hello_server.c"></a>hello_server.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock;<span class="comment">// 服务器套接字</span></span><br><span class="line">    <span class="type">int</span> clnt_sock;<span class="comment">// 客户端套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_adr; <span class="comment">// 客户端地址信息</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz; <span class="comment">// 客户端地址信息长度</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数：可执行文件名、端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建了一个 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充,主要是为了将 serv_addr 的 sin_zero 成员设为 0</span></span><br><span class="line">    <span class="comment">// 服务器地址信息</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//htonl 将long型数据从主机字节序转换为网络字节序。INADDR_ANY表示接受任意地址</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])); <span class="comment">// htons 将 short 型数据从主机字节序转换为网络字节序。atoi 将字符串转换为整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>) <span class="comment">// 将套接字和服务器IP地址信息绑定</span></span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>) <span class="comment">// 将套接字转换为可接收连接状态，连接请求等待队列长度为 5</span></span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz=<span class="built_in">sizeof</span>(clnt_adr); <span class="comment">// 接收连接请求时需要传递地址信息的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接受连接请求。accept 会阻塞，直到有连接请求才会返回</span></span><br><span class="line">    <span class="comment">// 并将 clnt_sock 套接字与其相连接</span></span><br><span class="line">    clnt_sock=<span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected client %d \n&quot;</span>, clnt_sock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, message, <span class="built_in">sizeof</span>(message)); <span class="comment">// 向客户端发送数据</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock); <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock); <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成可执行文件后的运行方式"><a href="#生成可执行文件后的运行方式" class="headerlink" title="生成可执行文件后的运行方式"></a>生成可执行文件后的运行方式</h3><p>在命令行中执行类似如下代码：</p>
<p><code>hello_server 5000 # 在端口 5000 处接收连接请求</code></p>
<h2 id="hello-client-c"><a href="#hello-client-c" class="headerlink" title="hello_client.c"></a>hello_client.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock; <span class="comment">// 套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>]; <span class="comment">// 保存接收数据的数组</span></span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数：可执行文件名、服务器IP地址</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.S_un.S_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]); <span class="comment">// 将点分十进制字符串转换为网络地址结构体</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>) <span class="comment">// 请求连接</span></span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len=<span class="built_in">read</span>(sock, message, <span class="built_in">sizeof</span>(message)<span class="number">-1</span>); <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="keyword">if</span>(str_len==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    message[str_len]=<span class="number">0</span>; <span class="comment">// 在字符串结尾添加 NULL 字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s \n&quot;</span>, message); <span class="comment">// 显示接收到的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock); <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成可执行文件后的运行方式-1"><a href="#生成可执行文件后的运行方式-1" class="headerlink" title="生成可执行文件后的运行方式"></a>生成可执行文件后的运行方式</h3><p>在命令行中执行类似如下代码：</p>
<p><code>hello_client 127.0.0.1 5000 # 向 127.0.0.1 5000 请求连接</code></p>
<h2 id="fd-seri-c"><a href="#fd-seri-c" class="headerlink" title="fd_seri.c"></a>fd_seri.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2, fd3;</span><br><span class="line">    fd1 = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">&quot;test.data&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC); <span class="comment">// 创建文件</span></span><br><span class="line">    fd3 = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d \n&quot;</span>, fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2: %d \n&quot;</span>, fd2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd3: %d \n&quot;</span>, fd3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="built_in">close</span>(fd3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预计输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fd1: 3</span><br><span class="line">fd2: 4</span><br><span class="line">fd3: 5</span><br></pre></td></tr></table></figure>

<h2 id="hello-server-win-c"><a href="#hello-server-win-c" class="headerlink" title="hello_server_win.c"></a>hello_server_win.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wsaData; <span class="comment">// 保存 Windows 套接字初始化信息的结构体变量</span></span><br><span class="line">    SOCKET serv_sock; <span class="comment">// 服务器套接字</span></span><br><span class="line">    SOCKET clnt_sock; <span class="comment">// 客户端套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_adr; <span class="comment">// 客户端地址信息</span></span><br><span class="line">    <span class="type">int</span> clnt_adr_sz; <span class="comment">// 客户端地址信息长度</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) <span class="comment">// 初始化 Winsock 库</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(serv_sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 接受任意地址</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])); <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==SOCKET_ERROR) <span class="comment">// 将套接字和服务器IP地址信息绑定</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>)==SOCKET_ERROR) <span class="comment">// 将套接字转换为可接收状态，连接请求等待队列长度为 5</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz=<span class="built_in">sizeof</span>(clnt_adr); <span class="comment">// 接收连接请求时需要传递地址信息的长度</span></span><br><span class="line"></span><br><span class="line">    clnt_sock=<span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz); <span class="comment">// 接受连接请求。accept 会阻塞，直到有连接请求才会返回</span></span><br><span class="line">    <span class="keyword">if</span>(clnt_sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">    <span class="built_in">send</span>(clnt_sock, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>); <span class="comment">// 向客户端发送数据</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clnt_sock); <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="built_in">closesocket</span>(serv_sock); <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>(); <span class="comment">// 释放 Winsock 库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hello-client-win-c"><a href="#hello-client-win-c" class="headerlink" title="hello_client_win.c"></a>hello_client_win.c</h2><p>书中源代码编译会报错，根据报错提示对第 33 行进行了修改。并且还要将项目&#x3D;》属性&#x3D;》配置属性&#x3D;》C&#x2F;C++ &#x3D;》常规&#x3D;》SDL检查 修改为”否“。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wsaData; <span class="comment">// 保存 Windows 套接字初始化信息的结构体变量</span></span><br><span class="line">    SOCKET sock; <span class="comment">// 套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>]; <span class="comment">// 保存接收数据的数组</span></span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) <span class="comment">// 初始化 Winsock 库</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]); <span class="comment">// 将点分十进制字符串转换为网络地址结构体</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==SOCKET_ERROR) <span class="comment">// 请求连接</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len=<span class="built_in">recv</span>(sock, message, <span class="built_in">sizeof</span>(message)<span class="number">-1</span>, <span class="number">0</span>); <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="keyword">if</span>(str_len==SOCKET_ERROR)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    message[str_len]=<span class="number">0</span>; <span class="comment">// 在字符串结尾添加 NULL 字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s \n&quot;</span>, message); <span class="comment">// 显示接收到的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock); <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>(); <span class="comment">// 释放 Winsock 库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个运行方式和之前一样</p>
<h1 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h1><h2 id="Linux-POSIX-和-Windows-对-sockaddr-in-结构体内部成员的定义方式不同"><a href="#Linux-POSIX-和-Windows-对-sockaddr-in-结构体内部成员的定义方式不同" class="headerlink" title="Linux&#x2F;POSIX 和 Windows 对 sockaddr_in 结构体内部成员的定义方式不同"></a>Linux&#x2F;POSIX 和 Windows 对 sockaddr_in 结构体内部成员的定义方式不同</h2><ul>
<li>在 Linux 和其他 POSIX 系统中，IP地址成员的访问方式是 sin_addr.s_addr。</li>
<li>在 Windows 中，底层的实际访问方式是 sin_addr.S_un.S_addr。</li>
</ul>
<ol>
<li><p>结构体定义的差异<br> 在 Linux&#x2F;POSIX (netinet&#x2F;in.h)sockaddr_in 结构体中的 in_addr 通常被定义为：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">// 32位的IPv4地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">// IP地址结构体</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 在这里，s_addr 是 in_addr 结构体的一个直接成员，所以你可以通过 serv_adr.sin_addr.s_addr 来访问它。</p>
<p> 在 Windows (WinSock2.h)<br> Windows 的定义要复杂一些，它使用了一个联合（union）来提供多种访问同一块内存的方式：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">uint32_t</span> S_addr;</span><br><span class="line">    &#125; S_un;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 在这个定义中，要访问32位的长整型地址，正确的路径是serv_adr.sin_addr.S_un.S_addr。</p>
</li>
<li><p>为什么 s_addr 有时也能在 Windows 上工作？<br> 为了让开发者能够编写跨平台的代码，Windows 的 WinSock2.h 头文件中通常包含了这样一个宏定义：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> s_addr S_un.S_addr</span></span><br></pre></td></tr></table></figure>
<p> 这个 #define 预处理指令告诉编译器：在代码中任何出现 s_addr 的地方，都将其替换为 S_un.S_addr。</p>
</li>
</ol>
<h2 id="IP地址的不同转换方式"><a href="#IP地址的不同转换方式" class="headerlink" title="IP地址的不同转换方式"></a>IP地址的不同转换方式</h2><p>一个IPv4地址本质上是一个32位的无符号整数（long 或 uint32_t）。为了方便记忆和书写，我们使用“点分十进制”表示法，例如 192.168.1.1。</p>
<p>程序处理: 在程序中，这个点分十进制的字符串必须被转换成32位的整数才能被网络协议栈使用。</p>
<ul>
<li>在服务器端代码 hello_server.c 中，使用了 INADDR_ANY。这是一个特殊的宏，代表一个 long 型整数 0，告诉操作系统绑定到本机所有可用的IP地址上。它本身就是一个 long 整型，所以直接用 htonl 转换。</li>
<li>在客户端代码 hello_client.c 中，使用了 inet_addr(argv[1])。这个函数的作用就是将点分十进制的字符串（如 “127.0.0.1”）转换成一个网络字节序的 long 整型。</li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串、向量和数组</title>
    <url>/2024/05/31/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>本文为阅读C++ primer第三章的读书笔记，仅作为查找以及防止遗忘对应知识点作用，不可替代原书。</p>
<span id="more"></span>
<h1 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h1><p>可以对单个名字进行独立的using声明</p>
<p>头文件里不应包含 using 声明。因为头文件的内容会拷贝到所有引用它的文件，一旦头文件有using声明，每个引用它的文件都有该声明，可能冲突</p>
<h1 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h1><p>string 表示可变长的字符序列。</p>
<h2 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h2><p>有以下几种方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1; <span class="comment">//将 s1 默认初始化为一个空的 string </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(s2)</span></span>; <span class="comment">//使用拷贝构造函数进行的拷贝初始化。s1 是 s2 的拷贝。 </span></span><br><span class="line">string s1 = s2; <span class="comment">//使用拷贝赋值运算符进行的拷贝初始化。s1 是 s2 的拷贝。 </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>; <span class="comment">//s1 是字面值 &quot;value&quot; 去除最后一个空字符后的拷贝。 </span></span><br><span class="line">string s1 = <span class="string">&quot;value&quot;</span>; <span class="comment">//同上。 </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//s1 初始化为 n 个 &#x27;c&#x27;。</span></span><br></pre></td></tr></table></figure>
<p><strong>使用字符串字面值或字符数组初始化 string 对象时，string 对象中是不包含末尾的空字符的，它会将字符数组中末尾的空字符去掉</strong></p>
<h2 id="string的一些操作"><a href="#string的一些操作" class="headerlink" title="string的一些操作"></a>string的一些操作</h2><p><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250725/QdOG/1040X475/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-07-25_163653.png" alt="1040X475&#x2F;屏幕截图_2025-07-25_163653.png"></p>
<h3 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h3><p>可以使用 cin, cout 来读写 string 对象，也可以使用 stringstream 来读写 string 对象。</p>
<h4 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline 函数"></a>getline 函数</h4><p>getline() 定义在头文件 string 中，以一个 istream 对象和一个 string 对象为输入参数。getline() 读取输入流的内容直到遇到换行符停止，然后将读入的数据存入 string 对象。</p>
<p>注意 getline 会将换行符也读入，但是不将换行符存入 string 对象。即触发 getline() 函数返回的那个换行符实际上被丢弃掉了。</p>
<p>getline() 只要一遇到换行符就结束读取操作并返回结果，即使一开始就是换行符也一样，这种情况下会得到一个空 string。</p>
<p>getline() 与 &lt;&lt; 一样，会返回它的流参数。所以可以用 getline 的结果作为条件。</p>
<h3 id="string-size-type-类型"><a href="#string-size-type-类型" class="headerlink" title="string::size_type 类型"></a>string::size_type 类型</h3><p>string 的 size() 成员函数返回一个 string::size_type 类型的值。</p>
<blockquote>
<p>[!NOTE] 配套类型<br>大多数标准库类型都定义了几种配套的类型，这些配套类型体现了标准库与机器无关的特性。</p>
</blockquote>
<p>在具体使用时，通过作用域操作符来表明 size_type 是在类 string 中定义的。</p>
<p>string::size_type 是无符号值，可以确定的是它足够存放任何 string 对象的大小。</p>
<p>C++11 允许通过 auto 和 decltype 来获得此类型。</p>
<p><code>auto len = s.size();// len 的类型是 string::size_type</code></p>
<p>不要在同一个表达式中混用 size_type 和 int 类型。原因一部分在于无符号数和有符号数转换的问题上</p>
<h2 id="string中的字符"><a href="#string中的字符" class="headerlink" title="string中的字符"></a>string中的字符</h2><p>cctype 头文件中有下列标准库函数来处理 string 中的字符。</p>
<p>下面这些函数的输入和返回值实际都是 int 类型的，且输入的值 c 必须满足 -1&lt;&#x3D;c&lt;&#x3D;255，即输入必须是 ASCII 字符<br><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250725/blbx/1019X636/cctype.png" alt="1019X636&#x2F;cctype.png"></p>
<blockquote>
<p>[!tip] 头文件使用建议<br>使用 c++ 版本的标准库头文件</p>
</blockquote>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str) <span class="comment">// 对于str中的每个字符 </span></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出当前字符，后面紧跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>当要改变 string 对象中的值时，需要把循环变量定义成引用类型。必须通过显示添加 &amp; 符号来声明引用类型。</p>
<p><strong>不能在范围 for 语句中改变所遍历序列的大小。</strong></p>
<p><code>for(auto &amp;c:str) c = toupper(c); // 转换为大写</code></p>
<p>对 string 的最后一个字符进行索引：s[s.size()-1];</p>
<p>索引必须大于等于 0 小于 size，使用索引前最好用 if(!s.empty()) 判断一下字符串是否为空。</p>
<p>任何表达式只要是整型值就可以作为索引。索引是无符号类型 size_type；</p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>变量和基本类型</title>
    <url>/2024/05/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>本文为阅读C++ primer第二章的读书笔记，仅作为查找以及防止遗忘对应知识点作用，不可替代原书。</p>
<span id="more"></span>
<p>C++定义了几种基本内置类型，如字符、整型、浮点数等。</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>基本内置类型包括算数类型和空类型。算术类型包括字符、整数、布尔值和浮点数。void类型没有关联的值，只能在少数情况下使用，最常见的是作为不返回值的函数的返回类型</p>
<h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>算数类型整体分为整型和浮点型两类。字符和布尔值都属于整型。</p>
<p>C++ 定义了各类型的最小尺寸：bool 未定义、char 8位、short 16位、int 16位、long 32位、long long 64位；float 是 32 位 4 字节，包括6位有效数字、double 是 64 位 8 字节，包括10位有效数字。</p>
<blockquote>
<p>[!NOTE] int位数的特别说明<br>int作为一个变长的类型，可能是16位，也可能是32位，取决于编译器。目前多为32位</p>
</blockquote>
<p>int、short、long 都是带符号类型。char 是否有符号由编译器决定。</p>
<p>因为 char 是否有符号并不确定，因此可以使用 signed char 或 unsigned char 来指定是否有符号。</p>
<p>C++ 提供了几种字符类型：</p>
<ol>
<li>char：一个 char 的空间应确保可以存放机器基本字符集中任意字符对于的数字值，即一个 char 的大小和一个机器字节一样。</li>
<li>wchar_t：宽字符，用于扩展字符集，wchar_t 确保可以存放机器最大扩展字符集中的任意一个字符。</li>
<li>char16_t 和 char32_t：为 Unicode 字符集服务。<br>下为书中列出的表格：<br><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250719/ilim/1158X563/C%2B%2B_Arithmetic_Types.png" alt="1158X563&#x2F;C++_Arithmetic_Types.png"></li>
</ol>
<blockquote>
<p>[!NOTE] 类型选择技巧<br>明确知晓数值不可能为负时，选用无符号类型。</p>
<p>整数运算用 int，数值太大时用 long long，不用 short 和 long </p>
<p>浮点数运算用 double。float 和 double 的计算代价相差无几</p>
</blockquote>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="几种类型转换的情况："><a href="#几种类型转换的情况：" class="headerlink" title="几种类型转换的情况："></a>几种类型转换的情况：</h3><ul>
<li>把浮点数赋给整型时，结果仅保留小数点前的部分。</li>
<li>赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如 -1 赋给 8 位 unsigned char 的结果是 255（-1&#x3D;256*(-1)+255）</li>
<li>赋给带符号类型超出范围的值时，结果是未定义的。程序可能工作，可能崩溃。</li>
</ul>
<p>程序尽量避免依赖于实现环境的行为。比如 int 的尺寸在不同环境可能不同。</p>
<h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p>一个表达式中既有无符号数又有int值时，int会被转换成无符号数。</p>
<p>无符号减无符号数，结果还是无符号数，如果是负值就等于该符数加上无符号数的模<br><code>unsigned u = 10; int i = -42; u + i = -32 + 2^32 = 4294967264</code></p>
<h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。</p>
<p>整型字面值的具体数据类型由它的值和符号决定。默认情况下十进制字面值是带符号数，类型是 int, long, long long 中能容纳当前值的尺寸最小的那个。</p>
<p>浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识</p>
<h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><p>单引号括起来的一个字符是 char 型字面值，双引号括起来的 0 个或多个字符则构成字符串型字面值。</p>
<p>字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（’\0’），因此字符串字面值的实际长度要比它的内容多 1。如 “A” 代表了一个长度为 2 的字符数组。</p>
<p><strong>如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string global_str = <span class="string">&quot;A is B&quot;</span>   <span class="string">&quot;and B is A&quot;</span>;</span><br><span class="line">cout &lt;&lt; global_str &lt;&lt; endl; <span class="comment">// 输出: A is Band B is A</span></span><br></pre></td></tr></table></figure>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>建议直接网上查表</p>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>可以通过给字面值增加前缀和后缀来改变字面值的默认类型。<br>下为一些常见的字面量类型指定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;整型字面值&#x27;</span> </span><br><span class="line"><span class="number">12</span> <span class="comment">// 默认类型为 int </span></span><br><span class="line"><span class="number">12u</span> <span class="number">12U</span> <span class="comment">// 最小匹配类型 unsigned </span></span><br><span class="line"><span class="number">12l</span> <span class="number">12L</span> <span class="comment">// 最小匹配类型 long </span></span><br><span class="line"><span class="number">12ul</span> <span class="number">12UL</span> <span class="comment">// 最小匹配类型 unsigned long </span></span><br><span class="line"><span class="number">12ll</span> <span class="number">12LL</span> <span class="comment">// 最小匹配类型 long long </span></span><br><span class="line"><span class="number">12ull</span> <span class="number">12ULL</span> <span class="comment">// 最小匹配类型 unsigned long long </span></span><br><span class="line"><span class="string">&#x27;浮点型字面值&#x27;</span> </span><br><span class="line"><span class="number">3.14</span> <span class="comment">// 默认类型为 double </span></span><br><span class="line"><span class="number">3.14f</span> <span class="number">3.14F</span> <span class="comment">// 类型为 float </span></span><br><span class="line"><span class="number">3.14l</span> <span class="number">3.14L</span> <span class="comment">// 类型为 long double </span></span><br><span class="line"><span class="string">&#x27;字符字符串字面值&#x27;</span> </span><br><span class="line"><span class="string">u&#x27;a&#x27;</span> <span class="string">u&quot;abandon&quot;</span> <span class="comment">// Unicode 16 字符，类型为 char16_t </span></span><br><span class="line"><span class="string">U&#x27;a&#x27;</span> <span class="string">U&quot;abandon&quot;</span> <span class="comment">// Unicode 32 字符，类型为 char32_t </span></span><br><span class="line"><span class="string">L&#x27;a&#x27;</span> <span class="string">L&quot;abandon&quot;</span> <span class="comment">// 宽字符，类型为 wchar_t </span></span><br><span class="line"><span class="string">u8&quot;abandon&quot;</span> <span class="comment">// 类型为 char，u8 的含义是 UTF-8，仅用于字符串字面值。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意 12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f</strong></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>对于c++而言，”变量“和”对象“一般可以互换使用。</p>
<p>c++中，对象通常指一块能存储数据并具有某种类型的内存</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>可以一个一个初始化</p>
<p>也可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。<br><code>double price = 109.99, discount = price * 0.6;</code></p>
<p>初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值擦除并用一个新值来替代。</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>下面四种初始化方式都是可行的，其中使用花括号的方式叫做列表初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>; <span class="type">int</span> i=&#123;<span class="number">0</span>&#125;; <span class="type">int</span> i&#123;<span class="number">0</span>&#125;; <span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>; </span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;, b=&#123;ld&#125;; <span class="comment">//错误，存在信息丢失的风险，转换未执行。 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d</span>=ld; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p><strong>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。</strong></p>
<p>定义于任何函数之外的内置类型则被初始化为0；</p>
<p>类的对象如果没有显式地初始化，则其由类确定。string 默认初始化为一个空串。</p>
<p>不能使用未初始化的变量，否则会引发运行时故障。</p>
<p><strong>建议初始化每一个内置类型的变量。</strong></p>
<h2 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h2><p>声明和定义是严格区分的。</p>
<p>要声明一个变量加 extern，声明变量不能赋值。</p>
<p>任何包含了显式初始化的声明即成为定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// 声明 i </span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">// 定义i； </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 定义 i，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure>
<p>变量只能被定义一次，但是可以多次声明。通过这种方式，一个变量可以在多个文件中使用</p>
<p>声明和定义的区分很重要</p>
<p>c++是静态类型语言，其含义是在编译阶段检查类型。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。</p>
<p>用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。这些是为了确保用户自定义的标识符不会和标准库中的重合</p>
<p>变量命名规范：</p>
<ol>
<li>标识符要体现其实际含义。</li>
<li>变量名一般用小写字母。</li>
<li>用户自定义的类型一般以大写字母开头。</li>
<li>包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。</li>
</ol>
<p>对于嵌套作用域，可以在内层作用域中重新定义外层作用域已有的名字，但是最好不要这样做。</p>
<h2 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h2><p>同一个名字在不同的作用域可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在作用域末端结束</p>
<blockquote>
<p>[!NOTE] 第一次使用变量时定义它<br>有助于更容易找到定义，也可以帮助合理给定初值</p>
</blockquote>
<h3 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h3><p>作用域可以互相包含。</p>
<p>被包含的作用域称为内层作用域（inner scope），包含其他作用域的作用域称为外层作用域（outer scope）。</p>
<p>一旦在作用域中声明了名字，嵌套在该作用域内部的作用域就可以使用该名字。在外层作用域中声明的名称也可以在内层作用域中重新定义。取最近的定义作为访问的对象</p>
<blockquote>
<p>[!NOTE] scope operator<br>:: 可以用于在内层访问全局变量</p>
</blockquote>
<p>下面是一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line">	<span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line">	<span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">	std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p>复合类型就是基于其他类型定义的类型，引用和指针是其中两种</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是给对象起的别名。初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。</p>
<p>引用必须初始化。引用的初始值必须是一个对象，不能是字面值。引用只能绑定同类型对象。</p>
<p>对引用的所有操作都是对与之绑定的对象的操作。</p>
<p>引用非对象。因此不能定义对引用的引用</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在块作用域内，指针如果没有被初始化，值将不确定。</p>
<p>指针必须指向指定的类型，不能指向其他类型。<strong>这是严格的，哪怕是long和int都是不能互相指向的</strong></p>
<p>指针与引用的不同：</p>
<ul>
<li>指针是一个对象而引用不是；</li>
<li>指针可以重新赋值，而引用不行</li>
<li>有指向指针的指针，无引用的引用</li>
<li>指针不需要在定义时赋初值，而引用需要<br>不能定义指向引用的指针。可以定义指向指针的引用。</li>
</ul>
<blockquote>
<p>[!NOTE] 根本原因<br>指针是对象，而引用不是、指针指向的是对象，而引用也只能引用对象</p>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种定义空指针的方式。最好用第一种</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">nullptr</span>;  </span><br><span class="line"><span class="type">int</span> *p = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure>

<p>建议初始化所有指针。</p>
<p>非零指针对应的条件值是 ture，零指针对应的条件值是 false。</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3><p>void* 指针和空指针不是一回事。</p>
<p>void* 指针是特殊的指针类型，可以存放任意对象的地址。</p>
<p>一般来说，使用 void* 指针将内存作为内存来处理，而不是使用指针来访问存储在内存中的对象</p>
<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><p>const 对象必须初始化，因为一旦创建就不能再改变值。</p>
<p>默认情况下，const 对象仅在文件内有效。因此你可以在多个文件中定义多个相同名字的const 对象</p>
<p>如果想在多个文件间共享 const 对象，必须在变量的定义前添加 extern 关键字并在本文件中声明。声明和定义都要加 extern。</p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>常量引用不是说引用是常量，因为引用本来就只能绑定一个对象，而是引用不能改变引用的对象值。</p>
<p>常量引用可以绑定const对象，也可以绑定非常量对象。但是无论哪种，都不能通过引用去修改绑定的对象的值了。</p>
<p><strong>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。</strong></p>
<p>之前我们提到过：引用的类型必须与其所引用对象的类型一致，但是有两个例外。其中一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</p>
<blockquote>
<p>[!NOTE] 原理<br>实际上是创建了一个临时对象让常量引用绑定，也因此不能通过常量引用修改对象的值</p>
</blockquote>
<h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><p>指向常量的指针既可以指向常量也可以指向非常量，和常量引用一样，也不能通过指向常量的指针修改对象的值</p>
<p>至于具体作为常量的指针和指向常量的指针，我们在下一小节介绍</p>
<h2 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h2><p>顶层 const 表示指针本身是个常量，底层 const 表示指针所指的对象是一个常量。顶层 const 对任何数据类型通用，底层 const 只用于引用和指针。</p>
<p>顶层 const 的指针表示该指针是 const 对象，因此必须初始化。底层 const 的指针则不用。</p>
<p>实际上只有指针类型既可以是顶层 const 也可以是底层 const，因为引用实际上只能是底层 const，常量引用即为底层 const，不存在顶层 const 的引用。</p>
<p><strong>从右向左读来判断是顶层 const 还是底层 const。</strong></p>
<p>对于指针和引用而言，顶层 const 在右边，底层 const 在左边。对于其他类型，全都是顶层 const</p>
<p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2 = &amp;c; <span class="comment">// 这是一个底层const，允许改变 p2 的值 </span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">// 这是一个顶层const，不能改变 p1 的值</span></span><br></pre></td></tr></table></figure>

<p>执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。而顶层const会被忽略。</p>
<h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p>字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。</p>
<h3 id="cosntexpr变量"><a href="#cosntexpr变量" class="headerlink" title="cosntexpr变量"></a>cosntexpr变量</h3><p>在实际应用中很难分辨一个初始值是否是常量表达式，通过将变量声明为 constexpr 类型即可由编译器来检查。</p>
<p>由 constexpr 声明的变量必须用常量表达式初始化。</p>
<p>建议：如果认定一个变量是常量表达式，就把它声明为 constexpr 类型。</p>
<p>新标准允许定义 constexpr，这种函数应该足够简单以使得编译时就可以计算其结果。</p>
<p>不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化 constexpr 变量。</p>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>算术类型、引用、指针都属于字面值类型，自定义类则不属于。</p>
<p>cosntexpr 指针的初始值必须是 nullptr 或 0 或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。</p>
<p>注意区分 constexpr 和 const 。constexpr 都是顶层 const，仅对指针本身有效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// p 是一个指向整型常量的指针 </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q 是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h3 id="const和constexpr区别"><a href="#const和constexpr区别" class="headerlink" title="const和constexpr区别"></a>const和constexpr区别</h3><p>constexpr 限定了变量是编译器常量，即变量的值在编译器就可以得到。</p>
<p>const 则并未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只是初始化后就不能再改变了。</p>
<p><strong>constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。</strong></p>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>有以下两种方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">// 使用 typedef 关键字 </span></span><br><span class="line"><span class="keyword">using</span> wages = <span class="type">double</span>; <span class="comment">// 使用 using 关键字进行别名声明</span></span><br></pre></td></tr></table></figure>
<p>和其他声明语句一样，typedef 的声明语句中也可以包含类型修饰符，从而构造复合类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 是 double 的别名，p 是 double* 的别名。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 带有指针的别名<br><code>typedef char* pstring; const pstring cstr = 0;</code><br> 注意：cstr是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr &#x3D; 0，按后者的话，cstr是一个指向常量的指针。这是错误的。</p>
</blockquote>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto 说明符让编译器根据初始值来分析表达式所属的类型。</p>
<p>auto 可以在一条语句中声明多个变量，但是多个变量将会是同一个基本数据类型</p>
<p><strong>编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：</strong></p>
<ol>
<li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li>
<li>auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。</li>
<li>auto 会保留底层 const。</li>
</ol>
<p>下面给出一些例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>, &amp;cr = ci; </span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b 是一个普通的 int。 </span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c 是一个普通的 int。 </span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> d = ci; <span class="comment">// d 是一个 const int </span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">// e 是一个指向常量的引用（常量引用是底层 const）。注意这个微妙的地方。 </span></span><br><span class="line"><span class="keyword">auto</span> f = &amp;ci; <span class="comment">// f 是一个 const int*（位于左边的 const 是底层 const）</span></span><br></pre></td></tr></table></figure>

<p><strong>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用</strong></p>
<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>当希望获得表达式的类型但是不要计算值的时候，可以使用类型说明符 decltype。</p>
<p>如果 decltype 使用的表达式是一个变量，则它返回该变量的类型（包括顶层 const 和引用在内）。</p>
<p>decltype 与 auto 的不同：decltype 不会忽略引用和顶层 const。</p>
<p>注意当获得的类型是引用时，必须初始化。</p>
<h3 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h3><p>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。可以使用这种方式来保证不获取引用类型。</p>
<p>注意解引用指针的结果是一个引用类型。给变量加括号的结果也是引用类型。赋值操作的结果也是引用类型。</p>
<p><strong>decltype((var)) 的结果永远是引用，而 decltype(var) 的结果只有当 var 本身就是引用时才是引用。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, &amp;r = i, *p; </span><br><span class="line"><span class="keyword">decltype</span>(r<span class="number">+0</span>) b; <span class="comment">// b 的类型是 int，因为 r+0 的结果类型是 int。 </span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i; <span class="comment">// c 的类型是 int&amp;。 </span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = i; <span class="comment">// d 的类型是 int&amp;。</span></span><br><span class="line"><span class="keyword">decltype</span>(j = r<span class="number">+0</span>) b = i; <span class="comment">// d 的类型是 int&amp;。</span></span><br></pre></td></tr></table></figure>
<h1 id="自定义数据结构和引用"><a href="#自定义数据结构和引用" class="headerlink" title="自定义数据结构和引用"></a>自定义数据结构和引用</h1><h2 id="定义struct类型"><a href="#定义struct类型" class="headerlink" title="定义struct类型"></a>定义struct类型</h2><p>struct+类名+类体+分号。类体可以为空。</p>
<p><code>struct Sales_data&#123;&#125;; // 注意：结尾加分号</code></p>
<p>定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。</p>
<p>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</p>
<h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</p>
<p>头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。</p>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p>
<p>预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。</p>
<p>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</p>
<p>c++ 中包含三个头文件保护符：</p>
<ol>
<li>#define：把一个名字设定为预处理变量</li>
<li>#ifndef：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #endif 为止</li>
<li>#endif</li>
</ol>
<p>预处理变量无视作用域的规则，作用范围是文件内</p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>语句</title>
    <url>/2024/06/07/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h1><h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>一个表达式加一个分号就是一个表达式语句，其执行表达式并丢弃掉求值结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ival + <span class="number">3</span>;<span class="comment">//一条没有实际用处的表达式语句 </span></span><br><span class="line">cout &lt;&lt; ival;<span class="comment">//一条有用的表达式语句</span></span><br></pre></td></tr></table></figure>
<h2 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h2><p>空语句是最简单的语句，只有一个分号</p>
<p>用在语法上需要一条语句，但是逻辑上不需要的地方。</p>
<p>使用空语句块最好加注释</p>
<h2 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h2><p>用花括号括起来的语句和声明序列都是复合语句（块），一个复合语句（块）就是一个作用域</p>
<p>空块的作用等价于一个空语句</p>
<h1 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h1><p>可以在 if、switch、while、for 语句的控制结构内定义变量。</p>
<p>这些定义的变量只能在这些语句的复合语句中使用</p>
<p>常见的语句有条件语句、循环语句、跳转语句三种。</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if 语句有两种形式，一种有 else 分支，另一种没有。</p>
<p>c++ 规定 else 与离他<strong>最近的在同一作用域的尚未匹配的</strong> if 匹配</p>
<p>使用 if 语句最好在所有的 if 和 else 之后都用花括号</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch 语句计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。如果没有任何一个 case 标签匹配 switch 表达式的值，就执行 default 分支。</p>
<p>case 关键字和它对应的值一起被称为 case 标签，case 标签必须为<strong>整型常量表达式</strong>。</p>
<p>default 也是一种特殊的 case 标签。</p>
<p>注意：如果switch条件值在某个case标签满足后，程序将从该case标签一直执行到switch末尾或者遇到第一个break。因此一般在每个 case标签后都有一条 break 语句。如果需要两个或多个值共享同一组操作，可以故意省略掉 break 语句</p>
<p>一条switch语句后可以跟多条语句，而不需要花括号</p>
<blockquote>
<p>[!NOTE] 为了代码的可阅读性，一般有以下规范<br>一般不要省略 case 分支最后的 break 语句。如果没有 break 语句，最好注释一下。</p>
<p>即使不准备在 default 下做任何工作，最好也定义一个 default 标签。</p>
<p>如果要在 case 分支定义并初始化变量，应该定义在块内以约束其作用域</p>
</blockquote>
<h1 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h1><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>其条件不能为空，可以是一个表达式或者带初始化的变量声明</p>
<p>定义在条件部分或者循环体内的变量每次迭代都会重新创建和销毁</p>
<p>一般使用于不知道多少次的循环</p>
<h2 id="传统for语句"><a href="#传统for语句" class="headerlink" title="传统for语句"></a>传统for语句</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement; condition; expression) </span><br><span class="line">	statement;</span><br></pre></td></tr></table></figure>
<p>init-statement 可以是声明语句、表达式语句或空语句。init-statement 可以定义多个对象，但是只能有一条声明语句。</p>
<p>expression 在每次循环之后执行。</p>
<p>for 语句头能省略掉三者中的任意一个或全部。</p>
<p>如果省略 condition ，条件恒为 true。</p>
<h2 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h2><p>用来遍历<strong>容器或其他序列</strong>的所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : expression) </span><br><span class="line">	statement;</span><br></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列（可以是用花括号括起来的初始值列表）。共同特点的是都可以返回迭代器的 begin 和 end 成员</p>
<p>declaration定义一个能从序列中元素转换而来的变量（<strong>不是迭代器</strong>），最简单的方法为用auto</p>
<p>如果需要执行写操作，必须将循环变量声明成引用类型。不需要写时最好都声明为常量引用</p>
<p>每次迭代都会重新定义循环控制变量，并将其初始化为序列的下一个值。</p>
<p><strong>绝对不要在范围 for 语句改变序列的元素数量</strong>。因为其预存了 end() 的值，改变元素数量后 end() 的值就可能失效了</p>
<h2 id="dowhile语句"><a href="#dowhile语句" class="headerlink" title="dowhile语句"></a>dowhile语句</h2><p>do while 语句与 while 语句的唯一区别就是它先执行循环体后检查条件。即至少执行一次循环。</p>
<p>注意：do while 后不要忘了加分号。</p>
<p>因为 condition 在循环体后面，所以 condition 使用的变量应该定义在循环体外面。</p>
<h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h1><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>终止离它最近的 while、do while、for 或 switch 语句，并从这些语句之后的第一条语句开始执行。</p>
<p>break 语句只能出现在迭代语句或 switch 内部</p>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>终止最近的循环中的当前迭代并开始下一次迭代。</p>
<p>continue 只能出现在迭代语句内部</p>
<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>作用是从 goto 语句无条件跳转到同一函数内的另一条语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">label: <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>
<p>label 是用于标识一条语句的标示符</p>
<p>标签标示符独立于变量或其他标示符的名字，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</p>
<p>如果 goto 语句跳回了一条变量的定义之前意味着系统将会销毁该变量，然后重新创建它。</p>
<p><strong>不要使用 goto，它会令程序又难理解又难修改</strong></p>
<h1 id="try和异常处理"><a href="#try和异常处理" class="headerlink" title="try和异常处理"></a>try和异常处理</h1><p>异常是指存在于运行时的反常行为，典型的有失去数据库连接和意外输入等等。</p>
<p><strong>处理异常可能是最难的部分</strong></p>
<p>当程序检测到一个无法处理的问题时，就需要异常处理，此时检测到问题的部分应该发出检测信号。</p>
<p>如果程序里有可能引发异常的代码，也应该有专门的代码处理问题</p>
<p>C++的异常处理机制为异常检测和异常处理提供支持。包括：</p>
<ol>
<li>throw表达式：异常检测部分使用throw表达式来表示遇到了无法处理的问题</li>
<li>try语句块：异常处理部分使用try语句块处理异常，以关键字try开始，一个或多个catch结束</li>
<li>一套异常类：用于在 throw 表达式和相关的 catch 子句间传递异常的具体信息</li>
</ol>
<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><p>throw 表达式包含关键字 throw 和紧随其后的一个表达式，表达式的类型就是抛出的异常类型</p>
<p>即 throw 后面跟一个异常类型的对象（必须同时使用 string 或 C 风格字符串对其初始化）</p>
<p><code>throw runtime_error(&quot;Data must be same as size&quot;);//使用 throw 表达式抛出一个运行时错误。</code></p>
<h2 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h2><p>跟在 try 块后面的是一个或多个 catch 子句。catch子句包括三部分：关键字catch、括号内一个异常类型的对象的声明（即异常声明）、一个块</p>
<p>当try语句中抛出了一个异常，如果该异常类型与catch子句中的异常类型相同，就会执行该catch子句</p>
<p>catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句执行</p>
<p>在catch后的括号中使用省略号…可以让catch捕获所有异常</p>
<p>每个标准库异常类都有一个 what 成员函数，它没有参数，返回初始化该对象时所用的 C 风格字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must be same as size&quot;</span>);<span class="comment">//try 语句块抛出了一个异常 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">catch</span>(runtime_error err)<span class="comment">//在 catch 后面的括号中声明了一个“runtime_error”类型的对象，与 try 抛出的异常类型相同，接下来执行此子句。 </span></span><br><span class="line">	&#123; </span><br><span class="line">		cout &lt;&lt; err.<span class="built_in">what</span>();<span class="comment">//输出 &quot;Data must be same as size&quot; </span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 函数在寻找处理代码的过程中退出<br>throw 语句可能出现在嵌套的 try 语句块中或在 try 语句块中调用的某个函数内。</p>
<p>当异常抛出的时候，会从内到外一层层寻找相应类型的catch子句。如果最后还是没找到，会调用terminate函数调用来终止程序</p>
<p>如果 throw 语句外就没有 try 语句块，也会执行 terminate 函数</p>
<p>异常中断了程序的正常流程。当发生异常，程序执行到一半就中断了，可能会存在如资源没有正常释放，对象没有处理完成等情况。异常安全的代码要求在异常发生时能正确执行清理工作。这个非常困难</p>
</blockquote>
<h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++ 标准库定义了一组异常类，用于报告标准库函数遇到的问题。他们定义在 4 个头文件中</p>
<p>定义在stdexcept头文件中的类型必须使用string对象或者C风格字符串来初始化，其他的3个头文件中的类型则只能默认初始化，</p>
<p>异常类型只有一个 what 成员函数，该函数没有参数，返回是一个 C 风格字符串的指针，目的是提供关于异常的文本信息</p>
<p>对于无初始值的异常类型，what 返回的内容由编译器决定，有初始值的返回初始值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exception头文件 </span></span><br><span class="line">exception           <span class="comment">// 异常类 exception 是最通用的异常类。它只报告异常的发生，不提供额外信息。 </span></span><br><span class="line"><span class="comment">//new头文件</span></span><br><span class="line">bad_alloc           <span class="comment">// 异常类 bad_alloc。在使用 new 分配动态内存失败时抛出 </span></span><br><span class="line"><span class="comment">//type_info头文件 </span></span><br><span class="line">bad_cast            <span class="comment">// 异常类型 bad_cast。经常发生在使用 dynamic_cast 时发生。 //stdexcept头文件 </span></span><br><span class="line">exception runtime_error       <span class="comment">// 只有在运行时才能检测出的问题 </span></span><br><span class="line">range_error         <span class="comment">// 运行时错误：生成的结果超出了有意义的值域范围 overflow_error      // 运行时错误：计算上溢 </span></span><br><span class="line">underflow_error     <span class="comment">// 运行时错误：计算下溢 </span></span><br><span class="line">logic_error         <span class="comment">// 程序逻辑错误 </span></span><br><span class="line">domain_error        <span class="comment">// 逻辑错误：参数对象的结果值不存在 </span></span><br><span class="line">invalid_argument    <span class="comment">// 逻辑错误：无效参数 </span></span><br><span class="line">length_error        <span class="comment">// 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range        // 逻辑错误：使用一个超出有效范围的值</span></span><br></pre></td></tr></table></figure>
<p>上述几个类的具体继承关系如下图<br><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250904/pYAn/656X562/exception_inherit.png" alt="656X562&#x2F;exception_inherit.png"></p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>表达式</title>
    <url>/2025/06/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>一般二元运算符都要求两个运算对象的类型相同或者可以转换为相同类型</p>
<p>运算符作用于类类型的对象时，用户可以自行定义含义，即重载运算符。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>C++表达式要么是左值，要么是右值</p>
<ul>
<li>左值：当一个对象被用作左值时，用的是对象的身份（即内存中的位置）</li>
<li>右值：当一个对象被用作右值时，用的是对象的值</li>
</ul>
<p>右值可以用左值来代替，但是反过来不行</p>
<p>使用关键字 decltype 时，如果表达式的求值结果是左值，decltype 作用于该表达式（不是变量）得到一个引用类型</p>
<h2 id="优先级和结合律"><a href="#优先级和结合律" class="headerlink" title="优先级和结合律"></a>优先级和结合律</h2><p>左结合律：如果运算符优先级相同，按照从左到右的方式组合运算对象</p>
<p><strong>赋值运算符满足的是右结合律</strong></p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>在一个复合表达式中，各个运算对象的求值顺序是不固定的。</p>
<p><code>cout &lt;&lt; i &lt;&lt; ++i &lt;&lt; end;//错误！未定义的行为，不知道先求 i 还是先求 ++i</code></p>
<p>4种运算符明确规定了运算对象的求值顺序：逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)</p>
<p>处理复合表达式的两个建议：</p>
<ol>
<li>不确定优先级与结合律时使用括号</li>
<li>如果改变了某个运算对象的值，在同一表达式中不要再使用该运算对象。</li>
</ol>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>算术运算符有 3 组，按优先级从高到低依次是</p>
<ol>
<li>+、- ：一元正号与一元负号</li>
<li><ul>
<li>、&#x2F;、% ：乘法、除法、求余</li>
</ul>
</li>
<li>+、- ：加法、减法<br>注意一元正负号的优先级最高，求余也是一种算术运算。</li>
</ol>
<p>整数除法的结果是向零舍入。</p>
<p>求余运算符的运算对象必须是整数，运算结果始终与被除数符号相同</p>
<h1 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h1><ul>
<li>逻辑运算符：！、&amp;&amp;、||。逻辑运算符的作用对象必须是能转换成布尔值的类型</li>
<li>关系运算符：&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, !&#x3D;, &#x3D;&#x3D; ：大于小于的优先级高于等于和不等于</li>
</ul>
<p><strong>&amp;&amp;、||都是短路求值，即先求左值，若无法判定整体布尔值，再求右值</strong></p>
<h2 id="布尔字面值"><a href="#布尔字面值" class="headerlink" title="布尔字面值"></a>布尔字面值</h2><p>使用算术值做条件时直接用，不要与布尔值做比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a);<span class="comment">//正确 </span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="literal">true</span>);<span class="comment">//错误：会将 true 先转换为 int 再比较，比较结果是不相等</span></span><br></pre></td></tr></table></figure>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>赋值运算符的左侧对象必须是一个可修改的左值</p>
<p>C++ 11 允许使用花括号括起来的初始值列表作为右侧运算对象。初始化列表可以为空，此时将进行值初始化。</p>
<p>赋值运算符满足右结合律。同时优先级较低</p>
<p>复合赋值运算符只求值一次，而普通运算符需要两次。(a&#x3D;a+1 要先求一次 a+1，再将结果赋值给 a)</p>
<p><code>+=; -=; *=; /=; %=; &lt;&lt;=; &gt;&gt;=; &amp;=; ^=; |=;</code></p>
<h1 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h1><h2 id="前置版本"><a href="#前置版本" class="headerlink" title="前置版本"></a>前置版本</h2><p>首先将运算对象加1，再将改变后的对象作为求值结果</p>
<h2 id="后置版本"><a href="#后置版本" class="headerlink" title="后置版本"></a>后置版本</h2><p>也是将运算对象加 1，但是求值结果是运算对象改变之前那个值的副本</p>
<blockquote>
<p>[!NOTE] 关键区别<br>前置版本将对象本身作为左值返回，后置版本将对象的原始值的副本返回。</p>
<p>前置版本直接返回改变了的运算对象，后置版本需要将原始值保存下来以便于返回，是一种浪费。</p>
<p>整体而言，后置版本对于整数和指针来说影响不大，但是对于迭代器而言消耗巨大</p>
</blockquote>
<h2 id="在一条语句中混用解引用和递增运算符"><a href="#在一条语句中混用解引用和递增运算符" class="headerlink" title="在一条语句中混用解引用和递增运算符"></a>在一条语句中混用解引用和递增运算符</h2><p><code>*p++</code> ：p++将 p 的值加一，然后返回 p 的初始值的副本作为求值结果用于解引用。(递增运算符优先级高于解引用)</p>
<p>这是一种提倡的写法，更加简洁，应该习惯于这种写法。</p>
<h1 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h1><p>对于一个指针而言，点运算符和箭头运算符都可以用来访问成员。</p>
<p><code>ptr-&gt;mem 等价于 (*ptr)-&gt;mem</code></p>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><p>cond ? expr1 : expr2。</p>
<p>可以嵌套使用<br><code>finalgrade = (grade&gt;90) ? &quot;high pass&quot; : (grade&lt;60) ? &quot;fail&quot; : &quot;pass&quot;;</code></p>
<p>条件运算符优先级非常低，一般都要加括号</p>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算符作用于整数类型的对象。</p>
<p>位运算符有六种：位求反、位与、位或、位异或、左移、右移</p>
<p><code>~a; a&amp;b; a|b; a^b; a&lt;&lt;2; a&gt;&gt;2</code></p>
<p>如果运算对象是个小整型，会被自动提升为较大的整型类型</p>
<p>可以带符号，也可以不带。如果不带，那么运算结果是固定的，否则要看机器</p>
<p><strong>左移操作处理带符号值是未定义行为</strong></p>
<p>在 C++ 中，建议仅用位运算符来处理无符号类型。</p>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>使用移位运算符，移动的位数必须严格小于结果的位数，否则会产生未定义的行为</p>
<p><code>&lt;&lt;</code>运算符在右侧插入 0，左侧移动超出边界的值舍弃掉。</p>
<p><code>&gt;&gt;</code>运算符处理无符号数时在左侧插入 0，右侧移动超出边界的值舍弃掉。</p>
<p><code>&gt;&gt;</code>运算符处理有符号数时可能在左侧插入 0 也可能插入符号位的副本，由机器决定使用哪种方式</p>
<p>标注IO库里重载了这两个运算符，使得可以接受输入输出流。</p>
<p>重载后满足左结合律</p>
<h2 id="位求反、位与、位或、位异或"><a href="#位求反、位与、位或、位异或" class="headerlink" title="位求反、位与、位或、位异或"></a>位求反、位与、位或、位异或</h2><p>这几种运算符处理 char 时，都会把 char 类型的运算对象首先零扩展提升成 int 类型再进行位运算。</p>
<h1 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h1><p>sizeof返回一个表达式或者一个类型名字所占的字节数，值为size_t类型</p>
<p>对数组执行sizeof运算将得到数组所占的空间，这里不会把数组转换为指针进行处理</p>
<p>对指针执行sizeof运算将得到指针类型的大小，8</p>
<p>如果对string或者vector执行sizeof只返回该类型固定部分的大小，不会计算对象中的元素占多少空间</p>
<blockquote>
<p>[!Hint] 可以用 sizeof 获得数组中元素的个数<br><code>sizeof(arr)/sizeof(*arr);//返回的是数组 arr 的元素数量</code></p>
</blockquote>
<h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><p>在 for 循环中可以用逗号分隔两个不同的条件，或者定义多个值（类型完全相同）<br><code>for(int i=0,j = 0; i!=n; i++,j++)</code></p>
<p><strong>注意，如果在条件判断的部分用逗号分割了若干部分，则只会返回最后一个条件判定的布尔值</strong></p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>c++ 不会直接将两个不同类型的值相加，会先通过类型转换把运算对象的类型统一后再求值</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><ul>
<li>比int类型小的整型值转换为int类型或者更大的整数类型</li>
<li>在条件里，把非布尔值转换成布尔值</li>
<li>初始化过程中，初始值转换为变量的类型</li>
<li>赋值时，右侧运算对象转换成左侧类型</li>
<li>算数运算或关系运算的运算对象有多种类型，转换成一种（一般取最宽的那种）</li>
</ul>
<h2 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h2><p>整型提升把小整数类型（包括 char、bool等）转换成较大的整数类型。如果 int 可以就转换成 int，否则提升成 unsigned int 类型</p>
<p>如果一个是无符号一个带符号。如果无符号类型不小于带符号类型（比如都是 4 字节），则带符号转换为无符号</p>
<p>如果无符号类型小于带符号，转换结果依赖机器。尽量避免这种操作。</p>
<h2 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h2><ol>
<li>数组转换为指针：大多数情况下数组自动转换成指向数组首元素的指针。（decltype关键字参数、取地址符(&amp;)、sizeof、typeid都不会发生这种转换）</li>
<li>指针的转换：0 或 nullptr 都能转换成任意指针类型。指向非常量的指针能转换成 void*。指向所有对象的指针都能转换成 const void*</li>
<li>转换成常量：指向非常量的指针转换成指向相应常量类型的指针</li>
<li>类类型的转换：<ol>
<li><code>while(cin&gt;&gt;s);//将 cin 转换为 bool 值</code></li>
<li><code>string s = &quot;value&quot;;//将 c 风格字符串转换为 string</code></li>
</ol>
</li>
</ol>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p>使用强制类型转换，非常危险，一般考虑能否用其他方式避免</p>
<p><code>castname&lt;type&gt;(expression);</code></p>
<p>有以下四种：</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static cast"></a>static cast</h3><p>任何类型转换，只要不包含底层const，都可以用static cast</p>
<p><code>double slope = static_cast&lt;double&gt;(j)/i; //将 j 转换成 double 以便执行浮点数除法</code></p>
<p>当把较大的类型转换为较小的类型时，static_cast 很有用。这时它告诉读者和编译器：我们知道且不在乎精度损失。平时编译器会给警告，显式转换后就不警告了</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const cast"></a>const cast</h3><p>只能改变对象的底层const，可以去掉或增加const性质</p>
<p>只有const cast可以改变表达式的常量属性，其他均不可以</p>
<p>cosnt_cast 常用于有函数重载的上下文中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; s; </span><br><span class="line"><span class="keyword">const_cast</span> &lt;<span class="type">const</span> string&amp;&gt; (s);<span class="comment">// 将 s 转换为常量引用 </span></span><br><span class="line"><span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);<span class="comment">// 将 s 转换回非常量引用</span></span><br></pre></td></tr></table></figure>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>依赖于机器，门槛高而且危险，不要用</p>
<h3 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h3><p>本质上采用 const_cast、static_cast 或 reinterpret_cast 中的一种。</p>
<p>旧式与新式相比没那么清晰明了，如果出现问题，追踪困难</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(a);<span class="comment">// 函数形式的强制类型转换 </span></span><br><span class="line">(<span class="type">int</span>)a;<span class="comment">// c 语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure>
<h1 id="附录：优先级表"><a href="#附录：优先级表" class="headerlink" title="附录：优先级表"></a>附录：优先级表</h1><p><img src="https://tc.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250903/ZzOK/627X605/priority_level_1.png" alt="627X605&#x2F;priority_level_1.png"></p>
<p><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250903/N7CE/631X880/priority_level_2.png" alt="631X880&#x2F;priority_level_2.png"></p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>线程模块-知识储备</title>
    <url>/2024/07/01/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97-%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<p>先做一点基础的线程知识介绍（也算刚考完试做个总结）</p>
<span id="more"></span>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251005/ULgi/1536X1024/memory_level.png" alt="1536X1024&#x2F;memory_level.png"></p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>假设CPU要读取某个内存地址的数据：</p>
<h3 id="寄存器检查"><a href="#寄存器检查" class="headerlink" title="寄存器检查"></a>寄存器检查</h3><ul>
<li>CPU首先查看这个数据是不是已经在<strong>寄存器</strong>里（最快的存储单元）。</li>
<li>若在寄存器中，直接读取，延迟极低（几个时钟周期内）。</li>
</ul>
<h3 id="L1-Cache（一级缓存）"><a href="#L1-Cache（一级缓存）" class="headerlink" title="L1 Cache（一级缓存）"></a>L1 Cache（一级缓存）</h3><ul>
<li>若寄存器没有，CPU从<strong>L1 Cache</strong>中查找。</li>
<li>L1分为两部分：<strong>L1D（数据）</strong> 和 <strong>L1I（指令）</strong></li>
<li>命中（Hit）：直接读取。</li>
<li>未命中（Miss）：进入下一级。</li>
</ul>
<h3 id="L2-Cache（二级缓存）"><a href="#L2-Cache（二级缓存）" class="headerlink" title="L2 Cache（二级缓存）"></a>L2 Cache（二级缓存）</h3><ul>
<li>查找L2 Cache（比L1大、速度稍慢）。</li>
<li>若命中，则把数据传回CPU，并且通常也更新L1。</li>
</ul>
<h3 id="L3-Cache（三级缓存）"><a href="#L3-Cache（三级缓存）" class="headerlink" title="L3 Cache（三级缓存）"></a>L3 Cache（三级缓存）</h3><ul>
<li>若L2未命中，CPU访问共享的<strong>L3 Cache</strong>（多核共享，容量更大）。</li>
<li>命中：把数据拷回L2和L1供CPU使用</li>
</ul>
<h3 id="主存（DRAM）"><a href="#主存（DRAM）" class="headerlink" title="主存（DRAM）"></a>主存（DRAM）</h3><ul>
<li>如果三级缓存都未命中（称为“三次Cache Miss”），CPU才会：<ul>
<li>通过**内存控制器（Memory Controller）**访问主存（DRAM）。</li>
<li>主存的访问延迟可达几百个时钟周期（相对Cache非常慢）。</li>
<li>数据取回后，会先填充到各级Cache，再给CPU使用。</li>
</ul>
</li>
</ul>
<h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>如果内存中也没有，即涉及到键盘等输入或者就是需要从磁盘读取，则需要继续访问SSD</p>
<h3 id="表格所示"><a href="#表格所示" class="headerlink" title="表格所示"></a>表格所示</h3><table>
<thead>
<tr>
<th>层级</th>
<th>访问延迟（时钟周期）</th>
<th>容量</th>
<th>速度</th>
<th>成本</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1</td>
<td>极小</td>
<td>极快</td>
<td>极高</td>
</tr>
<tr>
<td>L1 Cache</td>
<td>2–4</td>
<td>数十 KB</td>
<td>很快</td>
<td>高</td>
</tr>
<tr>
<td>L2 Cache</td>
<td>10–20</td>
<td>数百 KB</td>
<td>快</td>
<td>中高</td>
</tr>
<tr>
<td>L3 Cache</td>
<td>30–60</td>
<td>数 MB</td>
<td>较慢</td>
<td>中</td>
</tr>
<tr>
<td>主存 (DRAM)</td>
<td>100–300</td>
<td>GB级</td>
<td>慢</td>
<td>低</td>
</tr>
<tr>
<td>SSD&#x2F;HDD</td>
<td>10⁵–10⁷</td>
<td>TB级</td>
<td>极慢</td>
<td>极低</td>
</tr>
</tbody></table>
<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><p>CPU时间片是指操作系统调度程序为每个可运行进程分配的一段<strong>固定长度的CPU时间</strong>。</p>
<ul>
<li>当进程在这段时间内<strong>未执行完</strong>，操作系统会<strong>剥夺其CPU使用权</strong>，将其放回就绪队列；</li>
<li>然后CPU切换到下一个进程；</li>
<li>如果进程在时间片内<strong>执行完毕</strong>，则主动释放CPU</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，</p>
<p>然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。<br>这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<h1 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h1><p>只是稍微介绍一下概念以及几种锁的种类，深入了解请移步并发编程的部分</p>
<h2 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h2><p>进程是操作系统分配资源的基本单位，每个进程独享属于自己的文件描述符、存储器资源等等。</p>
<p>线程是操作系统进行调度的基本单位，一个进程可以有多个线程，线程之间是共享所属进程的资源的。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥是进程(线程)之间的间接制约关系。</p>
<p>当一个进程(线程)进入临界区使用临界资源时，另一个进程(线程)必须等待。 只有当使用临界资源的进程(线程)退出临界区后，这个进程(线程)才会解除阻塞状态。</p>
<blockquote>
<p>[!NOTE] 临界资源<br>对于某些资源来说，其在同一时间只能被一个进程所占用。 这些一次只能被一个进程所占用的资源就是所谓的临界资源。</p>
</blockquote>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步是进程(线程)之间的直接制约关系。 </p>
<p>是指多个相互合作的进程(线程)之间互相通信、互相等待，这种相互制约的现象称为进程(线程)的同步</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>我觉得在并发管理中应该认为<code>mutex</code>是互斥量，当上锁后才是互斥锁</p>
<p>这是最基础的锁。<code>std::mutex</code> 保证在任何时刻，只有一个线程能够获得锁，从而进入由它保护的临界区（Critical Section）。</p>
<p><strong>特点</strong>:</p>
<ul>
<li>独占式：一个线程获取锁之后，其他线程必须等待它释放锁。</li>
<li>非递归：同一个线程不能在释放之前再次获取同一个 <code>std::mutex</code>，否则会造成死锁。</li>
</ul>
<p><strong>使用方法</strong>: 直接调用 <code>lock()</code> 和 <code>unlock()</code> 方法。但这种方式很危险，如果在 <code>lock()</code> 和 <code>unlock()</code>  之间发生异常，<code>unlock()</code> 将不会被调用，导致锁无法释放，所有等待该锁的线程都会被永久阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; // 创建一个互斥锁实例</span><br><span class="line">int shared_counter = 0;</span><br><span class="line"></span><br><span class="line">void increment() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">        mtx.lock(); // 获取锁</span><br><span class="line"></span><br><span class="line">        // --- 临界区开始 ---</span><br><span class="line"></span><br><span class="line">        shared_counter++;</span><br><span class="line"></span><br><span class="line">        // --- 临界区结束 ---</span><br><span class="line"></span><br><span class="line">        mtx.unlock(); // 释放锁</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(increment);</span><br><span class="line">    std::thread t2(increment);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Shared counter: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl; // 输出应该是 20000</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><strong>条件变量（Condition Variable）</strong> 是一种<strong>线程间通信机制</strong>，允许一个线程在某个条件不满足时<strong>进入等待状态（阻塞）</strong>，直到另一个线程<strong>通知它条件已满足</strong>。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cv.wait(lock)</code></td>
<td>线程阻塞，并释放锁</td>
</tr>
<tr>
<td><code>cv.notify_one()</code></td>
<td>唤醒一个等待线程</td>
</tr>
<tr>
<td><code>cv.notify_all()</code></td>
<td>唤醒所有等待线程</td>
</tr>
<tr>
<td>必须持有锁</td>
<td>修改条件变量所依赖的共享状态时，必须先加锁</td>
</tr>
<tr>
<td>防止伪唤醒</td>
<td>使用 <code>cv.wait(lock, predicate)</code> 版本更安全</td>
</tr>
<tr>
<td>典型用途</td>
<td>生产者-消费者模型、线程池任务队列等</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件成立</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;条件满足，开始执行任务\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>C++ 标准库<strong>早期（C++11、C++14、C++17）没有内置信号量</strong>，但从 <strong>C++20</strong> 开始，标准库正式引入了 <strong>信号量（<code>std::counting_semaphore</code> 和 <code>std::binary_semaphore</code>）</strong>。</p>
<hr>
<h3 id="标准信号量"><a href="#标准信号量" class="headerlink" title="标准信号量"></a>标准信号量</h3><p>头文件：<code>#include &lt;semaphore&gt;</code></p>
<h4 id="1-std-counting-semaphore"><a href="#1-std-counting-semaphore" class="headerlink" title="1. std::counting_semaphore"></a>1. <code>std::counting_semaphore</code></h4><ul>
<li>是通用的<strong>计数信号量</strong>。</li>
<li>内部有一个整型计数器，控制可用资源数。<br>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span>  </span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;3&gt; <span class="title">sem</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 最大资源数3，初始值3  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;     </span><br><span class="line">	sem.<span class="built_in">acquire</span>(); <span class="comment">// P操作，尝试获取资源    </span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; working\n&quot;</span>;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));     </span><br><span class="line">	sem.<span class="built_in">release</span>(); <span class="comment">// V操作，释放资源 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(task, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(task, <span class="number">2</span>)</span>, <span class="title">t3</span><span class="params">(task, <span class="number">3</span>)</span>, <span class="title">t4</span><span class="params">(task, <span class="number">4</span>)</span></span>;     </span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>(); t<span class="number">3.</span><span class="built_in">join</span>(); t<span class="number">4.</span><span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最多同时有3个线程能执行“工作”，第4个线程会阻塞直到有资源释放。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-std-binary-semaphore"><a href="#2-std-binary-semaphore" class="headerlink" title="2. std::binary_semaphore"></a>2. <code>std::binary_semaphore</code></h4><ul>
<li>相当于最大计数为 1 的信号量，也就是“二元信号量”（互斥信号量）。</li>
<li>类似于互斥锁，但可以手动 release，而不需要RAII封装。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="function">std::binary_semaphore <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;     </span><br><span class="line">	sem.<span class="built_in">acquire</span>();     </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; in critical section\n&quot;</span>;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); </span><br><span class="line">	sem.<span class="built_in">release</span>(); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(work, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(work, <span class="number">2</span>)</span></span>;     </span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁是一对互斥锁，分为读锁和写锁。 </p>
<p>读锁和写锁互斥，让一个线程在进行读操作时，不允许其他线程的写操作，但是不影响其他线程的读操作。 当一个线程在进行写操作时，不允许任何线程进行读操作或者写操作。</p>
<blockquote>
<p>[!NOTE] 使用<br>考虑到RAII，虽然读写锁本身提供了对应的加锁和解锁方式，但是还是用提供的RAII锁类，帮助<br>自动管理锁的获取与释放</p>
</blockquote>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>对应操作</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::unique_lock&lt;std::shared_mutex&gt;</code></td>
<td>写锁</td>
<td>独占修改数据</td>
</tr>
<tr>
<td><code>std::shared_lock&lt;std::shared_mutex&gt;</code></td>
<td>读锁</td>
<td>并发只读访问</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁是一种<strong>忙等待锁（busy waiting lock）</strong>：</p>
<ul>
<li>当线程尝试获取锁时，如果锁已被占用，它<strong>不会挂起（不睡眠）</strong>，<br>  而是一直<strong>在循环中检查锁是否可用</strong>。</li>
<li>直到锁可用时立即获取，从而<strong>避免线程上下文切换</strong>的开销。</li>
</ul>
<p>适合场景：</p>
<ul>
<li>锁持有时间极短；</li>
<li>线程数量少；</li>
<li>临界区工作量小；</li>
<li>不希望发生线程切换。<br>不适合：</li>
<li>临界区耗时较长；</li>
<li>核心数量较少（容易浪费CPU）。</li>
</ul>
<p>没有提供标准库实现，但是可以通过<code>atomic_flag</code>实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果锁被其他线程持有，则等待（自旋）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in the critical section.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.<span class="built_in">clear</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(critical_section)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>线程模块-代码</title>
    <url>/2024/07/04/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="pthread的封装"><a href="#pthread的封装" class="headerlink" title="pthread的封装"></a>pthread的封装</h1><h2 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h2><p>首先我们主要是面向对象编程。面向对象编程有三个特点：【封装】、【继承】、【多态】。</p>
<p>这里封装pthread是为了使用上更方便，因为虽然pthread提供了以下的一些功能：【Thread】,【Semaphore】,【Mutex】,【RWMutex】,【Spinlock】等</p>
<p>但是都是最基本的功能，而我们开发中往往是多个功能相互结合相互配合着来使用的。</p>
<p>这里封装是为了提供一些新的功能接口供方便使用</p>
<h2 id="thread-h"><a href="#thread-h" class="headerlink" title="thread.h"></a>thread.h</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Thread</span>(std::function&lt;<span class="built_in">void</span>()&gt; cb, <span class="type">const</span> std::string&amp; name);</span><br><span class="line">	~<span class="built_in">Thread</span>();</span><br><span class="line">	<span class="function"><span class="type">pid_t</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;<span class="comment">// 线程ID</span></span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;<span class="comment">//线程结合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 获取系统分配的线程id</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">pid_t</span> <span class="title">GetThreadId</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取当前所在线程	</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Thread* <span class="title">GetThis</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取当前线程的名字</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 设置当前线程的名字</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 线程函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">run</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">pid_t</span> m_id = <span class="number">-1</span>;<span class="comment">//进程的id</span></span><br><span class="line">	<span class="type">pthread_t</span> m_thread = <span class="number">0</span>;<span class="comment">//线程</span></span><br><span class="line">	<span class="comment">// 线程需要运行的函数</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; m_cb;</span><br><span class="line">	std::string m_name;<span class="comment">//线程的name</span></span><br><span class="line">	Semaphore m_semaphore;<span class="comment">//引入信号量的类来完成线程的同步创建。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里涉及到的信号量封装会在后面介绍</p>
<h2 id="thread-cpp"><a href="#thread-cpp" class="headerlink" title="thread.cpp"></a>thread.cpp</h2><p>初始化时通过pthread_create()绑定run函数为线程的入口函数。</p>
<p>在这里run方法负责初始化线程和真正调用线程需要运行任务(函数对象cb)，</p>
<p>使用Semaphore类控制线程初始化的同步，保证所有的线程都能初始化，防止未初始化的线程出现，</p>
<p>GetThreadId()主要是使用系统调用获取真实的线程id，和getpid()返回的线程ID是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycoroutine &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程信息</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> Thread* t_thread          = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> std::string t_thread_name = <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Thread::GetThreadId</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">syscall</span>(SYS_gettid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Thread* <span class="title">Thread::GetThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">Thread::GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_thread_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::SetName</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_thread) &#123;</span><br><span class="line">        t_thread-&gt;m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    t_thread_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(std::function&lt;<span class="built_in">void</span>()&gt; cb, <span class="type">const</span> std::string &amp;name): </span><br><span class="line"><span class="built_in">m_cb</span>(cb), <span class="built_in">m_name</span>(name) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将新创建线程的入口函数绑定到run</span></span><br><span class="line">    <span class="type">int</span> rt = <span class="built_in">pthread_create</span>(&amp;m_thread, <span class="literal">nullptr</span>, &amp;Thread::run, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (rt) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;pthread_create thread fail, rt=&quot;</span> &lt;&lt; rt &lt;&lt; <span class="string">&quot; name=&quot;</span> &lt;&lt; name;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程函数完成初始化</span></span><br><span class="line">    m_semaphore.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构时对线程分离以确定会自动销毁</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_thread) &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread);</span><br><span class="line">        m_thread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_thread) &#123;</span><br><span class="line">	    <span class="comment">// 因为不关心返回值去哪，所以直接设置为nullptr</span></span><br><span class="line">        <span class="type">int</span> rt = <span class="built_in">pthread_join</span>(m_thread, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;pthread_join failed, rt = &quot;</span> &lt;&lt; rt &lt;&lt; <span class="string">&quot;, name = &quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;pthread_join error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止后续再次被join</span></span><br><span class="line">        m_thread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Thread::run</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    Thread* thread = (Thread*)arg;</span><br><span class="line"></span><br><span class="line">    t_thread       = thread;</span><br><span class="line">    t_thread_name  = thread-&gt;m_name;</span><br><span class="line">    thread-&gt;m_id   = <span class="built_in">GetThreadId</span>();</span><br><span class="line">    <span class="comment">//pthread_self()获取当前线程的ID，设置m_name是前15个字节取，因为linux设置最多15</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(<span class="built_in">pthread_self</span>(), thread-&gt;m_name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">15</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; cb;</span><br><span class="line">    cb.<span class="built_in">swap</span>(thread-&gt;m_cb); <span class="comment">// swap -&gt; 可以减少m_cb中只能指针的引用计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化完成</span></span><br><span class="line">    thread-&gt;m_semaphore.<span class="built_in">signal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="static-thread-local又是什么意思？"><a href="#static-thread-local又是什么意思？" class="headerlink" title="static thread_local又是什么意思？"></a>static thread_local又是什么意思？</h2><p>static代表生命周期知道程序运行结束时候销毁，<strong>被 <code>thread_local</code> 修饰的变量，在每个线程中都有一个独立的副本</strong>。</p>
<h2 id="对pthread-create、pthread-detch、pthread-join的详解"><a href="#对pthread-create、pthread-detch、pthread-join的详解" class="headerlink" title="对pthread_create、pthread_detch、pthread_join的详解"></a>对pthread_create、pthread_detch、pthread_join的详解</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><p>&#96;int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (<em>start_rtn)(void</em>),void *restrict arg);</p>
<ul>
<li>输入参数： tidp:填入pthread_t类型参数。  </li>
<li>attr:通常设置为NULL，用于定制各种不同的线程属性。  </li>
<li>start_rtn:新创建线程的入口函数由此绑定。无参数把arg设置为NULL即可  </li>
<li>返回值：成功返回0，否则返回错误码。</li>
</ul>
<p>线程的入口函数最开始都要先获取传入的参数:&#96;比如pthread_create(&amp;m_thread, nullptr, &amp;Thread::run, this);</p>
<p>在run函数里先执行&#96;Thread* thread &#x3D; (Thread*)arg;</p>
<h3 id="pthread-detch"><a href="#pthread-detch" class="headerlink" title="pthread_detch"></a>pthread_detch</h3><p>目的是为了确保线程在结束后能够正确的释放资源，而不需要主线程或其他线程进行join操作。一般适用的场景是在子线程要脱离主线程的管理，并且主线程不需要担心其资源的释放，简化了使用的复杂性。  </p>
<p>避免了内存泄漏防止忘记调用join导致的内存泄露  </p>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>pthread_Join是POSIX线程库的一个函数，用于等待一个线程的终止并回收它的资源  </p>
<p>值得说的一点就是一般都可以写nullptr。如果你需要接受某个实际的值，那就写一个实际的指针去接受它。</p>
<h1 id="信号量的封装"><a href="#信号量的封装" class="headerlink" title="信号量的封装"></a>信号量的封装</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;                </span><br><span class="line">    std::condition_variable cv;    </span><br><span class="line">    <span class="type">int</span> count;                   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 信号量初始化为0</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Semaphore</span><span class="params">(<span class="type">int</span> count_ = <span class="number">0</span>)</span> : count(count_) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// P操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123; </span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// wait for signals</span></span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// V操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();  <span class="comment">// signal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>分层结构</title>
    <url>/2025/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>计算机网络的模型主要有OSI模型和TCP&#x2F;IP模型两种，本文将分别介绍对应模型中每一层的功能与最终的对比。</p>
<span id="more"></span>
<h1 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h1><ul>
<li>协议数据单元（PDU）：对等层之间传送的数据单位。第n层的记为n-PDU。各层PDU都分为服务数据单元和协议控制信息</li>
<li>服务数据单元（SDU）：层与层之间交换的数据单位，第n层的SDU记为n-SDU</li>
<li>协议控制信息（PCI）：控制协议操作的信息。第n层的PCI记为n-PCI<br>每层的协议数据单元都有额外名称，如物理层的称为比特流，链路层的称为帧，网络层的称为分组，传输层的称为报文段</li>
</ul>
<p>在各层间传输数据时满足：n-SDU + n-PCI &#x3D; n-PDU &#x3D; (n-1)-SDU</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>为了在网络中进行数据交换而建立的规则、标准或约定称为网络协议，是控制在对等实体间进行通信的规则的集合，是水平的，不对等实体间没有协议。</p>
<p>由以下三部分组成：</p>
<ul>
<li>语法：数据与控制信息的格式</li>
<li>语义：即需要发出何种控制信息、完成何种动作以及做出何种应答</li>
<li>同步：执行各种操作的条件、时序关系等，即事件实现顺序的详细说明</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>同一节点内相邻两层的实体交换信息的逻辑接口称为服务访问点（SAP），每层只能在紧邻的层间定义接口，而不能跨层定义。</p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>指下层为紧邻的上层提供的功能调用，是垂直的。对等实体在协议的控制下，使本层能为上层提供服务。</p>
<p>可以分为以下三种：</p>
<ul>
<li>面向连接和无连接服务：<ul>
<li>面向连接服务中，通信双方必须先建立连接，分配相应的资源，以保证通信正常进行，传输结束后释放连接和占用的资源。</li>
<li>无连接服务中，通信双方不需要提前建立连接，发送数据时直接发送。</li>
</ul>
</li>
<li>可靠服务和不可靠服务<ul>
<li>可靠服务：指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</li>
<li>不可靠服务：指网络只是尽量让数据正确、可靠地传送到目的地</li>
</ul>
</li>
<li>有应答服务和无应答服务<ul>
<li>有应答服务：指接收方在收到数据后向发送方给出相应的应答，由传输系统内部自动实现</li>
<li>无应答服务：接收方收到数据后不自动给出应答。如果需要，由高层实现</li>
</ul>
</li>
</ul>
<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>有七层，分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>传输单位是比特，功能是在物理介质上为数据端设备透明地传输原始比特流。但是注意传输信息所用的物理介质（如光缆、无线信道等等）不在物理层协议内</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>传输单位是帧，功能是将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，同时实现节点间的差错控制和流量控制的功能</p>
<p>广播式网络还要处理如何控制对共享信道的访问</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>传输单位是数据报。主要任务是将网络层的协议数据单元（分组）从源主机传输到目的主机。关键在于对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>负责两个进程间的通信，提供端到端的流量控制、差错控制、连接建立和释放、可靠传输管理等服务。</p>
<p>数据链路层提供点对点通信，可以理解为主机与主机的通信（主机通过硬件地址或IP地址标识）</p>
<p>端到端的通信指运行在不同主机内两个进程间的通信，每个进程都由一个端口来标识</p>
<p>因为一台主机可以运行多个进程，因此传输层具有复用和分用的功能。复用指多个进程可以同时使用传输层的服务，分用指传输层将收到的信息分别交付给上层的对应进程</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>允许不同主机上各个进程进行会话，为进程建立连接，并在连接上有序传输数据，这就是会话。</p>
<p>负责管理主机间的会话进程，包括建立、管理和终止进程间的会话。</p>
<p>包含一种称为检查点的机制来维持可靠会话，使通信会话在通信失效时从检查点继续恢复通信。</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>主要处理不同主机间交换信息的方式，此外数据压缩、加密和解密也是表示层的功能</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>是用户与网络的接口</p>
<h1 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h1><p>分为五层：物理层、链路层、网络层、传输层、应用层</p>
<p>主要内容上面已经有对应的了，只不过应用层整合了会话层、表示层、应用层三层的功能</p>
<h1 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h1><ul>
<li>OSI模型精确定义了服务、协议与接口。但是TCP&#x2F;IP模型没有明确区分</li>
<li>OSI模型先有模型，后有协议规范，通用性好。TCP&#x2F;IP模型先有协议栈后建立模型，不适合其他非TCP&#x2F;IP的网络</li>
<li>OSI模型在网络层支持无连接和面向连接的服务，但是在传输层仅有面向连接的服务。而TCP&#x2F;IP模型认为可靠性是端到端的问题，因此在网络层仅有一种无连接通信模式，但是在传输层支持无连接和面向连接两种模式</li>
<li>OSI模型有七层，而TCP&#x2F;IP模型分为五层。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络复习</category>
      </categories>
  </entry>
  <entry>
    <title>绪论</title>
    <url>/2025/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>本文将介绍计算机网络的概念以及进行信息交换的方式</p>
<span id="more"></span>
<h1 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h1><ul>
<li>当前全球最大的、开放的、由众多网络和路由器互连而成的特定计算机网络，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET</li>
</ul>
<h1 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h1><ul>
<li>组成部分：<ul>
<li>硬件：主要有主机（也被称作端系统）、通信链路（如光纤）、交换设备（如路由器、交换机）和通信处理机（如网卡）等组成</li>
<li>软件：主要包括各种实现资源共享的软件和方便用户使用的各种工具软件</li>
<li>协议：是计算机网络的核心，规定了网络传输数据时所遵循的规范</li>
</ul>
</li>
<li>工作方式：可以分为边缘部分和核心部分<ul>
<li>边缘部分：所有连接到互联网上的供用户直接使用的主机组成，用来进行通信（如传输数据、音频和视频）和资源共享</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务</li>
</ul>
</li>
<li>功能组成<ul>
<li>通信子网：由各种传输介质、通信设备和相应的网络协议组成，使网络具有数据传输、交换、控制和存储的能力，实现联网计算机间的数据通信</li>
<li>资源子网：实现资源共享功能的设备及软件的集合，向网络用户提供共享其他计算机的硬件资源、软件资源和数据资源的服务</li>
</ul>
</li>
</ul>
<h1 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h1><ul>
<li>数据通信：是最基本和最重要的功能，用来实现联网计算机间各种信息的传输。</li>
<li>资源共享：既可以是软件或数据的共享，也可以是硬件的共享。使计算机中的资源互通有无、分工协作，极大提高了硬件资源、软件资源和数据资源的利用率</li>
<li>分布式处理：当某个计算机系统负荷过重时，可将其处理的复杂任务分配给网络中其他计算机系统，从而利用空闲计算机资源提高整个系统的利用率</li>
<li>提高可靠性：计算机网络中各台计算机可以通过网络互为替代机</li>
<li>负载均衡：将工作任务均衡分配给计算机网络中各台计算机</li>
</ul>
<h1 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h1><p>分为三步：</p>
<ul>
<li>建立连接：进行数据传输前，两个用户必须先建立一条专用的物理通信路径，由通信双方之间的交换设备和链路逐段连接而成</li>
<li>传输数据：在数据传输过程中，这一物理通信路径始终被两用户独占</li>
<li>释放连接：通信结束后释放通信资源<br>整个通信阶段，比特流连续地从源节点直达目的节点，好像在一个管道中传送，不存在存储转发所耗费的时间</li>
</ul>
<p>优点：</p>
<ul>
<li>通信时延小：通信线路为通信双方专用，数据直达，传输速率高</li>
<li>有序传输：通信时按发送顺序传输数据，不存在失序问题</li>
<li>没有冲突：不同的通信双方有不同的信道</li>
<li>实时性强：一旦建立连接，可以随时通信<br>缺点：</li>
<li>建立连接时间长</li>
<li>线路利用率低：线路被独占，即使空闲也不能供其他用户使用</li>
<li>灵活性差：物理通路中任何一点出现故障，必须重新建立连接</li>
<li>难以实现差错控制：中间节点不具备存储和检验数据的能力，无法发现并纠正错误<br>计算机间的数据传送往往是突发（高频、少量）的，使用电路交换来传送数据时，被用户占用的通信资源在绝大部分时间是空闲的，利用率往往不到10%乃至1%</li>
</ul>
<h1 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h1><p>数据交换的单位是报文，用户数据+原地址+目的地址等信息封装为报文。</p>
<p>采用存储转发的技术，整个报文先传送到相邻的节点，全部存储后查找转发表，转发到下一个节点，如此重复直到目的节点。每个报文可以单独选择到达目的端的路径</p>
<p>优点：</p>
<ul>
<li>无建立连接时延：通信前无需建立连接，用户可以随时发生报文</li>
<li>灵活分配线路：交换节点存储整个报文后，选择一条合适的空闲线路，转发报文。若某条路径故障，可重新选择另一条路径传输</li>
<li>线路利用率高：报文在一段链路上传送时才占用这段链路的通信资源</li>
<li>支持差错控制：交换节点可以对缓存下来的报文进行差错检验<br>缺点：</li>
<li>转发时延高：交换节点要收到所有报文后，才查找转发表进行转发</li>
<li>缓存开销大：报文大小没有限制，要求交换节点有较大的缓存空间</li>
<li>错误处理低效：报文较长时，发生错误概率相对更高，重传整个报文的代价也很大</li>
</ul>
<h1 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h1><p>也采用存储转发技术，但是解决了报文过长的问题</p>
<p>源主机在发送之前，先把较长的报文划分为若干较小的等长数据段，每个数据段前添加一些必要的控制信息（如源地址、目的地址和编号信息）组成的首部，构成分组</p>
<p>源主机将分组发送到分组交换网中，分组交换网的分组交换机收到一个分组后，先缓存，再从首部中提取目的地址，据此查找自己的转发表，再将分组转发给下一个分组交换机。经过多个分组交换机的存储转发后，分组到达目的主机</p>
<p>除了继承报文交换的优点外，还有如下优点：</p>
<ul>
<li>方便存储管理，存储转发开销小。</li>
<li>传输效率高</li>
<li>减少了出错概率和重传代价<br>缺点：</li>
<li>存在存储转发时延</li>
<li>需要额外的信息量</li>
<li>当采用数据报服务时，可能出现失序、丢失或重复分组的情况。如果采用虚电路服务，则没有失序问题，但是有呼叫建立、数据传输和虚电路释放三个过程</li>
</ul>
<h1 id="三种交换方式总结"><a href="#三种交换方式总结" class="headerlink" title="三种交换方式总结"></a>三种交换方式总结</h1><p>当要连续传送大量的数据，且传送时间远大于建立连接时间时，采用电路交换比较合适；从提高整个网络的信道利用率来看，报文交换和分组交换优于电路交换，其中分组交换的时延更小，更为灵活，尤其适合突发式数据传送</p>
<h1 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h1><h2 id="按分布范围"><a href="#按分布范围" class="headerlink" title="按分布范围"></a>按分布范围</h2><ul>
<li>广域网（WAN）：提供长距离通信，运送主机发送的数据，覆盖范围通常是直径几十米到几千千米的区域。是互联网核心部分，连接广域网各节点交换机的链路一般是高速链路，具有较大的通信容量。一般使用交换技术</li>
<li>城域网（MAN）：覆盖范围可以跨越几个街区甚至几个城市，直径为5-50km。多采用以太网技术</li>
<li>局域网（LAN）：一般用主机通过高速线路相连，覆盖范围较小，通常是直径为几十米到几千米的区域。一般使用广播技术</li>
<li>个人区域网（PAN）：指在个人工作的地方将电子设备用无线技术连接起来的网络，也叫无线个人区域网</li>
</ul>
<h2 id="按传输技术"><a href="#按传输技术" class="headerlink" title="按传输技术"></a>按传输技术</h2><ul>
<li>广播式网络：共享一个公共通信信道。当一个计算机发送报文分组时，其他所有计算机都会“收听”到，通过检查目的地址来决定是否接收</li>
<li>点对点网络：每条物理线路连接一对计算机。若通信的两台主机间没有直接相连的线路，则要通过中间节点进行存储转发</li>
</ul>
<h2 id="按拓扑结构"><a href="#按拓扑结构" class="headerlink" title="按拓扑结构"></a>按拓扑结构</h2><p>网络拓扑结构是指由网中节点与通信线路间的几何关系表示的网络结构</p>
<ul>
<li>总线型：单根传输线连接计算机。优点是建网容易、增删节点方便、节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感</li>
<li>星型网络：每个终端或计算机以单独线路与中央设备（一般是路由器或交换机）相连。优点是便于集中控制和管理。缺点是成本高，中央设备对故障敏感</li>
<li>环形网络：所有计算机接口设备连成一个环。最典型的例子是令牌环局域网，既可以是单环也可以是双环。环中信号单向传输</li>
<li>网状网络：每个节点至少有两条路径与其他节点相连，多用在广域网中。有规则型和非规则型两种。优点是可靠性高，缺点是控制复杂、线路成本高</li>
</ul>
<h2 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h2><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="按传输介质"><a href="#按传输介质" class="headerlink" title="按传输介质"></a>按传输介质</h2><p>可以分为有线无线两大类。有线网络可以再分为双绞线网络、同轴电缆网络等。无线网络可以分为蓝牙、微波、无线电等类型</p>
<h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><ul>
<li>速率：指连接到网络上的节点在数字信道上传送数据的速率。单位为b&#x2F;s。较高时可用kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s</li>
<li>带宽：原本表示通信线路允许通过的信号频率范围，单位是Hz。但是在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“最高数据传输速率”的同义语。单位为b&#x2F;s</li>
<li>吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。</li>
<li>时延：指数据从网络的一端传送到另一端所需的总时间。由四部分组成：<ul>
<li>发送时延：从发送第一个比特开始到最后一个比特从本地发送到线路结束。发送时延&#x3D;分组长度&#x2F;发送速率</li>
<li>传播时延：一个比特从链路一端到另一端的时间。传播时延&#x3D;信道长度&#x2F;传播速率</li>
<li>处理时延：分组在交换节点为存储转发而进行的处理所花的时间。</li>
<li>排队时延：分组在路由器的输入或输出队列排队等待的时间</li>
</ul>
</li>
<li>时延带宽积：指发送的第一个比特到达终点时发送端发出了多少比特。时延带宽积&#x3D;传播时延 * 信道带宽</li>
<li>往返时延（RTT）：从发送端发出一个短分组，到发送端收到来自接收端的确认总共经历的时间。包括各中间节点的处理时延、排队时延及转发数据时的发送时延</li>
<li>信道利用率：某个信道有百分之多少的时间有数据通过。太低会浪费网络资源。太高会产生较大的时延，导致网络拥塞。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络复习</category>
      </categories>
  </entry>
</search>
