<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7-24 洛谷题单之排序</title>
    <url>/2025/07/24/7-24/</url>
    <content><![CDATA[<h1 id="P1116-车厢重组-洛谷"><a href="#P1116-车厢重组-洛谷" class="headerlink" title="P1116 车厢重组 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1116">P1116 车厢重组 - 洛谷</a></h1><p>实际上是个冒泡排序的过程，在这中间记录一下交换的次数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">                sum++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">bubbleSort</span>(arr);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1068-NOIP-2009-普及组-分数线划定-洛谷"><a href="#P1068-NOIP-2009-普及组-分数线划定-洛谷" class="headerlink" title="P1068 [NOIP 2009 普及组] 分数线划定 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1068">P1068 [NOIP 2009 普及组] 分数线划定 - 洛谷</a></h1><p>结构体排序罢了，但是最后记得要处理分数一样的情况。只需要从m* 1.5开始直到第一个不一样的即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">candiate</span>&#123;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> candiate &amp;a, <span class="type">const</span> candiate &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;candiate&gt; <span class="title">vec</span><span class="params">(<span class="number">5001</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; vec[i].name &gt;&gt; vec[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    m = m * <span class="number">1.5</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i].score == vec[m - <span class="number">1</span>].score)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m += sum;</span><br><span class="line">    cout &lt;&lt; vec[m<span class="number">-1</span>].score &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        cout &lt;&lt; vec[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; vec[i].score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1012-NOIP-1998-提高组-拼数-洛谷"><a href="#P1012-NOIP-1998-提高组-拼数-洛谷" class="headerlink" title="P1012 [NOIP 1998 提高组] 拼数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1012">P1012 [NOIP 1998 提高组] 拼数 - 洛谷</a></h1><p>具体证明请参照<a href="https://www.luogu.com.cn/problem/solution/P1012">P1012 [NOIP 1998 提高组] 拼数 - 洛谷</a>的第一篇。</p>
<p>对于做出此题而言的关键在于怎么给输入的字符串排序。而且最终的字符串长度是不会有变化的。</p>
<p>一个简单的想法是，<strong>考虑相邻两项是否需要交换</strong></p>
<p><strong>那么就把对字典序贡献最大的放在前面。比较方法只要比较 s1​+s2​ 和 s2​+s1​ 的大小即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vec</span><span class="params">(<span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b &gt; b+a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + n, cmp);</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans += vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-22 洛谷题单之排序</title>
    <url>/2025/07/22/7-22/</url>
    <content><![CDATA[<h1 id="P1177-【模板】排序-洛谷"><a href="#P1177-【模板】排序-洛谷" class="headerlink" title="P1177 【模板】排序 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1177">P1177 【模板】排序 - 洛谷</a></h1><p>主要是练一下手写快排。</p>
<h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p>本部分讲述的是常用的三路快速排序。如果想了解快速排序的更多变种实现方式可以在 <a href="https://oi-wiki.org/basic/quick-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">OI Wiki</a> 中了解。</p>
<p>我们设待排序的序列为一个长度为 n 的序列 a。快速排序的具体原理如下：</p>
<p>首先，在 a 中随机选择一个数 x，之后我们进行如下操作：</p>
<ol>
<li>如果 n&#x3D;0 或 n&#x3D;1，此时根本无需排序，直接退出；</li>
<li>定义三个新的序列 b,c,d；</li>
<li>遍历整个序列 a，将比 x 小的放在 b 内，比 x 大的放在 d 内，和 x 相等的放在 c 内；</li>
<li>将 b,d 按如上过程继续排序。序列 c 中的数由于都相等所以不必排序。</li>
</ol>
<p>可以发现：实际上每一次的排序之后都会通过调用本身来继续排序，这明显就是递归。</p>
<p>通过递归，我们将一个完整的序列经过不断的分解来变成很多个小序列，直到只有一个或没有数为止。<strong>这种排序就是在不断的递归和分解当中来慢慢实现与完成排序</strong></p>
<p>模版代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    T pivot = arr[<span class="built_in">rand</span>() % (right - left + <span class="number">1</span>) + left];</span><br><span class="line">    <span class="type">int</span> i = left, j = left, k = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[k--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, left, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, k + <span class="number">1</span>, right);</span><br><span class="line">	<span class="comment">//j是第一个pivot所在的位置,k是最后一个pivot所在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1923-【深基9-例4】求第-k-小的数-洛谷"><a href="#P1923-【深基9-例4】求第-k-小的数-洛谷" class="headerlink" title="P1923 【深基9.例4】求第 k 小的数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k 小的数 - 洛谷</a></h1><p>通过分治去求。考虑上面的快排，每次分出三个相对有序的序列，可以据此判断出第k小的数在哪个序列中，然后再递归对应的序列即可</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_nth_k</span><span class="params">(vector&lt;T&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right,<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> arr[left];</span><br><span class="line">    T pivot = arr[(right-left) / <span class="number">2</span> + left];</span><br><span class="line">    <span class="type">int</span> i = left, j = left, k = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[k--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; j - left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_nth_k</span>(arr, left, j<span class="number">-1</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; k - left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_nth_k</span>(arr, k<span class="number">+1</span>, right, pos- (k - left + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-23 洛谷题单之排序</title>
    <url>/2025/07/23/7-23/</url>
    <content><![CDATA[<h1 id="P1059-NOIP-2006-普及组-明明的随机数-洛谷"><a href="#P1059-NOIP-2006-普及组-明明的随机数-洛谷" class="headerlink" title="P1059 [NOIP 2006 普及组] 明明的随机数 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1059">P1059 [NOIP 2006 普及组] 明明的随机数 - 洛谷</a></h1><p>可以直接用sort排序后再去重。</p>
<p>但是考虑到最大只有1000，因此可以用桶排。每个桶只需要记录有没有即可</p>
<p>最后stl库中的set可以同时完成去重和排序的目的。</p>
<p>最终我选择的set。代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        s.<span class="built_in">insert</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1093-NOIP-2007-普及组-奖学金-洛谷"><a href="#P1093-NOIP-2007-普及组-奖学金-洛谷" class="headerlink" title="P1093 [NOIP 2007 普及组] 奖学金 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1093">P1093 [NOIP 2007 普及组] 奖学金 - 洛谷</a></h1><p>用结构体存储对应的变量，然后重构cmp即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">score</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> english;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> score &amp;a, <span class="type">const</span> score &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.total != b.total) <span class="keyword">return</span> a.total &gt; b.total;</span><br><span class="line">    <span class="keyword">if</span>(a.chinese != b.chinese) <span class="keyword">return</span> a.chinese &gt; b.chinese;</span><br><span class="line">    <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;score&gt; <span class="title">scores</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt;scores[i].chinese &gt;&gt; scores[i].math &gt;&gt; scores[i].english;</span><br><span class="line">        scores[i].total = scores[i].chinese + scores[i].math + scores[i].english;</span><br><span class="line">        scores[i].id = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;s = scores[i];</span><br><span class="line">        cout &lt;&lt; s.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.total &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1781-宇宙总统-洛谷"><a href="#P1781-宇宙总统-洛谷" class="headerlink" title="P1781 宇宙总统 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P1781">P1781 宇宙总统 - 洛谷</a></h1><p>这是个大整数，因此不能直接排序。但是考虑到C++字符串提供了比较字典序的方法，因此可以将其作为字符串来比较，当然首先要比较长度</p>
<p>因为只需要最大的，所以不需要全部存储，读一个比一次即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> winner = <span class="number">1</span>;</span><br><span class="line">    string vote;</span><br><span class="line">    cin&gt;&gt;vote;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        string current_vote;</span><br><span class="line">        cin &gt;&gt; current_vote;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(current_vote, vote)) &#123;</span><br><span class="line">            vote = current_vote;</span><br><span class="line">            winner = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; winner &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; vote &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-21 代码随想录之数组</title>
    <url>/2025/07/21/day1/</url>
    <content><![CDATA[<h1 id="704-二分查找-力扣（LeetCode）"><a href="#704-二分查找-力扣（LeetCode）" class="headerlink" title="704. 二分查找 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a></h1><p>这是二分查找的模版题。二分查找两种思路：左闭右开和左闭右闭。</p>
<p>在进行二分查找的循环中，循环的条件就是查找的区间要是合法的，即区间内至少有1个元素，例如，在左闭右闭的方法中，[1, 1]中至少有“1”这个元素，区间合法；而对于左闭右开，[1, 1)中没有元素，这个区间就是非法的。</p>
<p>在确认区间合法后，才在区间中取中间值</p>
<p>对于左闭右闭：由于每一次查找都需要在合法区间中寻找，且此次循环的合法区间不能包含上一次循环中已经筛除的值，所以在更新左右端点的值时，左端点的下标为中点下标+1，右端点的下标为中点下标-1。</p>
<p>对于左闭右开：与上面一样，但是此时区间的右端点不在区间内，所以在更新左右端点的值时，左端点的下标为中点下标+1，右端点的下标为中点下标。</p>
<p>注意<br>无论是左闭右闭还是左闭右开，在初始化时都必须要让数组中的所有元素都在初始合法区间内，例如数组nums为{1， 2， 3， 4}， 对于左闭右闭，那么初始的合法区间为[0, nums.size() - 1]，而对于左闭右开，初始的合法区间应该为[0, nums.size())</p>
<p>给出代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="27-移除元素-力扣（LeetCode）"><a href="#27-移除元素-力扣（LeetCode）" class="headerlink" title="27. 移除元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素 - 力扣（LeetCode）</a></h1><p>双指针，慢的指向最后一个非val的下一个元素，快的就一直遍历。每遇到一个非val的元素，就把它赋值给慢指针对应的位置</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] == val)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="977-有序数组的平方-力扣（LeetCode）"><a href="#977-有序数组的平方-力扣（LeetCode）" class="headerlink" title="977. 有序数组的平方 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a></h1><p>最开始想的是从数组左右两边遍历，然后将大的放在右边，小的放在左边。但是如果全是负数就会出错，因为不会有任何一个数的绝对值小于数组最右边那个数，则一旦最右边那个数至于最左边后就不会再交换了。</p>
<p>所以初始一个新的数组，然后从后往前填空，但是不改变原数组元素的顺序</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> pos = r;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[r]) &gt; <span class="built_in">abs</span>(nums[l]))&#123;</span><br><span class="line">                result[pos--] = nums[r] * nums[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result[pos--] = nums[l] * nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-23 代码随想录之链表</title>
    <url>/2025/07/23/day3/</url>
    <content><![CDATA[<h1 id="203-移除链表元素-力扣（LeetCode）"><a href="#203-移除链表元素-力扣（LeetCode）" class="headerlink" title="203. 移除链表元素 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（LeetCode）</a></h1><p>链表的题我个人还是喜欢有一个虚拟的头节点更好。这样便于操作和处理边界情况</p>
<p>在这个题里，维护一个当前节点和当前节点的前一个节点，当前节点值为val时，只需要把前一个节点的next指向当前节点的next即可。</p>
<p><strong>最后返回虚拟头节点的next是因为当链表内全为对应val时，原head节点将被删除</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        ListNode* dumhead = pre;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                ListNode* tmp = cur;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="206-反转链表-力扣（LeetCode）"><a href="#206-反转链表-力扣（LeetCode）" class="headerlink" title="206. 反转链表 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></h1><p>循环的做法比较简单，不赘述</p>
<p>对于递归，考虑设计一个函数，每次翻转两个节点间的指向关系即可。最后的那个节点就是头节点</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">nullptr</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="24-两两交换链表中的节点-力扣（LeetCode）"><a href="#24-两两交换链表中的节点-力扣（LeetCode）" class="headerlink" title="24. 两两交换链表中的节点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></h1><p>依然设置一个虚拟头节点，current指针的下一个节点是需要临时保存的；因为是两两交换  </p>
<p>还有循环停止的条件是current节点和下个节点不能为空</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode* pre = dummyhead;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next; </span><br><span class="line">            cur-&gt;next = temp-&gt;next</span><br><span class="line">            temp-&gt;next = cur;</span><br><span class="line">            pre-&gt;next = temp;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>SQL必知必会</title>
    <url>/2024/10/26/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<p>读过《SQL必知必会》后的总结</p>
<span id="more"></span>

<h1 id="了解SQL"><a href="#了解SQL" class="headerlink" title="了解SQL"></a>了解SQL</h1><h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><p>数据库是保存有组织的数据的容器，通常是一个文件或一组文件</p>
<p>数据库软件是数据库管理系统（DBMS），数据库是通过DBMS创建和操纵的容器</p>
<p>RDBMS指关系型数据库管理系统，是SQL的基础，也是现代数据库系统的基础</p>
<p>RDBMS的数据存储在被称为表(tables)的数据库对象中</p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表是一种结构化的文件，存储在表中的数据是同一种类型的数据或清单。</p>
<p>每一个表有唯一的名字。有一些特性：数据在表中如何存储、存储什么样的数据、数据如何分解等。</p>
<p>模式描述了表或数据库的这些特性信息。</p>
<h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><p>表由列组成，列是表中的一个字段。使用表存储数据时要正确地将数据分解为多个列。</p>
<p>每个列都有相应的数据类型，限定了可存储在该列中地数据种类。</p>
<p>注意：数据类型及其名称的不同是 SQL 不兼容的一个主要原因。</p>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>行是表中的一个记录，表中的数据是按行存储的。</p>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>表中每一行都应该有一列或者几列可以唯一标识自己，这就是表的主键</p>
<p>表中至少有一个主键</p>
<h3 id="作为主键的列需要满足的条件"><a href="#作为主键的列需要满足的条件" class="headerlink" title="作为主键的列需要满足的条件"></a>作为主键的列需要满足的条件</h3><ol>
<li>任意两行不具有相同的主键值</li>
<li>每一行必须有一个主键值（主键列不允许有NULL值）</li>
<li>主键列中的值不允许修改或更新</li>
<li>主键值不能重用（即使被删除后，也不能给以后的新行）<br>当多个列作为主键时，只需要所有的列值的组合是唯一的，单个列的值可以不唯一。</li>
</ol>
<h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><p>SQL(Structured Query Language)：结构化查询语言。SQL 是一种专门用来与数据库沟通的语言。</p>
<p>SQL 不是某个特定数据库供应商专用的语言，几乎所有重要的 DBMS 都支持 SQL，但是不同厂商进行了不同的扩展。</p>
<p>标准 SQL 由 ANSI 标准委员会管理，因此称为 ANSI SQL。</p>
<p>可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。</p>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><p>不区分大小写，但是一般<strong>SQL关键字使用大写，列名和表名使用小写</strong></p>
<h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><p>SQL 语句由简单的英语单词组成，这些单词称为关键字。</p>
<p>每个 SQL 语句由一个或多个关键字构成，关键字不能作为表或列的名字。</p>
<p>多条 SQL 语句必须以分号分割，单条 SQL 语句一般不需要（有的 DBMS 也需要）</p>
<p>处理 SQL 语句时所有的空格都会被忽略，SQL 语句可以写成一行，也可以写成多行。</p>
<p>SQL 语句由子句组成，有些子句是必须的，有些是可选的。一个子句通常由一个关键字加上所提供的数据组成。比如 FROM 子句，WHRER 子句。</p>
<h2 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>SELECT 语句返回的数据是未排序的，可能是记录的添加顺序也可能不是。</p>
<h2 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>不同列名间以逗号分隔</p>
<h2 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>一般除非确实需要每一列，否则不要使用 * 通配符，会降低性能。</p>
<h2 id="检索不同的值"><a href="#检索不同的值" class="headerlink" title="检索不同的值"></a>检索不同的值</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>关键字 DISTINCT 用来区分不同的值。</p>
<p>如果有多行 vend_id 列值相同，只返回其中一行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id, prod_price </span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p>DISTINCT 作用于跟在其后的所有的列，而不是一列。</p>
<p>如果有多行的 vend_id 与 prod_price 两列的列值都相同，则只返回一行。</p>
<h2 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h2><p>只返回前N行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM Products </span><br><span class="line">LIMIT 3;</span><br></pre></td></tr></table></figure>
<p>只返回从m行开始的前N行（下面这个例子返回从第2行开始的4行）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Product </span><br><span class="line">LIMIT 4 OFFSET 2;</span><br></pre></td></tr></table></figure>
<p>有简化版写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Product</span><br><span class="line">LIMIT 4,2;</span><br></pre></td></tr></table></figure>
<h2 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--一条注释 </span><br><span class="line">#一条注释 //这种使用的较少 </span><br><span class="line">/*多行注释*/ //这是多行注释</span><br></pre></td></tr></table></figure>
<h1 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h1><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_id</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY prod_name</span><br></pre></td></tr></table></figure>
<p>按字母顺序进行排序。</p>
<p>ORDER BY 子句中使用的列一般是将要显示的列，但是也可以不是。</p>
<p>通常 ORDER BY 子句必须是 SELECT 语句的最后一个子句。</p>
<p>当有 LIMIT 时，LIMIT 应位于 ORDER BY 的后面，且 DBMS 会先执行 ORDER BY 后执行 LIMIT</p>
<h2 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name </span><br><span class="line">FROM Products </span><br><span class="line">ORDER BY prod_id, prod_price;</span><br></pre></td></tr></table></figure>
<p>首先按 prod_id 排序，对于 prod_id 相同的多行，按 prod_price 排序。</p>
<h2 id="按列位置排序"><a href="#按列位置排序" class="headerlink" title="按列位置排序"></a>按列位置排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name </span><br><span class="line">FROM Products </span><br><span class="line">ORDER BY 2,3;</span><br></pre></td></tr></table></figure>
<p>按相对列位置进行排序。</p>
<p>ORDER BY 2,3 表示按照 SELECT 后跟的列名中的第二个和第三个进行排序</p>
<p>当根据不出现在 SELECT 清单中的列进行排序时，不能采用这种方法。但是可以混合使用实际列名和相对列位置。</p>
<h2 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY 2 DESC,3;</span><br></pre></td></tr></table></figure>
<p>使用关键字 DESC 来指定按降序排列，DESC 仅作用于位于它前面的一个列名。</p>
<p>如果想在多个列上按降序排列，要对每一列都指定 DESC 关键字。</p>
<p>DESC 是 DESCENDING 的缩写，两个都可以用。对应的升序是 ASC(ASCENDING)，可以省略</p>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><h2 id="使用where子句"><a href="#使用where子句" class="headerlink" title="使用where子句"></a>使用where子句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price = 3.49;</span><br></pre></td></tr></table></figure>
<p>使用 WHERE 子句指定过滤条件。</p>
<p>字符串要用单引号括起来。</p>
<h2 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h2><p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251009/xdP5/627X432/Where%E6%93%8D%E4%BD%9C%E7%AC%A6.png" alt="627X432&#x2F;Where操作符.png"><br>MySql支持的操作符如下<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251009/S1VY/668X298/mysql_where%E6%93%8D%E4%BD%9C%E7%AC%A6.png" alt="668X298&#x2F;mysql_where操作符.png"></p>
<p>还有<strong>IS NULL、IN、NOT</strong></p>
<h3 id="BETWEEN-操作符"><a href="#BETWEEN-操作符" class="headerlink" title="BETWEEN 操作符"></a>BETWEEN 操作符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price </span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price BETWEEN 5 AND 10;</span><br></pre></td></tr></table></figure>
<p>BETWEEN 匹配的值包括两个边界值 5 和 10。</p>
<h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price </span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price IS NULL;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 不等于<br>在使用不等于作为过滤条件时，并不会匹配到 NULL 值的行。</p>
</blockquote>
<h1 id="高级数据过滤"><a href="#高级数据过滤" class="headerlink" title="高级数据过滤"></a>高级数据过滤</h1><h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h2><p>可以使用<strong>AND操作符</strong> 和 <strong>OR操作符</strong>来组合多个条件</p>
<p>AND 的优先级高于 OR，可以使用圆括号来控制运算顺序。建议当在一个子句种同时使用 AND 和 OR 时加上圆括号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price </span><br><span class="line">FROM products </span><br><span class="line">WHERE (vend_id = &#x27;DLL01&#x27; OR vend_id = &#x27;BRS01&#x27;) AND prod_price &gt;= 10;</span><br></pre></td></tr></table></figure>
<h2 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price, vend_id</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id IN (&#x27;DLL01&#x27;, &#x27;BRS01&#x27;);</span><br></pre></td></tr></table></figure>
<p>IN 后跟一个圆括号列表，用来指定要匹配值的清单。</p>
<p>IN 的作用和 OR 类似，可以使用 OR 完成同样的操作。IN 操作符一般比一组 OR 操作符执行的更快。</p>
<p><strong>IN 可以包含其他 SELECT 语句</strong></p>
<h2 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE NOT vend_id IN (&#x27;DLL01&#x27;, &#x27;BRS01&#x27;);</span><br></pre></td></tr></table></figure>
<p>NOT 否定其后所跟的任何条件。</p>
<h1 id="使用通配符进行过滤"><a href="#使用通配符进行过滤" class="headerlink" title="使用通配符进行过滤"></a>使用通配符进行过滤</h1><h2 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h2><p>使用LIKE来匹配具有特定模式的字符串，类似正则表达式</p>
<p>通配符：用来匹配值的一部分的特殊字符。</p>
<p>搜索模式：由字面值、通配符或两者组合构成的搜索条件。通配符可以在搜索模式中的任意位置使用，并可以使用多个通配符。</p>
<p>LIKE 后一般跟一个使用了通配符的搜索模式。</p>
<p>根据 DBMS 的设置，搜索可以区分大小写。</p>
<p>常用通配符</p>
<ol>
<li>%:1. 百分号通配符匹配任意数量的任意字符（0 个及 0 个以上）</li>
<li>_ ：下划线通配符用来匹配一个任意字符</li>
<li>[] ：方括号通配符用来指定一个字符集，匹配一个属于字符集的字符（只有 Microsoft Access 和 SQL Server 支持它）。可以在方括号内的开始位置加一个 ^ （ Microsoft Access 中对应字符是 !）来表示否定（像正则表达式一样）<br>MySQL 仅支持 % 和 _ 两种通配符</li>
</ol>
<blockquote>
<p>[!NOTE] 注意可能填补的空格<br>有些DBMS用空格来填补字段的内容。例如，如果某列有50个字符， 而存储的文本为Fish bean bag toy（17个字符），则为填满该列需要在文本后附加33个空格。这样做一般对数据及其使用没有影响，但是可能对上述SQL语句有负面影响。子句WHERE prod_name LIKE ‘F%y’只匹配以F开头、以y结尾的prod_name。如果值后面跟空格， 则不是以y结尾，所以Fish bean bag toy就不会检索出来。简单 的解决办法是给搜索模式再增加一个%号：’F%y%’还匹配y之后的字符（或空格）。更好的解决办法是用函数去掉空格。</p>
</blockquote>
<p>百分号通配符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_name LIKE &#x27;F%y&#x27;; //匹配以 F 开头以 y 结尾的字符串</span><br></pre></td></tr></table></figure>
<p>下划线通配符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_name LIKE &#x27;__ inch %&#x27;;</span><br></pre></td></tr></table></figure>
<p>方括号通配符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_name LIKE &#x27;[1-9][0-9] inch %&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h2><p>通配符搜索比其他搜索耗费时间更多，因此：</p>
<ol>
<li>不要过度使用通配符，如果其他操作符能达到目的，就使用其他操作符。</li>
<li>必须使用通配符时，尽量不要把它放在搜索模式的开始位置。</li>
</ol>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><p>有时存储在表中的数据不是应用程序需要的，需要直接从数据库中检索出转换、计算或格式化的数据。比如数据库中一列保存了姓，另一列保存了名，而用户想要将姓名一块输出</p>
<p>在SQL语句内可完成的许多转换和格式化工作都可以直接在客户端应用程序内完成，但是一般来说，在数据库服务器上完成更快</p>
<p><strong>字段</strong>：基本与列的意思相同，经常互换使用，不过字段通常与计算字段一起使用</p>
<p>计算字段并不实际存在于数据库表中。计算字段是运行时在 SELECT 语句内创建的。</p>
<h2 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h2><p>拼接：将值连接到一起构成单个值。</p>
<p>MySQL、MariaDB 使用 Concat 函数来拼接字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#x27;(&#x27;, RTRIM(vend_country), &#x27;)&#x27;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name</span><br></pre></td></tr></table></figure>
<p>其他 DBMS 使用 + 或 || 来拼接字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;Access、SQL Server&#x27; </span><br><span class="line">SELECT vend_name + &#x27;(&#x27; + vend_country + &#x27;)&#x27; </span><br><span class="line">FROM vendors </span><br><span class="line">ORDER BY vend_name; </span><br><span class="line">&#x27;DB2、Oracle、PostgreSQL、SQLite、Open Office Base&#x27; </span><br><span class="line">SELECT vend_name || &#x27;(&#x27; || vend_country || &#x27;)&#x27; </span><br><span class="line">FROM vendors </span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<h3 id="TRIM函数"><a href="#TRIM函数" class="headerlink" title="TRIM函数"></a>TRIM函数</h3><p>大多数DBMS都支持RTRIM()（去掉右边的空格）、LTRIM()（去掉字符串左边的空格）以及 TRIM()（去掉字符串左右两边的空格）。</p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>上面SELECT拼接得到的字段没有名字，可以使用别名alias作为一个字段或值的替换名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#x27;(&#x27;, vend_country, &#x27;)&#x27;) AS vend_title </span><br><span class="line">FROM vendors </span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<p>使用关键字 AS 来赋予别名。推荐通过 AS 来使用别名。</p>
<p>别名除了给计算字段命名外，还可以重命名某个列名。</p>
<p>别名可以是一个单词也可以是一个字符串，如果是字符型需要加引号。但是建议别名只使用单个单词。</p>
<h2 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h2><p>计算字段的另一用途是对检索出的数据执行算术计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price </span><br><span class="line">FROM orderitems </span><br><span class="line">WHERE order_num = 20008;</span><br></pre></td></tr></table></figure>
<p>将列 quantity 与列 item_price 相乘后命名为 expended_price 输出。</p>
<p>SQL 支持加减乘除四种算术运算，可以用圆括号来区分优先顺序。</p>
<h3 id="测试计算"><a href="#测试计算" class="headerlink" title="测试计算"></a>测试计算</h3><p>SELECT 语句不加 FROM 子句时可以用来处理简单的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 2*3; //返回 6 </span><br><span class="line">SELECT Trim(&#x27; abc&#x27; ); //返回 abc </span><br><span class="line">SELECT Now() AS CurrentTime; //返回当前日期和时间</span><br></pre></td></tr></table></figure>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>几乎所有的 DBMS 都等同地支持 SQL 语句，但是每个 DBMS 都有特定的函数，只有少数几个函数被所有主要的 DBMS 等同地支持。</p>
<p>因为函数不可移植，所以如果使用函数编写 SQL 程序，要做好注释，以便理解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;提取字符串的组成部分&#x27; </span><br><span class="line">SUBSTRING(); // MySQL、SQL Server </span><br><span class="line">SUBSTR(); // DB2、Oracle、PostgreSQL、SQLite </span><br><span class="line">MID(); // Access </span><br><span class="line">&#x27;数据类型转换&#x27; </span><br><span class="line">CONVERT(); // MySQL、MariaDB、SQL Server </span><br><span class="line">CAST(); // PostgreSQL、SQLite </span><br><span class="line">&#x27;取当前日期&#x27; </span><br><span class="line">CURDATE(); // MySQL、MariaDB 。MySQL 中 NOW() 是同时取日期和时间。 </span><br><span class="line">NOW(); // Access </span><br><span class="line">DATE(); // SQLite </span><br><span class="line">GETDATE(); // SQL Server </span><br><span class="line">CURRENT_DATE // DB2、PostgreSQL</span><br></pre></td></tr></table></figure>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>大多数 SQL 都支持以下函数：</p>
<ol>
<li>用于处理文本字符串的函数。如删除或填充值、转换大小写。</li>
<li>用于在数值数据上进行算术操作的数值函数。如返回绝对值、进行算术运算。</li>
<li>用于处理日期和是兼职并从中提取特定成分的日期和时间函数。如返回两个日期之差、检查日期有效性。</li>
<li>返回 DBMS 正使用的特殊信息的系统函数。如返回用户登录信息。</li>
</ol>
<p>下面只列出了 MySQL 中的函数。</p>
<h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEFT();RIGHT();// 返回字符串左边/右边的字符</span><br><span class="line">LENGTH(); // 返回字符串的长度</span><br><span class="line">LOWER();UPPER(); // 将字符串转换为小写/大写</span><br><span class="line">LTRIM();RTRIM;();TRIM();// 去掉字符串左边/右边/两边的空格</span><br><span class="line">SOUNDEX(); // 返回字符串的 SOUNDEX 值</span><br><span class="line">LOCATE();// 找出串的一个子串</span><br><span class="line">SUBSTRING(); // 返回子串的字符</span><br></pre></td></tr></table></figure>

<p>SOUNDEX 值是描述一个文本串的语音表示的字母数字模式，他考虑了类似的发音字符和字节，使得能对字符串进行发音比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;下面这个语句未查询到符合条件的返回值&#x27; </span><br><span class="line">SELECT cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE cust_contact = &#x27;Michael Green&#x27;; </span><br><span class="line">&#x27;下面这个语句返回 Michelle Green，因为两者发音相似&#x27; </span><br><span class="line">SELECT cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE SOUNDEX(cust_contact) = SOUNDEX(&#x27;Michael Green&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p>日期和时间采用相应的数据类型存储在表中，每种 DBMS 都有自己的特殊形式。日期和时间值以特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。</p>
<p>大多数 DBMS 具有比较日期、执行基于日期的运算、选择日期格式等的函数。</p>
<p>日期和时间函数在 SQL 中具有重要的作用，但是他们可移植性最差。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddData(); // 增加一个日期（天、周等） </span><br><span class="line">AddTime(); // 增加一个时间（时、分等） </span><br><span class="line">CurDate(); CurTime(); // 返回当前日期/时间 </span><br><span class="line">DateDiff(); // 计算两个日期之差 </span><br><span class="line">Date_Add(); // 高度灵活的日期计算函数 </span><br><span class="line">Date_Format(); // 返回一个格式化的日期或时间串 </span><br><span class="line">DayOfWeek(); // 对于一个日期，返回对应的星期几 </span><br><span class="line">Year(); Month(); Day(); // 返回一个日期的年份/月份/天数部分 </span><br><span class="line">Hour(); Minute(); Second(); // 返回一个时间的小时/分钟/秒部分 </span><br><span class="line">Now(); // 返回当前日期和时间 </span><br><span class="line">Date(); // 返回一个日期时间的日期部分 </span><br><span class="line">Time(); // 返回一个日期时间的时间部分</span><br></pre></td></tr></table></figure>
<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>数值处理函数仅处理数值数据。一般用于代数、三角或几何运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cos(); Sin(); Tan(); </span><br><span class="line">Abs(); // 返回绝对值 </span><br><span class="line">Mod(); // 返回余数 </span><br><span class="line">Pi(); // 返回圆周率 </span><br><span class="line">Rand(); // 返回随机数 </span><br><span class="line">Exp(); // 返回一个数的指数值 </span><br><span class="line">Sqrt(); // 返回一个数的平方根</span><br></pre></td></tr></table></figure>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>聚集函数用来汇总数据，而非检索数据。比如说想知道表中的总行数、某一列的最大值、平均值等就可以使用聚集函数。</p>
<p>SQL 提供了 5 个聚集函数，它们对某些行运行，计算并返回一个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVG() //返回某列的平均值 </span><br><span class="line">COUNT() //返回某列的行数 </span><br><span class="line">MAX() //返回某列的最大值 </span><br><span class="line">MIN() //返回某列的最小值 </span><br><span class="line">SUM() //返回某列值的和</span><br></pre></td></tr></table></figure>
<h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h3><p>AVG() 可以用来返回所有列的平均值，也可以返回特定列或特定行的平均值。</p>
<p>只能作用于数值列，且列名作为函数参数<br>、<br>会忽略值为NULL的行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;返回某一列中所有行的平均值&#x27;</span><br><span class="line"></span><br><span class="line">SELECT AVG(prod_price) AS avg_price </span><br><span class="line">FROM Products;</span><br><span class="line"></span><br><span class="line">&#x27;返回某一列中特定行的平均值&#x27;</span><br><span class="line"></span><br><span class="line">SELECT AVG(prod_price) AS avg_price </span><br><span class="line">FROM Products WHRER vend_id = &#x27;DLL01&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><p>COUNT() 函数有两种使用方式：</p>
<ol>
<li>COUNT(* )：返回表中的行数（值为 NULL 的行也会统计在内）</li>
<li>COUNT(colum)：对特定列中具有值的行进行计数，忽略 NULL 值。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_cust </span><br><span class="line">FROM Customers;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(cust_email) AS num_cust </span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>
<h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h3><p>MAX() 返回指定列中的最大值，可以用于数值或日期值。但许多 DBMS 也允许它用于返回文本列中的最大值。</p>
<p>MySQL 中的 MAX() 函数支持返回任何列的最大值，包括文本列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MAX(prod_price) AS max_price </span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<h3 id="MIN"><a href="#MIN" class="headerlink" title="MIN"></a>MIN</h3><p>类似MAX</p>
<h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h3><p>SUM() 返回指定列值的和，忽略值为 NULL 的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SUM(item_price*quantity) AS total_price </span><br><span class="line">FROM OrderItems </span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>
<h2 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h2><p>以上聚集函数都可以如下使用：</p>
<ol>
<li>对所有行执行计算（默认或显式指定ALL参数）</li>
<li>只包含不同的值，指定DISTINCT参数，只计算不同的值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price </span><br><span class="line">FROM Products </span><br><span class="line">WHERE vend_id = &#x27;DLL01&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h2><p>SELECT 语句可以包含多个聚集函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items, </span><br><span class="line">	MIN(prod_price) AS price_min, </span><br><span class="line">	MAX(prod_price) AS price_max, </span><br><span class="line">	AVG(prod_price) AS price_avg </span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p>用到两个SELECT子句：GROUPBY和HAVING子句</p>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算（使用第九章中的聚集函数）。</p>
<h2 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h2><p>使用GROUP BY子句创建分组，该子句指示DBMS分组数据，然后对每个组而非整个结果集进行聚集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_pords </span><br><span class="line">FROM products </span><br><span class="line">GROUP BY vend_id</span><br></pre></td></tr></table></figure>
<p>规定：</p>
<ol>
<li>GROUP BY可以包含任意数目的列，因此可以对分组进行嵌套，更细致的进行数据分组</li>
<li>如果嵌套了分组，数据将在最后指定的分组进行汇总。即基于指定的所有列来分组</li>
<li>该子句列出的每一列都必须是检索列或有效的表达式。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句指定相同的表达式，不能用别名</li>
<li>大多数 SQL 不允许 GROUP BY 列带有长度可变的数据类型，如文本或备注型字段</li>
<li>除聚集计算语句外，SELECT语句中每一列都必须在GROUP BY子句中给出。因为结果返回的是对分组后的各个组进行聚集的结果，而不是对单条记录的统计结果</li>
<li>如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回</li>
<li>GROUP BY 子句必须在 WHRER 子句之后，ORDER BY 子句之前（ORDER BY 永远在最后）</li>
</ol>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>可以使用 HAVING 子句过滤分组，类似于 WHERE 子句用来过滤行。实际上所有基本的 WHERE 子句都可以用 HAVING 来替代。HAVING 支持所有的 WHERE 操作符。</p>
<p>可以理解为：WHERE 在数据分组前过滤，HAVING 在数据分组后过滤。如果不指定 GROUP BY，那么 HAVING 和 WHERE 对大多 DBMS 来说是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders </span><br><span class="line">FROM orders </span><br><span class="line">GROUP BY cust_id </span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<p>上面的代码中 HAVING 子句过滤了订单在两个以上（COUNT(* )&gt;&#x3D;2）的分组。</p>
<h3 id="将-WHERE-和-HAVING-一块使用"><a href="#将-WHERE-和-HAVING-一块使用" class="headerlink" title="将 WHERE 和 HAVING 一块使用"></a>将 WHERE 和 HAVING 一块使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods </span><br><span class="line">FROM products </span><br><span class="line">WHERE prod_price &gt;= 4 </span><br><span class="line">GROUP BY vend_id </span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<p>上面的代码先使用 WHERE 过滤数据，然后对过滤后的数据分组，然后过滤分组。</p>
<h2 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h2><p>GROUP BY 分组的数据一般是以分组顺序输出的，但这不是 SQL 规范所要求的。</p>
<p>一般在使用 GROUP BY 时，也要用 ORDER BY 子句。</p>
<h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><p>SELECT子句及其顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT //选择要返回的列或表达式 </span><br><span class="line">FROM //从表中检索数据 </span><br><span class="line">WHERE //行级过滤 </span><br><span class="line">GROUP BY //分组 </span><br><span class="line">HAVING //组级过滤 </span><br><span class="line">ORDER BY //输出排序</span><br></pre></td></tr></table></figure>
<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL可以使用子查询，即嵌套在其他查询内的查询</p>
<h2 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h2><p>嵌套的层数没有限制，但是实际使用一般不嵌套太多层。</p>
<p><strong>作为子查询的 SELECT 语句只能查询单个列</strong></p>
<p>在 SELECT 语句中，子查询是从内向外处理的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, cust_name, cust_city, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">					FROM orders</span><br><span class="line">					WHERE order_num IN (SELECT order_num </span><br><span class="line">										FROM orderitems</span><br><span class="line">										WHERE prod_id = &quot;RGAN01));</span><br></pre></td></tr></table></figure>
<p>上面的程序通过三层嵌套查询获得了订购产品 RGAN01 的所有顾客的详细信息。</p>
<p>（<strong>这个例子中，考虑到可能有产品订购数量和RGAN01一样，故数据有可能比实际的多</strong>）</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>也可以把子查询 SELECT 语句作为外层查询的计算字段。</p>
<p>计算字段中的子查询为外层查询检索出的每个项目执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_state, (</span><br><span class="line">		SELECT COUNT(*) </span><br><span class="line">		FROM orders </span><br><span class="line">		WHERE orders.cust_id = customers.cust_id) AS orders //这里使用了完全限定列名。 </span><br><span class="line">FROM customers </span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>
<p>上面的代码查询了所有顾客的订单数量。</p>
<h3 id="完全限定列名"><a href="#完全限定列名" class="headerlink" title="完全限定列名"></a>完全限定列名</h3><p>表名加列名就构成了完全限定列名，使用一个句点分隔表名和列名。</p>
<p>如果在 SELECT 语句中操作多个表，就应该使用完全限定列名来避免歧义。</p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><p>SQL可以在数据查询中联结表。这是SQL中最重要、最强大的特性</p>
<h3 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h3><p>关系数据库设计的基础：避免相同的数据出现多次</p>
<p>关系表的设计要把信息分解成多个表。一类数据一个表。各个表通过一些共同值来互相关联。这样使关系数据库的可伸缩性非常好（即能够很好地适应不断增加的工作量）、、</p>
<h3 id="联结-1"><a href="#联结-1" class="headerlink" title="联结"></a>联结</h3><p>是一种机制，用来在一条SELECT语句中联结多个表返回一组输出</p>
<p>是在DBMS查询时建立起来的，实际数据库表中不存在</p>
<h3 id="引用完整性"><a href="#引用完整性" class="headerlink" title="引用完整性"></a>引用完整性</h3><p>在联结不同表时，要维护好引用的完整性。</p>
<p>比如 Products 表中存储了一些商品，每个商品有对应的供应商 ID，另有一个表 Vendors 存储了所有的供应商，那么应保证 Products 中的所有商品的供应商 ID 在 Vendors 中都存在，不能向 Products 中插入 Vendors 表中没有的供应商 ID。</p>
<p>在 DBMS 的图形界面上一般可以进行相关设置，以保证引用完整性</p>
<h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, vendors.vend_id, prod_name, prod_price </span><br><span class="line">FROM vendors, products </span><br><span class="line">WHERE vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<p>上面的代码中 FROM 子句列出了两个表，这两个表通过 WHERE 子句建立了联结。</p>
<h3 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a>WHERE子句的重要性</h3><p>在一条 SELECT 语句中联结几个表时，相应的关系是在运行中构造的。</p>
<p>联结两个表时，实际上就是将第一个表中的每一行与第二个表中的每一行配对。</p>
<p>WHERE 子句作为过滤条件（这里是联结条件），只包含那些匹配给定条件的行。没有 WHERE 子句，第一个表中的每一行将于第二个表中的每一行配对，而不管它们逻辑上是否能配在一起。</p>
<p>要保证所有联结都有 WHERE 子句。</p>
<blockquote>
<p>[!NOTE] 笛卡尔积<br>没有联结条件的表关系返回的结果是笛卡尔积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
</blockquote>
<h3 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h3><p>上面使用的联结被称为等值联结，基于两个表之间的相等测试，也称为内联结</p>
<p>可以用另一种即join</p>
<p><strong>注意：当使用了 JOIN 关键字后，就不能再用 WHERE，而必须用 ON。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, vendors.vend_id, prod_name, prod_price </span><br><span class="line">FROM vendors INNER JOIN products </span><br><span class="line">ON vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><h2 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h2><p>SQL 除了可以对列名和计算字段使用别名，还可以给表名起别名。</p>
<p>给表名起别名有两个作用：</p>
<ol>
<li>缩短 SQL 语句。</li>
<li>允许在一条 SELECT 语句中多次使用相同的表。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name,cust_contact </span><br><span class="line">FROM customers AS C, orders AS O, orderitems AS OI //在 FROM 子句中定义表别名 </span><br><span class="line">WHERE C.cust_id = O.cust_id AND O.order_num = OI.order_num AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>表的别名可以用于 WHERE 子句，SELECT 列表等各个部分。</p>
<p>列别名会返回到客户端，而表别名只在查询执行中使用，不返回到客户端。</p>
<h2 id="使用不同类型的内联结"><a href="#使用不同类型的内联结" class="headerlink" title="使用不同类型的内联结"></a>使用不同类型的内联结</h2><p>除了内联结（等值联结）外，还有三种其他联结：自联结、自然联结、外联结。</p>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><p>通过表别名可以在一条 SELECT 语句中不止一次引用相同的表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT A.cust_id, A.cust_name, A.cust_contact </span><br><span class="line">FROM customers AS A, customers AS B </span><br><span class="line">WHERE A.cust_name = B.cust_name AND A.cust_contact = &#x27;Jim Jones&#x27;;</span><br></pre></td></tr></table></figure>
<p>使用子查询可以实现相同功能，但是自联结速度一般快很多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, cust_name, cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE cust_name = (SELECT cust_name </span><br><span class="line">					FROM customers </span><br><span class="line">					WHERE cust_contact = &#x27;Jim Jones&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h2><p>因为联结的多个表必然具有相同的列，因此有时可能返回多次相同的列（实际应用中，基本所有的内联结都是自然联结）。</p>
<p>自然联结排除多次出现，使每一列只返回一次。</p>
<p>自然联结并不是系统完成的，而是要求你自己完成：只能选择那些唯一的列。一般通过对一个表使用通配符(SELECT * )，而对其他表的列使用明确的子集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_price </span><br><span class="line">FROM customers AS C, orders AS O, orderitems AS OI </span><br><span class="line">WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来</p>
<h2 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h2><p>内联结是将一个表中的行与另一个表中的行（按行依次匹配）相关联，外联结可以包含没有关联行（即对应的列为 NULL）的那些行。</p>
<p>使用关键字 OUTER JOIN 来指定联结类型，同时用 RIGHT 或 LEFT 关键字指定包含其所有行的表（RIGHT 包含右边的表，LEFT 包含左边的表）。</p>
<p>下面这个 LEFT 表示要查询 customers 中所有的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id, orders.order_num </span><br><span class="line">FROM customers LEFT OUTER JOIN orders </span><br><span class="line">ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>还有一种外联结是全外联结，它检索两个表中的所有行并关联那些可以关联的行。全外联结包含两个表的不关联的行（MariaDB、MySQL 和 SQLite不支持全联结）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num </span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>
<h2 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h2><p>聚集函数可以和联结一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id, COUNT(orders.order_num) AS num_ord </span><br><span class="line">FROM customers INNER JOIN orders </span><br><span class="line">ON customers.cust_id = orders.cust_id </span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>上面的例子将检索出的行按 customers.cust_id 分组并聚集。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT customers.cust_id, COUNT(orders.order_num) AS num_ord </span><br><span class="line">FROM customers LEFT OUTER JOIN orders </span><br><span class="line">ON customers.cust_id = orders.cust_id </span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>上面的例子将检索出的行按 customers.cust_id 分组并聚集，其中对于在 orders 中没有的 customers.cust_id，它的 num_ord 为 0。</p>
<h2 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h2><p>联结使用的要点：</p>
<ol>
<li>注意所使用的联结类型。一般使用内联结，有时也要用到外联结。</li>
<li>确切的联结语法应该查看 DBMS 的具体文档。</li>
<li>保证使用正确的联结条件。应该总是提供联结条件。</li>
<li>在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型</li>
</ol>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>使用 UNION 操作符将多条 SELECT 语句组合成一个结果</p>
<h2 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h2><p>执行多个查询并将结果作为一个查询结果集返回</p>
<ol>
<li>在一个查询中从不同的表返回数据</li>
<li>对一个表执行多个查询，按一个查询返回数据</li>
</ol>
<p>多数情况，组合相同表的两个查询所完成的工作与有多个 WHERE 子句条件的一个查询所完成的工作相同</p>
<h2 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h2><p>可用 UNION 操作符来组合数条 SQL 查询。</p>
<p>使用 UNION 很简单，给出每条SELECT 语句，在各条语句之间放上关键字 UNION 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;) </span><br><span class="line">UNION </span><br><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_name = &#x27;Fun4All&#x27;;</span><br></pre></td></tr></table></figure>
<p>上面组合查询的结果是两个查询结果的并集。</p>
<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><ol>
<li>每个查询必须包含相同的列、表达式或聚集函数（各个列不需要以相同的次序列出）</li>
<li>必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION 分隔（因此，如果组合四条SELECT 语句，将要使用三个 UNION 关键字）</li>
<li>列数据类型必须兼容，类型不必完全相同，但必须是 DBMS 可以隐含转换的类型</li>
</ol>
<h3 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h3><p>默认情况下 UNION 从查询结果集中自动去除了重复的行；如果想返回所有的匹配行，可使用 UNION ALL 而不是 UNION。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;) </span><br><span class="line">UNION ALL </span><br><span class="line">SELECT cust_name, cust_contact, cust_email </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_name = &#x27;Fun4All&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="对组合查询结果进行排序"><a href="#对组合查询结果进行排序" class="headerlink" title="对组合查询结果进行排序"></a>对组合查询结果进行排序</h3><p>在用 UNION 组合查询时，只能使用一条 ORDER BY 子句，它必须位于最后一条SELECT 语句之后。DBMS 将用它来排序所有 SELECT 语句返回的所有结果。</p>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>INSERT 用来将行插入（或添加）到数据库表。插入有几种方式：</p>
<ol>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入某些查询的结果</li>
</ol>
<h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><h4 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h4><p>直接按表中列的顺序列出各列的值，没有值就使用 NULL。这种方法可移植性差，容易出错，不提倡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers </span><br><span class="line">VALUES(&#x27;1000000006&#x27;, &#x27;Toy Land&#x27;, &#x27;123 Any Street&#x27;, &#x27;New York&#x27;, &#x27;NY&#x27;, &#x27;11111&#x27;, &#x27;USA&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure>
<h4 id="明确给出列名"><a href="#明确给出列名" class="headerlink" title="明确给出列名"></a>明确给出列名</h4><p>在表名后的括号里明确指定列名。优点是可移植性强，且即使表的结构改变也可以工作。建议使用这种方式</p>
<p>这种方式下各列的顺序可以随意调换，只要列名与列值相对于即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email) </span><br><span class="line">VALUES( &#x27;1000000006&#x27;, &#x27;Toy Land&#x27;, &#x27;123 Any Street&#x27;, &#x27;New York&#x27;, &#x27;NY&#x27;, &#x27;11111&#x27;, &#x27;USA&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure>
<h4 id="插入部分行"><a href="#插入部分行" class="headerlink" title="插入部分行"></a>插入部分行</h4><p>使用明确给出列名的方式还可以省略列，只提供一部分列的值。</p>
<p>省略的列必须满足：该列被定义为允许 NULL 或在表的定义中给出了该列的默认值（这表示如果不提供值将使用默认值）</p>
<h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><p>可以利用它将 SELECT 语句的结果插入表中，这就是所谓的 INSERT SELECT。它是由一条 INSERT 语句和一条 SELECT 语句组成的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers( cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) </span><br><span class="line">SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country </span><br><span class="line">FROM CustNew;</span><br></pre></td></tr></table></figure>
<p>这个例子在 INSERT 和 SELECT 语句中使用了相同的列名。但是不一定要求列名匹配。DBMS 不关心 SELECT 返回的列名。它使用的是列的位置，因此 SELECT 中的第一列（不管其列名）将用来填充表列中指定的第一列，第二列将用来填充表列中指定的第二列，如此等等。</p>
<p>INSERT SELECT 中 SELECT 语句可以包含 WHERE 子句，以过滤插入的数据</p>
<p>INSERT 通常只插入一行。要插入多行，必须执行多个INSERT 语句。INSERT SELECT是个例外，它可以用一条 INSERT 插入多行，不管 SELECT 语句返回多少行，都将被INSERT 插入</p>
<h2 id="从一个表复制到另一个表"><a href="#从一个表复制到另一个表" class="headerlink" title="从一个表复制到另一个表"></a>从一个表复制到另一个表</h2><p>有一种数据插入不使用 INSERT 语句。要将一个表的内容复制到一个全新的表（运行中创建的表），可以使用 SELECT INTO 语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="operator">/</span><span class="operator">/</span>要想只复制部分的列，可以明确给出列名 </span><br><span class="line"><span class="keyword">INTO</span> CustCopy </span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure>
<p>MySQL、MariaDB、Oracle、PostgreSQL 和 SQLite 不使用 SELECT INTO，而使用 CREATE 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE CustCopy AS </span><br><span class="line">SELECT * FROM Customers;</span><br></pre></td></tr></table></figure>
<p>在使用 SELECT INTO 时，需要知道一些事情：</p>
<ol>
<li>任何 SELECT 选项和子句都可以使用，包括 WHERE 和 GROUP BY；</li>
<li>可利用联结从多个表插入数据；</li>
<li>不管从多少个表中检索数据，数据都只能插入到一个表中。</li>
</ol>
<h1 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h1><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>更新（修改）表中的数据，可以使用 UPDATE 语句。有两种使用 UPDATE 的方式：</p>
<ol>
<li>更新表中的特定行；</li>
<li>更新表中的所有行。</li>
</ol>
<p><strong>在使用 UPDATE 时一定要细心。因为稍不注意，就会更新表中的所有行</strong></p>
<p>基本的UPDATE 语句由三部分组成，分别是：</p>
<ol>
<li>要更新的表；</li>
<li>列名和它们的新值；</li>
<li>确定要更新哪些行的过滤条件。如果没有 WHERE 子句，将更新所有行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Customers </span><br><span class="line">SET cust_contact = &#x27;Sam Roberts&#x27;, cust_email = &#x27;kim@thetoystore.com&#x27; </span><br><span class="line">WHERE cust_id = &#x27;1000000005&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="删除某个列的值"><a href="#删除某个列的值" class="headerlink" title="删除某个列的值"></a>删除某个列的值</h3><p>要删除某个列的值，可通过 UPDATE 设置它为 NULL（假如表定义允许NULL 值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Customers </span><br><span class="line">SET cust_email = NULL </span><br><span class="line">WHERE cust_id = &#x27;1000000005&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>从一个表中删除（去掉）数据，使用 DELETE 语句。有两种使用 DELETE的方式</p>
<ol>
<li>从表中删除特定的行</li>
<li>从表中删除所有的行<br>在使用 DELETE 时一定要细心。因为稍不注意，就会错误地删除表中所有行</li>
</ol>
<p>如果某个行通过外键与其他表中的行相连接，则 DELETE 将抛出错误并中止。</p>
<p>DELETE 不需要列名或通配符。DELETE 删除整行而不是删除列。要删除指定的列，请使用 UPDATE 语句</p>
<h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><p>使用 UPDATE 或 DELETE 时所遵循的重要原则：</p>
<ol>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带 WHERE 子句的 UPDATE 或 DELETE 语句。</li>
<li>保证每个表都有主键，尽可能像 WHERE 子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在 UPDATE 或 DELETE 语句使用 WHERE 子句前，应该先用 SELECT 进行测试，保证它过滤的是正确的记录，以防编写的WHERE 子句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样 DBMS 将不允许删除其数据与其他表相关联的行。</li>
<li>有的 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 语句。如果所采用的 DBMS 支持这个特性，应该使用它。</li>
</ol>
<h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>一般有两种创建表的方法：</p>
<ol>
<li>多数 DBMS 都具有交互式创建和管理数据库表的工具（这本质上也是通过 SQL 语句创建的）。</li>
<li>表也可以直接用 SQL 语句操纵。</li>
</ol>
<p>CREATE TABLE 语句用来创建表。使用 CREATE TABLE 语句时要给出下列信息：</p>
<ol>
<li>新表的名字，在关键字 CREATE TABLE 之后给出；</li>
<li>表列的名字和定义，用逗号分隔；</li>
<li>有的 DBMS 还要求指定表的位置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Products </span><br><span class="line">( //注意使用的是圆括号 </span><br><span class="line">	prod_id CHAR(10) NOT NULL, </span><br><span class="line">	vend_id CHAR(10) NOT NULL, </span><br><span class="line">	prod_name CHAR(254) NOT NULL, </span><br><span class="line">	prod_price DECIMAL(8,2) NOT NULL, </span><br><span class="line">	pro_desc TEXT(1000) NULL </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的 TEXT 只适用于 MySQL，在 Oracle、PostgreSQL、SQL Server 和 SQLite 中要换成 VARCHAR。</p>
<p>注意创建新表时，指定的表名必须之前不存在。</p>
<h3 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h3><p>NULL 值就是没有值，允许 NULL 值的列也允许在插入行时不给出该列的值。</p>
<p>每个表列要么是 NULL 列，要么是 NOT NULL 列。这在创建时由表的定义规定，不指明的话默认为 NULL 列。</p>
<p>只有 NOT NULL 列才能作为主键。</p>
<h3 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h3><p>SQL 允许通过关键字 DEFAULT 指定某一列的默认值，在插入行时如果不给出值，DBMS 将自动采用默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE OrderItems </span><br><span class="line">( </span><br><span class="line">	prod_id CHAR(10) NOT NULL, </span><br><span class="line">	quantity INTEGER NOT NULL DEFAULT 1, </span><br><span class="line">	order_time CHAR(30) NOT NULL DEFAUTL CURRENT_DATE(), //指定系统时间为默认值 </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>默认值经常用于日期或时间戳列，将系统日期作为默认日志。</p>
<h2 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h2><p>可以使用 ALTER TABLE 语句更新表定义。不同 DBMS 的 ALTER TABLE 的可更新范围不同。</p>
<p>使用 ALTER TABLE 更改表结构，必须给出下面的信息：</p>
<ol>
<li>在 ALTER TABLE 之后给出要更改的表名（该表必须存在，否则将出错）；</li>
<li>列出要做哪些更改。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Vendors </span><br><span class="line">ADD vend_phone CHAR(20);</span><br></pre></td></tr></table></figure>
<p>上面的例子给 Vendors 增加了一列。更改或删除列、增加约束或增加键等操作也使用类似的语法。</p>
<p>可以在一条 ALTER 语句中对一个表进行多次更改，不同更改间用逗号分隔</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>理想情况下，不要在表中包含数据时对其进行更新。</li>
<li>所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。</li>
<li>许多 DBMS 不允许删除或更改表中的列</li>
<li>多数 DBMS 允许重新命名表中的列。</li>
<li>许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。</li>
</ol>
<p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p>
<ol>
<li>用新的列布局创建一个新表；</li>
<li>使用 INSERT SELECT 语句从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ol>
<p>使用 ALTER TABLE 要极为小心，应该在进行改动前做完整的备份（表结构和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们。</p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>删除表使用 DROP TABLE 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE CustCopy;</span><br></pre></td></tr></table></figure>
<p>删除表没有确认，也不能撤销，执行 DROP TABLE 语句将永久删除表。</p>
<p>许多 DBMS 允许强制实施有关规则，防止删除与其他表相关联的表。此时如果对某个表发布一条 DROP TABLE 语句，且该表是某个关系的组成部分，则 DBMS 将阻止这条语句执行。</p>
<h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><p>DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 用户使用 RENAME 语句重命名表。</p>
<p>MySQL 重命名表的方式如下，可以在单个 RENAME 语句中重命名多个表，不同重命名间用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE customers TO customers2, </span><br><span class="line">			vendors TO vendors2;</span><br></pre></td></tr></table></figure>
<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚拟的表，不包含数据，只包含查询语句</p>
<p>理解：视图实际上是把一个查询包装为了一个虚拟表，虚拟表的内容就是包装起来的查询的结果。</p>
<p>创建视图之后，可以用与表基本相同的方式使用它们。可以对视图执行 SELECT 操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加和更新数据。</p>
<p>视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p><strong>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。</strong></p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ol>
<li>重用 SQL 语句。</li>
<li>简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。</li>
<li>使用表的一部分而不是整个表。</li>
<li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ol>
<h3 id="使用视图的一些规则和限制"><a href="#使用视图的一些规则和限制" class="headerlink" title="使用视图的一些规则和限制"></a>使用视图的一些规则和限制</h3><ol>
<li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的 DBMS 中有所不同（嵌套视图可能会严重降低查询的性能，因此在使用之前，应该对其进行全面测试）。</li>
<li>许多 DBMS 禁止在视图查询中使用 ORDER BY 子句，MySQL 允许。</li>
<li>有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。</li>
<li>视图不能索引，也不能有关联的触发器或默认值。</li>
<li>有些 DBMS 把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表</li>
</ol>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>视图用 CREATE VIEW 语句来创建。</p>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW ProductCustomers AS </span><br><span class="line">SELECT cust_name, cust_contact, prod_id </span><br><span class="line">FROM Customers, Orders, OrderItems </span><br><span class="line">WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num;</span><br></pre></td></tr></table></figure>
<p>上面的例子创建了一个名为 ProductCustomers 的视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM ProductCustomers WHERE prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>上面的例子通过 WHERE 子句从视图中检索数据。</p>
<p>利用视图，可一次性编写基础的 SQL，然后根据需要多次使用。</p>
<h3 id="利用视图重新格式化检索出的数据"><a href="#利用视图重新格式化检索出的数据" class="headerlink" title="利用视图重新格式化检索出的数据"></a>利用视图重新格式化检索出的数据</h3><p>视图的另一常见用途是重新格式化检索出的数据。</p>
<p>对于以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27; </span><br><span class="line">AS vend_title </span><br><span class="line">FROM Vendors </span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<p>如果经常要使用上述格式，可以创建一个视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW VendorLocations AS </span><br><span class="line">SELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27; </span><br><span class="line">AS vend_title </span><br><span class="line">FROM Vendors;</span><br></pre></td></tr></table></figure>

<p>之后再进行格式化查询就可以通过视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM VendorLocations;</span><br></pre></td></tr></table></figure>
<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><p>视图对于应用普通的WHERE子句很有用</p>
<h3 id="用视图简化计算字段"><a href="#用视图简化计算字段" class="headerlink" title="用视图简化计算字段"></a>用视图简化计算字段</h3><p>在简化计算字段的使用上，视图也特别有用。</p>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>删除视图，可以使用 DROP 语句，其语法为 DROP VIEW viewname;。</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>更新视图必须先删除它，然后再重新创建。</p>
<p>MySQL 中更新视图还可以使用 CREATE OR REPLACE VIEW 语句。如果要更新的视图不存在，它会创建一个视图；如果要更新的视图存在，它会替换原有视图。</p>
<h1 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>经常会有一些复杂的操作需要多条 SQL 语句才能完成，这时可以创建存储过程。</p>
<p>存储过程就是为以后使用而保存的一条或多条SQL 语句。</p>
<h2 id="为什么要使用"><a href="#为什么要使用" class="headerlink" title="为什么要使用"></a>为什么要使用</h2><p>存储过程的用处：</p>
<ol>
<li>通过把处理封装在一个易用的单元中，可以简化复杂的操作。</li>
<li>保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。也能减少错误。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员不需要知道这些变化。</li>
<li>因为存储过程通常以编译过的形式存储，所以 DBMS 处理命令所需的工作量少，提高了性能。</li>
<li>存在一些只能用在单个请求中的SQL 元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</li>
</ol>
<p>简而言之，存储过程的三个优点：简单、安全、高性能。</p>
<h2 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h2><p>使用 EXECUTE 语句执行存储过程。注意 MySQL 使用的是 CALL 而不是 EXCUTE。</p>
<p>EXECUTE 语句接受存储过程名和需要传递给它的参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> AddNewProduct( <span class="string">&#x27;JTS01&#x27;</span>, <span class="string">&#x27;Stuffed Eiffel Tower&#x27;</span>, <span class="number">6.49</span>, <span class="string">&#x27;Plush&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>对于具体的DBMS，可能包括以下的执行选择：</p>
<ol>
<li>参数可选，具有不提供参数时的默认值；</li>
<li>不按次序给出参数，以“参数&#x3D;值”的方式给出参数值。</li>
<li>输出参数，允许存储过程在正执行的应用程序中更新所用的参数。</li>
<li>用 SELECT 语句检索数据。</li>
<li>返回代码，允许存储过程返回一个值到正在执行的应用程序。</li>
</ol>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>MySQL版本的一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE productPricing() //如果存储过程接受参数，它们将在()中列举出来 </span><br><span class="line">BEGIN </span><br><span class="line">	SELECT Avg(prod_price) AS pricaverage </span><br><span class="line">	FROM products </span><br><span class="line">END; </span><br><span class="line">DROP PROCEDURE productPricing; //删除存储过程</span><br></pre></td></tr></table></figure>
<h1 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h1><p>可以利用 COMMIT 和 ROLLBACK 语句管理事务处理。</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>事务处理（transaction processing）确保成批的 SQL 操作要么完全执行，要么完全不执行，可以用来维护数据库的完整性。</p>
<p>事务处理是一种机制，用来管理必须成批执行的 SQL 操作，保证数据库不包含不完整的操作结果。</p>
<p>利用事务处理，可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态。</p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>事务：一组 SQL 语句。</li>
<li>回退：撤销指定的 SQL 语句。</li>
<li>提交：将未存储的 SQL 语句结果写入到数据库表。</li>
<li>保留点：事务处理中设置的临时占位符，可以对它发布回退。</li>
</ul>
<p>事务处理用来管理 INSERT、UPDATE 和 DELETE 语句。不能回退SELECT语句（也没有必要）、CREATE 、DROP。</p>
<h2 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h2><p>管理事务的关键在于将SQL语句组分解为逻辑块，并明确数据何时应该回退，何时不应该</p>
<p>MySQL 和 MariaDB 中的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION ... //这些语句必须完全执行或完全不执行。</span><br></pre></td></tr></table></figure>

<p>SQL Server 使用的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION ... <span class="keyword">COMMIT</span> TRANSACTION</span><br></pre></td></tr></table></figure>

<p>Oracle 中等同的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET TRANSACTION ...</span><br></pre></td></tr></table></figure>

<h3 id="使用ROLLBACK"><a href="#使用ROLLBACK" class="headerlink" title="使用ROLLBACK"></a>使用ROLLBACK</h3><p>SQL 中的 ROLLBACK 命令用来回退（撤销）SQL 语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders; </span><br><span class="line"><span class="keyword">ROLLBACK</span>; <span class="operator">/</span><span class="operator">/</span>撤销上面的 <span class="keyword">DELETE</span> 语句</span><br></pre></td></tr></table></figure>
<h3 id="使用Commit"><a href="#使用Commit" class="headerlink" title="使用Commit"></a>使用Commit</h3><p>一般的SQL语句都是针对数据库表直接执行和编写的，属于隐式提交，即提交操作自动进行</p>
<p>在事务处理块中，提交不会隐式进行。而是使用 COMMIT 语句进行明确的提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION </span><br><span class="line">DELETE FROM ordersitems WHERE order_num = 20010; </span><br><span class="line">DELETE FROM orders WHERE order_num = 20010; COMMIT;</span><br></pre></td></tr></table></figure>
<p>当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭。</p>
<h3 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h3><p>使用简单的ROLLBACK和COMMIT语句，可以写入或撤销整个事务</p>
<p>有时只想回退部分事务，可以在事务处理块中的合适位置放置占位符，回退时可以回退到某个占位符，称为保留点</p>
<p>使用 SAVEPOINT 语句创建保留点。</p>
<p>在 MySQL 、MariaDB 和 Oracle 中，如下进行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT delete1; </span><br><span class="line">ROLLBACK TRANSACTION delete1;</span><br></pre></td></tr></table></figure>
<p>保留点越多越好，可以在 MySQL 代码中设置任意多的保留点。保留点会在事务处理完成后自动释放。</p>
<h1 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h1><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>SQL 检索操作返回一组称为结果集的行，这组返回的行都是与 SQL 语句相匹配的行（零行或多行）。有时需要在检索出来的行中前进或后退一行或多行，这就是游标的用途所在</p>
<p>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p>主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。游标对基于Web 的应用用处不大。</p>
<p>Mysql中的游标只能用于存储过程和函数</p>
<h2 id="使用游标-1"><a href="#使用游标-1" class="headerlink" title="使用游标"></a>使用游标</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>使用 DECLARE 语句创建游标，并定义相应的 SELECT 语句，根据需要带 WHERE 和其他子句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders() </span><br><span class="line">BEGIN </span><br><span class="line">	DECLARE ordernumbers CURSOR </span><br><span class="line">	FOR </span><br><span class="line">	SELECT order_num FROM orders; </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>上面的存储过程定义了一个游标，存储过程结束后游标就会消失。</p>
<h2 id="使用游标-2"><a href="#使用游标-2" class="headerlink" title="使用游标"></a>使用游标</h2><p>定义游标后可以打开游标，使用 OPEN 语句打开游标，然后使用 FETCH 语句访问游标数据，最后使用 CLOSE 语句关闭游标。</p>
<p>FETCH 指出要检索哪些行，从何处检索它们以及将它们放于何处（如变量名）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN ordernumbers //处理 OPEN 语句时会执行对应的查询并存储检索出的数据以供浏览和滚动。 FETCH ordernumbers INTO var; //用 FETCH 检索当前行的 order_num 列（自动从第一行开始）并存到局部变量 var 中。 </span><br><span class="line">CLOSE ordernumbers //关闭游标</span><br></pre></td></tr></table></figure>
<p>例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders() </span><br><span class="line">BEGIN </span><br><span class="line">	//声明局部变量 </span><br><span class="line">	DECLARE done BOOLEAN DEFAULT 0; </span><br><span class="line">	DECLARE o INT; </span><br><span class="line">	DECLARE t DECIMAL(8, 2); </span><br><span class="line">	//创建游标 </span><br><span class="line">	DECLARE ordernumbers CURSOR </span><br><span class="line">	FOR </span><br><span class="line">	SELECT order_num FROM orders; </span><br><span class="line">	//声明 continue handler，这是在条件出现时被执行的代码。 </span><br><span class="line">	//SQLSTATE&#x27;02000&#x27; 是一个未找到条件，当 REPEAT 由于没有更多的行供循环而不能继续时，出现这个条件。 </span><br><span class="line">	DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;02000&#x27; SET done=1; //当 SQLSTATE &#x27;02000&#x27; 出现时，SET done=1。 </span><br><span class="line">	//创建一个表用来存储结果 </span><br><span class="line">	CREATE TABLE IF NOT EXISTS ordertotals (order_num INT, total DECIMAL(8, 2)); </span><br><span class="line">	//打开游标 </span><br><span class="line">	OPEN ordernumbers; </span><br><span class="line">	//循环所有行 </span><br><span class="line">	REPEAT </span><br><span class="line">		FETCH ordernumbers INTO o; </span><br><span class="line">		CALL ordertotal(o, 1, t); </span><br><span class="line">		INSERT INTO ordertotals(order_num, total) VALUES(o, t); </span><br><span class="line">	UNTIL done END REPEAT; //反复执行直到 done=1 </span><br><span class="line">	//关闭游标 </span><br><span class="line">	CLOSE ordernumbers; </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h1 id="高级SQL特性"><a href="#高级SQL特性" class="headerlink" title="高级SQL特性"></a>高级SQL特性</h1><p>SQL 的几个高级数据处理特性：约束、索引、触发器。</p>
<p>约束是实施引用完整性的重要部分，索引可改善数据检索的性能，触发器可以用来执行运行前后的处理，安全选项可用来管理数据访问。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束是管理如何插入或处理数据库数据的规则。</p>
<p>关系数据库存储分解为多个表的数据，每个表存储相应的数据。利用键来建立从一个表到另一个表的引用，由此产生了引用完整性。</p>
<p>DBMS 通过在数据库表上施加约束来实施引用完整性。大多数约束是在表定义中定义的，用 CREATE TABLE 或 ALTER TABLE 语句。</p>
<h3 id="主键-1"><a href="#主键-1" class="headerlink" title="主键"></a>主键</h3><p>主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。换句话说，表中的一列（或多个列）的值唯一标识表中的每一行。</p>
<p>任意列只要满足以下条件，就可以用于主键</p>
<ol>
<li>任意两行的主键值不同</li>
<li>每行都有一个主键值（列中不允许有NULL值）</li>
<li>包含主键值的列从不修改或更新。主键值不能重用。如果从表中删除某一行，其主键值不分配给新行</li>
</ol>
<p>在表定义时用PRIMARY KEY关键字声明主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Vendors </span><br><span class="line">( </span><br><span class="line">	vend_id CHAR(10) NOT NULL PRIMARY KEY, </span><br><span class="line">	vend_name CHAR(50) NOT NULL, </span><br><span class="line">	vend_address CHAR(50) NULL, </span><br><span class="line">	vend_city CHAR(50) NULL, </span><br><span class="line">	vend_state CHAR(5) NULL, </span><br><span class="line">	vend_zip CHAR(10) NULL, </span><br><span class="line">	vend_country CHAR(50) NULL</span><br></pre></td></tr></table></figure>
<p>使用 CONSTRAINT 语法定义主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Vendors</span><br><span class="line">ADD CONSTRAINT PRIMARY KEY (vend_id);</span><br></pre></td></tr></table></figure>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>是表中的一列，值必须列在另一表的主键中，外键是保证引用完整性的极其重要部分</p>
<p>外键除了保证引用完整性外，还能防止意外的删除。比如订单中定义了外键关联到顾客，那么要想删除顾客必须先删除所有与该顾客相关联的订单项。</p>
<p>使用REFERENCES关键字声明外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Orders </span><br><span class="line">( </span><br><span class="line">	order_num INTEGER NOT NULL PRIMARY KEY, </span><br><span class="line">	order_date DATETIME NOT NULL, </span><br><span class="line">	cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id) );</span><br></pre></td></tr></table></figure>
<p>上面的例子在 Orders 的 cust_id 列上定义了一个外键，这样 cust_id 中的任何值都必须是 Customers 表中的 cust_id 值。</p>
<p>使用 CONSTRAINT 语法声明外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Venders </span><br><span class="line">ADD CONSTRAINT REFERENCES Customers(cust_id);</span><br></pre></td></tr></table></figure>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>用来保证一列（或一组列）中数据唯一。类似主键，但有以下区别：</p>
<ol>
<li>表中可以包含多个唯一约束，但每个表只允许一个主键</li>
<li>唯一约束列可包含NULL值</li>
<li>唯一约束列可以修改或更新</li>
<li>唯一约束列的值可以重复用</li>
<li>与主键不一样，唯一约束不能用来定义外键。</li>
</ol>
<p>唯一约束的语法类似于其他约束的语法。唯一约束既可以用 UNIQUE 关键字在表定义中定义，也可以用单独的 CONSTRAINT 定义</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点：</p>
<ol>
<li>检查最小或最大值。例如防止 0 个物品的订单（即使 0 是合法的数）。</li>
<li>指定范围。</li>
<li>只允许特定的值</li>
</ol>
<p>数据类型限制了列中可保存的数据的类型，检查约束在数据类型内又做了进一步的限制。</p>
<p>使用关键字 CHECK 添加检查约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE OrderItems </span><br><span class="line">( </span><br><span class="line">	order_num INTEGER NOT NULL, </span><br><span class="line">	order_item INTEGER NOT NULL, </span><br><span class="line">	prod_id CHAR(10) NOT NULL, </span><br><span class="line">	quantity INTEGER NOT NULL CHECK (quantity &gt; 0), </span><br><span class="line">	item_price MONEY NOT NULL </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用 CONSTRAINT 语法添加检查约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE Products </span><br><span class="line">ADD CONSTRAINT CHECK (gender LIKE &#x27;[MF]&#x27;) //使 gender 列只包含 M 或 F。</span><br></pre></td></tr></table></figure>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引用来排序数据以加快搜索和排序操作的速度。</p>
<p>数据库索引的作用与书籍中索引&#x2F;目录的作用一样。</p>
<p>主键数据总是排序的，这是 DBMS 的工作。因此，按主键检索特定行总是一种快速有效的操作。但是，搜索其他列中的值通常效率不高。</p>
<p>可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS 以使用书的索引类似的方法使用它。DBMS 搜索排过序的索引，找出匹配的位置，然后检索这些行。</p>
<p>注意事项：</p>
<ol>
<li>索引改善检索操作的性能，但是降低了数据插入、修改和删除的性能。执行这些操作时，DBMS必须动态更新索引</li>
<li>索引数据可能占用大量存储空间</li>
<li>并非所有数据都适合做索引，取值不多的数据（如州）不如具有更多可能值的数据（如姓或名）能通过索引得到那么多的好处</li>
<li>索引用于数据过滤和数据排序。</li>
<li>可以在索引在定义多个列，例如，州加上城市。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处</li>
</ol>
<p>索引用 CREATE INDEX 语句创建，索引必须唯一命名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX prod_name_id </span><br><span class="line">ON Products (prod_name);</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是特殊的存储过程，它在特定的事件（表更改）发生时自动执行。触发器可以与特定表上的 INSERT、UPDATE 和 DELETE 操作（或组合）相关联。</p>
<p>与存储过程不一样（存储过程只是简单的存储 SQL 语句），触发器与单个的表相关联。与 Orders 表上的 INSERT 操作相关联的触发器在 Orders 表中插入行时执行。</p>
<p>触发器中的代码有如下数据的访问权</p>
<ol>
<li>INSERT 操作中的所有新数据；</li>
<li>UPDATE 操作中的所有新数据和旧数据；</li>
<li>DELETE 操作中删除的数据。</li>
</ol>
<p>常见用途如下：</p>
<ol>
<li>保证数据的一致性。例如，在 INSERT 或 UPDATE 操作中将所有州名转换为大写。</li>
<li>基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表。</li>
<li>进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入。</li>
<li>计算计算列的值或更新时间戳。</li>
</ol>
<p>一般约束比触发器快，因此尽量用约束</p>
<p>只有表才支持触发器，视图和临时表都不支持</p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>使用 CREATE TRIGGER 创建触发器，触发器可以在一个操作发生前或发生后执行。</p>
<p>需要给出4条信息</p>
<ol>
<li>唯一的触发器名：触发器应该有一个在数据库内唯一的名字</li>
<li>触发器关联的表</li>
<li>触发器应该响应的活动（DELETE、INSERT 或 UPDATE）</li>
<li>触发器何时执行（处理之前（BEFORE）或之后（AFTER））</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products //触发器在表 products 的 INSERT 语句成功执行后执行。 </span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27;;</span><br></pre></td></tr></table></figure>

<p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条 INSERT、UPDATE 和 DELETE 的之前和之后）。</p>
<p>触发器失败：如果 BEFORE 触发器失败，则将不执行请求的操作。如果 BEFORE 触发器或语句本身失败，将不执行 AFTER 触发器。</p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p><code>DROP TRIGGER newproduct;</code></p>
<h3 id="使用INSERT触发器"><a href="#使用INSERT触发器" class="headerlink" title="使用INSERT触发器"></a>使用INSERT触发器</h3><p>INSERT触发器在 INSERT 语句执行之前或之后执行。需要知道以下几点：</p>
<ol>
<li>在INSERT触发器代码内，可以引用一个名为NEW的虚拟表，访问被插入的行</li>
<li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li>
<li>对于 AUTO_INCREMENT 列（这种列具有 MySQL 自动赋予的值），NEW 在 INSERT 执行之前包含 0，在 INSERT 执行之后包含新的自动生成值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders </span><br><span class="line">FOR EACH ROW SELECT NEW.order_num; //每次插入新订单时都显示订单号</span><br></pre></td></tr></table></figure>
<p>之前执行的话一般用于数据验证和净化</p>
<h3 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h3><p>DELETE 触发器在 DELETE 语句执行之前或之后执行。需要知道以下两点：</p>
<ol>
<li>在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行；</li>
<li>OLD 中的值全都是只读的，不能更新。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders </span><br><span class="line">FOR EACH ROW </span><br><span class="line">BEGIN </span><br><span class="line">	INSERT INTO archive_orders(order_num, order_date, cust_id)</span><br><span class="line">	VALUES(OLD.order_num, OLD.order_date, OLD.cust_id) </span><br><span class="line">END; //将要被删除的订单保存到名为 archive_orders 的存档表中</span><br></pre></td></tr></table></figure>

<h3 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h3><p>UPDATE触发器在 UPDATE 语句执行之前或之后执行。需要知道以下几点：</p>
<ol>
<li>在 UPDATE 触发器代码中，可以引用一个名为 OLD 的虚拟表访问以前（UPDATE 语句前）的值，引用一个名为 NEW 的虚拟表访问新更新的值；</li>
<li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新（允许更改将要用于 UPDATE 语句中的值）</li>
<li>OLD中的值全是只读的，不能更新</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors </span><br><span class="line">FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state); //保证每个州名都是大写。</span><br></pre></td></tr></table></figure>
<h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><p>大多数 DBMS 都给管理员提供了管理机制，利用管理机制授予或限制对数据的访问。</p>
<p>任何安全系统的基础都是用户授权和身份确认。</p>
<p>一般说来，需要保护的操作有：</p>
<ol>
<li>对数据库管理功能（创建表、更改或删除已存在的表等）的访问；</li>
<li>对特定数据库或表的访问；</li>
<li>访问的类型（只读、对特定列的访问等）；</li>
<li>仅通过视图或存储过程对表进行访问；</li>
<li>创建多层次的安全措施，从而允许多种基于登录的访问和控制；</li>
<li>限制管理用户账号的能力。</li>
</ol>
<p>安全性使用 GRANT 和 REVOKE 语句来管理，不过，大多数 DBMS 提供了交互式的管理实用程序，这些实用程序在内部使用 GRANT 和 REVOKE 语句。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>7-21 代码随想录之数组</title>
    <url>/2025/07/21/day2/</url>
    <content><![CDATA[<h1 id="209-长度最小的子数组-力扣（LeetCode）"><a href="#209-长度最小的子数组-力扣（LeetCode）" class="headerlink" title="209. 长度最小的子数组 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></h1><p>双指针维护子数组的左边界和右边界，一个变量记录和。</p>
<p><strong>注意：当和大于等于target时，需要循环减去左边界，因为当新加入的数特别大时，只减一次是不够的</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(f &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, f - s + <span class="number">1</span>);</span><br><span class="line">                    sum -= nums[s];</span><br><span class="line">                    s++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                f++;</span><br><span class="line">                <span class="keyword">if</span>(f &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    sum += nums[f];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX?<span class="number">0</span>:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="58-区间和（第九期模拟笔试）"><a href="#58-区间和（第九期模拟笔试）" class="headerlink" title="58. 区间和（第九期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1070">58. 区间和（第九期模拟笔试）</a></h1><p>可以暴力，但是太慢了。</p>
<p>这里引入前缀和。前缀和可以简单理解为「数列的前n项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。</p>
<p>在这道题目中，计算的是区间内的和(设区间为a、b)，则该区间内的和就是前b项的和减去前a项的和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b))&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prefix[b]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = prefix[b] - prefix[a - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="44-开发商购买土地（第五期模拟笔试）"><a href="#44-开发商购买土地（第五期模拟笔试）" class="headerlink" title="44. 开发商购买土地（第五期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1044">44. 开发商购买土地（第五期模拟笔试）</a></h1><p>其实还是用前缀和的思想，但是这里最好是把整个二维数组观想成一维一维的数组（无论行列）。然后将每一维当作一个元素，去求整体的前缀和。</p>
<p>因为无论怎么分，都是以一行或者一列为单位的，那么这里面所有的元素都会划在同一个区域</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; vec[i][j];</span><br><span class="line">            sum += vec[i][j];<span class="comment">//计算所有元素的和，因为只有两个区域</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; m; j++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (j == m - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line">            <span class="comment">//每经过一行，计算所有元素的和，然后计算result</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            count += vec[i][j];</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) result = <span class="built_in">min</span> (result, <span class="built_in">abs</span>(sum - count - count));</span><br><span class="line">			<span class="comment">//同样作用在列上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-244 代码随想录之链表</title>
    <url>/2025/07/24/day4/</url>
    <content><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点-力扣（LeetCode）"><a href="#19-删除链表的倒数第-N-个结点-力扣（LeetCode）" class="headerlink" title="19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></h1><p>先让cur节点往后跑n-1个，然后一起后移cur和pre。</p>
<p>这样当cur是最后一个节点时，pre就指向的是倒数第n个节点的前一个节点了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummynode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummynode-&gt;next = head;</span><br><span class="line">        ListNode* pre = dummynode;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> dummynode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="面试题-02-07-链表相交-力扣（LeetCode）"><a href="#面试题-02-07-链表相交-力扣（LeetCode）" class="headerlink" title="面试题 02.07. 链表相交 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></h1><p>设「第一个公共节点」为 node ，「链表 headA」的节点数量为 a ，「链表 headB」的节点数量为 b ，「两链表的公共尾部」的节点数量为 c ，则有：</p>
<p>头节点 headA 到 node 前，共有 a−c 个节点；<br>头节点 headB 到 node 前，共有 b−c 个节点；</p>
<p>那么让两个链表头先遍历完本身，再去从对方的头开始遍历，直到到达公共节点时指针 A , B 重合（如下所示）：<br>$a+(b−c)&#x3D;b+(a−c)$</p>
<p>并有两种情况：</p>
<ul>
<li>若两链表 有 公共尾部 (即 c&gt;0 ) ：指针 A , B 同时指向「第一个公共节点」node 。</li>
<li>若两链表 无 公共尾部 (即 c&#x3D;0 ) ：指针 A , B 同时指向 null 。<br>此时返回A、B均可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A = headA;</span><br><span class="line">        ListNode *B = headB;</span><br><span class="line">        <span class="keyword">while</span>(A != B)&#123;</span><br><span class="line">            A = A != <span class="literal">NULL</span>? A-&gt;next : headB;</span><br><span class="line">            B = B != <span class="literal">NULL</span>? B-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="142-环形链表-II-力扣（LeetCode）"><a href="#142-环形链表-II-力扣（LeetCode）" class="headerlink" title="142. 环形链表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></h1><p>能想到用快慢指针，快指针走2n步，慢指针走n步，通过是否碰撞来检测环的存在。</p>
<p>但是第一次确实没想到要怎么判断环的入口在哪里</p>
<p>借一下灵神的图吧<br> <img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250724/vR3R/986X829/LT142.png" alt="986X829&#x2F;LT142.png"></p>
<blockquote>
<p>[!NOTE] 链接<br><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/1999271/mei-xiang-ming-bai-yi-ge-shi-pin-jiang-t-nvsq/">142. 环形链表 II - 力扣（LeetCode）</a></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">while</span> (slow != head) &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>7-25 代码随想录之哈希表</title>
    <url>/2025/07/25/day5/</url>
    <content><![CDATA[<h1 id="242-有效的字母异位词-力扣（LeetCode）"><a href="#242-有效的字母异位词-力扣（LeetCode）" class="headerlink" title="242. 有效的字母异位词 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（LeetCode）</a></h1><p>可以用哈希，也可以直接大小为26的数组。如果是unicode字符，那就必须用哈希了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)&#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t)&#123;</span><br><span class="line">            hash[c]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : hash)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="349-两个数组的交集-力扣（LeetCode）"><a href="#349-两个数组的交集-力扣（LeetCode）" class="headerlink" title="349. 两个数组的交集 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集 - 力扣（LeetCode）</a></h1><p>维护一个set。前面插入，后面删除。如果删除成功（即之前加入了），就加入结果集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; n1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : nums1)&#123;</span><br><span class="line">            n<span class="number">1.</span><span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n<span class="number">1.</span><span class="built_in">erase</span>(b))&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="202-快乐数-力扣（LeetCode）"><a href="#202-快乐数-力扣（LeetCode）" class="headerlink" title="202. 快乐数 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></h1><p>既然有可能无限循环，那就说明会遇到重复的数。</p>
<p>简单计算一下，即使是9999计算后也只是324,。因此一个set是够存放的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SumSquare</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            ans = ans + (a * a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">SumSquare</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>理解网络编程和套接字</title>
    <url>/2024/06/05/%E5%9C%B0%E5%9D%80%E6%97%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="分配给套接字的IP地址和端口号"><a href="#分配给套接字的IP地址和端口号" class="headerlink" title="分配给套接字的IP地址和端口号"></a>分配给套接字的IP地址和端口号</h1><p>IPV4地址为4字节，IPv6 是 16 字节地址族。</p>
<p>端口号是 2 字节，范围是 0<del>65535。其中 0</del>1023 是熟知端口号。</p>
<p>同一协议族端口号不能重复，TCP 套接字和 UDP 套接字不会共用端口号，所以两者之间允许重复。</p>
<h1 id="地址信息的表示"><a href="#地址信息的表示" class="headerlink" title="地址信息的表示"></a>地址信息的表示</h1><h2 id="表示IPV4地址的结构体sockaddr-in"><a href="#表示IPV4地址的结构体sockaddr-in" class="headerlink" title="表示IPV4地址的结构体sockaddr_in"></a>表示IPV4地址的结构体sockaddr_in</h2><p>下面这个结构体将作为地址信息传递给 bind 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span> </span><br><span class="line">	<span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族 </span></span><br><span class="line">	<span class="type">uint16_t</span> sin_port; <span class="comment">// 16 位端口号 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// 表示 32 位 IP 地址的结构体 </span></span><br><span class="line">	<span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">// 不使用 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中用于表示 IP 地址的结构体 in_addr 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span> </span><br><span class="line">	<span class="type">in_addr_t</span> s_addr; <span class="comment">// 32 位 IP 地址，实际位为 uint32_t 类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员分析"><a href="#成员分析" class="headerlink" title="成员分析"></a>成员分析</h2><h3 id="sin-family"><a href="#sin-family" class="headerlink" title="sin_family"></a>sin_family</h3><p>不同协议族使用的地址族不同，如 PF_INET(IPv4 协议族) 对应的地址族是 AF_INET( IPv4 地址族)。<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/jZdd/891X163/dress_Family.png" alt="891X163&#x2F;dress_Family.png"></p>
<h3 id="成员sin-port"><a href="#成员sin-port" class="headerlink" title="成员sin_port"></a>成员sin_port</h3><p>以网络字节序保存 16 位端口号。</p>
<h3 id="成员sin-addr"><a href="#成员sin-addr" class="headerlink" title="成员sin_addr"></a>成员sin_addr</h3><p>类型为 in_addr，in_addr 的成员 s_addr 按网络字节序保存 32 位 IP 地址。</p>
<h3 id="成员sin-zero"><a href="#成员sin-zero" class="headerlink" title="成员sin_zero"></a>成员sin_zero</h3><p>无特殊含义。只是为了使结构体 sockaddr_in 的大小与 sockaddr 结构体一致而插入的成员，必须填充为 0</p>
<h2 id="sockaddr-in的传递"><a href="#sockaddr-in的传递" class="headerlink" title="sockaddr_in的传递"></a>sockaddr_in的传递</h2><p>bind 的第二个参数期望得到的是 sockaddr 结构体变量的地址值，但是 sockaddr 的成员填充起来比较麻烦，因此使用 sockaddr_in 结构体来代替它。</p>
<p>使用 sockaddr_in 结构体生成的字节流也符合 bind 函数的要求，只需在传递地址时转换为 sockaddr* 类型即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> </span><br><span class="line">... </span><br><span class="line"><span class="keyword">if</span>(bind(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>) </span><br><span class="line">	error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="sockaddr结构体"><a href="#sockaddr结构体" class="headerlink" title="sockaddr结构体"></a>sockaddr结构体</h2><p>sockaddr 结构体定义如下，它是通用的结构体，并非只为 IPv4 设计，而 sockaddr_in 是保存 IPv4 地址信息的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span> </span><br><span class="line">	<span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族 </span></span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// 地址信息 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络字节序和地址变换"><a href="#网络字节序和地址变换" class="headerlink" title="网络字节序和地址变换"></a>网络字节序和地址变换</h1><h2 id="字节序与网络字节序"><a href="#字节序与网络字节序" class="headerlink" title="字节序与网络字节序"></a>字节序与网络字节序</h2><p>CPU 向内存保存数据的方式有两种：</p>
<ol>
<li>大端序：高位字节存放到低位地址。网络字节序为大端序。</li>
<li>小端序：高位字节存放到高位地址。目前主流的 Intel 系列 CPU 按小端序方式保存数据。</li>
</ol>
<p>在使用网络发送数据时要先把数据转化成大端序，接收时也要先转换为主机字节序。</p>
<h2 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h2><p>htons 中的 h 代表主机字节序，n 代表网络字节序。</p>
<p>s 代表 short 类型，处理 2 字节数据，用于端口号转换；l 代表 long 类型（Linux 中 long 占用 4 字节），处理 4 字节数据，用于 IP 地址转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;short 类型，用于端口号的转换&#x27;</span> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>;</span><br><span class="line"> <span class="string">&#x27;long 类型，用于 IP 地址的转换&#x27;</span> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>除了向 sockaddr_in 结构体变量填充数据时需要进行字节序转换外，其他情况无需考虑字节序问题，会自动转换。</p>
<h1 id="网络地址的初始化和分配"><a href="#网络地址的初始化和分配" class="headerlink" title="网络地址的初始化和分配"></a>网络地址的初始化和分配</h1><p>sockaddr_in 中保存地址信息的成员是 32 位整型，而一般我们描述 IP 地址时用的是字符串格式的点分十进制表示法，因此需要将字符串形式的 IP 地址转换为 32 位整型数据。</p>
<p>有两个函数可以完成以上功能：inet_addr 函数和 inet_aton 函数</p>
<h2 id="inet-addr函数"><a href="#inet-addr函数" class="headerlink" title="inet_addr函数"></a>inet_addr函数</h2><p>inet_addr 函数在转换类型的同时也会完成网络字节序的转换，它还可以检测无效的 IP 地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>)</span>; </span><br><span class="line"><span class="comment">// 功能：将字符串形式的 IP 地址转换为 32 位整型数据并返回。 </span></span><br><span class="line"><span class="comment">// 返回值：成功时返回 32 位大端序整型值，失败时返回 INADDR_NONE。</span></span><br></pre></td></tr></table></figure>
<h2 id="inet-aton函数"><a href="#inet-aton函数" class="headerlink" title="inet_aton函数"></a>inet_aton函数</h2><p>inet_aton 函数和 inet_addr 函数的功能相同，也是将字符串形式的 IP 地址转换为 32 位网络字节序整数，但是它利用了 in_addr 结构体，使用频率更高。</p>
<p>inet_aton 需要传递一个 in_addr 类型结构体的指针，它会将转换结果直接放入该指针所指的 in_addr 结构体中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>, <span class="keyword">struct</span> in_addr* addr)</span>; </span><br><span class="line"><span class="comment">// 功能：将字符串形式的 IP 地址转换为 32 位网络字节序整数并存储到 addr 中。 </span></span><br><span class="line"><span class="comment">// 返回值：成功时返回 1，失败时返回 0</span></span><br></pre></td></tr></table></figure>
<h2 id="inet-ntoa函数"><a href="#inet-ntoa函数" class="headerlink" title="inet_ntoa函数"></a>inet_ntoa函数</h2><p>inet_ntoa 函数与 inet_aton 函数相反，它将网络字节序的整数型 IP 地址转换为字符串形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr adr)</span>; </span><br><span class="line"><span class="comment">// 功能：将网络字节序的整数型 IP 地址转换为字符串形式 </span></span><br><span class="line"><span class="comment">// 返回值：成功时返回转换的字符串地址值，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>该函数使用时要小心：返回值类型为 char 指针，返回字符串地址意味着字符串已保存到内存中，但该函数是在内部申请了内存并保存了字符串，因此如果再次调用 inet_ntoa 函数，也有可能覆盖之前保存的字符串信息。</p>
<p>因此要将返回的字符串信息复制到其他内存空间。</p>
<h2 id="网络地址初始化"><a href="#网络地址初始化" class="headerlink" title="网络地址初始化"></a>网络地址初始化</h2><p>下面是服务器端套接字创建过程中常见的网络地址信息初始化方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span> </span><br><span class="line"><span class="type">char</span> *serv_ip = <span class="string">&quot;211.217.168.13&quot;</span>; <span class="comment">// 声明 IP 地址字符串 </span></span><br><span class="line"><span class="type">char</span> *serv_port = <span class="string">&quot;9190&quot;</span>; <span class="comment">// 声明端口号字符串 </span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)); <span class="comment">// 结构体变量 addr 的所有成员初始化为 0，主要是为了将 sockaddr_in 的成员 sin_zero 初始化为 0。 </span></span><br><span class="line">addr.sin_family = AF_INET; <span class="comment">// 指定地址族 </span></span><br><span class="line">addr.sin_addr.s_addr = inet_addr(serv_ip); <span class="comment">// 基于字符串的 IP 地址初始化 </span></span><br><span class="line">addr.sin_port = htons(atoi(serv_port)); <span class="comment">// 基于字符串的端口号初始化</span></span><br></pre></td></tr></table></figure>
<p>服务器端和客户端都要进行网络地址信息的初始化，但目的不同：</p>
<ol>
<li>服务器端要将声明的 sockaddr_in 结构体变量初始化为自己的 IP 地址和端口号，用于在 bind 函数中与自己的套接字相绑定。</li>
<li>客户端也要将声明的 sockaddr_in 结构体变量初始化为服务器端的 IP 地址和端口号，用于在 connect 函数中向服务器发起连接请求。</li>
</ol>
<h2 id="INADDR-ANY"><a href="#INADDR-ANY" class="headerlink" title="INADDR_ANY"></a>INADDR_ANY</h2><p>可以用常数 INADDR_ANY 来获取服务器端的 IP 地址</p>
<p><code>addr.sin_addr.s_addr = htonl(INADDR_ANY); // INADDR_ANY 相当于主机字节序的 32 位整型 IP 地址</code></p>
<p>使用 INADDRY_ANY，如果同一个计算机具有多个 IP 地址，那么可以从不同 IP 地址（的同一端口号）接收数据，因此服务器端中优先使用 INADDR_ANY，而客户端不应该采用。</p>
<h1 id="基于Windows的实现"><a href="#基于Windows的实现" class="headerlink" title="基于Windows的实现"></a>基于Windows的实现</h1><p>在 Windows 中使用 htons、inet_addr、inet_ntoa 函数的方式与在 Linux 中相同，但是要运行它们都需要在项目中添加 ws2_32.lib 库，再将 SDL 检查设为否。</p>
<p>注意：Windows 系统中没有 inet_ntoa 函数，因此要将点分十进制字符串格式的 IP 地址转换为整型只能使用 inet_addr 函数。</p>
<p>WSAStringToAddress&amp;WSAAddressToString</p>
<p>WinSock2.h 增加了两个函数：WSAStringToAddress 和 WSAAddressToString，它们的功能和 inet_addr 函数、inet_ntoa 函数相同，优点是可以用于 IPv4、IPv6 等多种协议，缺点是只能用于 Windows 系统，不利于在 Windows 和 Linux 之间移植，一般使用较少。</p>
<p>这两个函数的详细定义及使用方法详见原书相关章节。</p>
<h1 id="POSIX定义的数据类型"><a href="#POSIX定义的数据类型" class="headerlink" title="POSIX定义的数据类型"></a>POSIX定义的数据类型</h1><p>POSIX（可移植操作系统接口）是为 UNIX 系列操作系统设立的标准，它定义了一些数据类型。</p>
<p>常见的这些基类类型如 int32_t 等位于 sys&#x2F;types.h 文件中，套接字相关的类型位于 sys&#x2F;socket.h 文件中。<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/tAYy/890X345/data_structure_in_POSIX.png" alt="890X345&#x2F;data_structure_in_POSIX.png"></p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="endian-conv-c"><a href="#endian-conv-c" class="headerlink" title="endian_conv.c"></a>endian_conv.c</h2><p>这是一个练习网络字节序与主机字节序之间的转换的程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> host_port = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> net_port;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> host_addr = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> net_addr;</span><br><span class="line"></span><br><span class="line">    net_port = htons(host_port);</span><br><span class="line">    net_addr = htonl(host_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host ordered port: %#x \n&quot;</span>, host_port);         <span class="comment">// 打印结果：0x1234</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network ordered port: %#x \n&quot;</span>, net_port);       <span class="comment">// 打印结果：0x3412</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host ordered address: %#x \n&quot;</span>, host_addr);      <span class="comment">// 打印结果：0x12345678</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network ordered address: %#x \n&quot;</span>, net_addr);    <span class="comment">// 打印结果：0x78563412</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inet-addr-c"><a href="#inet-addr-c" class="headerlink" title="inet_addr.c"></a>inet_addr.c</h2><p>此程序用来了解 inet_addr 函数的用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *addr1 = <span class="string">&quot;1.2.3.4&quot;</span>;    </span><br><span class="line">    <span class="type">char</span> *addr2 = <span class="string">&quot;1.2.3.256&quot;</span>;   <span class="comment">// 错误的 IP 地址：一个字节能表示的最大整数是 255</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> conv_addr = inet_addr(addr1);  <span class="comment">// 将 &quot;1.2.3.4&quot; 转换为 0x4030201 并返回</span></span><br><span class="line">    <span class="keyword">if</span> (conv_addr == INADDR_NONE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occured! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#lx \n&quot;</span>, conv_addr);  </span><br><span class="line"></span><br><span class="line">    conv_addr = inet_addr(addr2);   <span class="comment">// 因为 IP 地址无效而返回 INADDR_NONE</span></span><br><span class="line">    <span class="keyword">if</span> (conv_addr == INADDR_NONE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error occured! \n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#lx \n\n&quot;</span>, conv_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inet-aton-c"><a href="#inet-aton-c" class="headerlink" title="inet_aton.c"></a>inet_aton.c</h2><p>此程序用来了解 inet_aton 函数的用法，inet_aton 函数可以将字符串形式的 IP 地址转换为 32 位网络字节序整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *addr = <span class="string">&quot;127.232.124.79&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_inet</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inet_aton(addr, &amp;addr_inet.sin_addr))      <span class="comment">// 注意 inet_aton 的用法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Conversion error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Network ordered integer addr: %#x \n&quot;</span>, addr_inet.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inet-ntoa-c"><a href="#inet-ntoa-c" class="headerlink" title="inet_ntoa.c"></a>inet_ntoa.c</h2><p>此程序用来了解 inet_ntoa 函数的用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr1</span>, <span class="title">addr2</span>;</span></span><br><span class="line">    <span class="type">char</span> *str_ptr;</span><br><span class="line">    <span class="type">char</span> str_arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    addr1.sin_addr.s_addr = htonl(<span class="number">0x1020304</span>);</span><br><span class="line">    addr2.sin_addr.s_addr = htonl(<span class="number">0x1010101</span>);</span><br><span class="line"></span><br><span class="line">    str_ptr = inet_ntoa(addr1.sin_addr);</span><br><span class="line">    <span class="built_in">strcpy</span>(str_arr, str_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation1: %s \n&quot;</span>, str_ptr);</span><br><span class="line"></span><br><span class="line">    inet_ntoa(addr2.sin_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation2: %s \n&quot;</span>, str_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dotted-Decimal notation3: %s \n&quot;</span>, str_arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++ 网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于TCP的服务器端和客户端-1</title>
    <url>/2024/06/07/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF-1/</url>
    <content><![CDATA[<h1 id="理解TCP-UDP"><a href="#理解TCP-UDP" class="headerlink" title="理解TCP&#x2F;UDP"></a>理解TCP&#x2F;UDP</h1><p>计网学过，不赘述</p>
<h1 id="实现基于TCP的服务器端-客户端"><a href="#实现基于TCP的服务器端-客户端" class="headerlink" title="实现基于TCP的服务器端&#x2F;客户端"></a>实现基于TCP的服务器端&#x2F;客户端</h1><h2 id="服务器端进入等待连接请求状态"><a href="#服务器端进入等待连接请求状态" class="headerlink" title="服务器端进入等待连接请求状态"></a>服务器端进入等待连接请求状态</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待连接请求状态：当服务器在此状态下时，在调用 accept 函数受理连接请求前，请求会处于等待状态。注意：这里说的是让来自客户端的请求处于等待状态，以等待服务器端受理它们的请求。</p>
<p>连接请求等待队列：还未受理的连接请求在此排队，backlog 的大小决定了队列的最大长度，一般频繁接受请求的 Web 服务器的 backlog 至少为 15。</p>
<h2 id="服务器端受理客户端连接请求"><a href="#服务器端受理客户端连接请求" class="headerlink" title="服务器端受理客户端连接请求"></a>服务器端受理客户端连接请求</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>accept 函数会受理连接请求等待队列中待处理的客户端连接请求，它从等待队列中取出 1 个连接请求，创建套接字并完成连接请求。如果等待队列为空，accpet 函数会阻塞，直到队列中出现新的连接请求才会返回。</p>
<p>它会在内部产生一个新的套接字并返回其文件描述符，该套接字用于与客户端建立连接并进行数据 I&#x2F;O。新的套接字是在 accept 函数内部自动创建的，并自动与发起连接请求的客户端建立连接。</p>
<p>accept 执行完毕后会将它所受理的连接请求对应的客户端地址信息存储到第二个参数 addr 中。</p>
<h2 id="客户端发起连接请求"><a href="#客户端发起连接请求" class="headerlink" title="客户端发起连接请求"></a>客户端发起连接请求</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>客户端调用 connect 函数后会阻塞，直到发生以下情况之一才会返回：</p>
<ol>
<li>服务器端接收连接请求。</li>
<li>发生断网等异常情况而中断连接请求。</li>
</ol>
<blockquote>
<p>[!NOTE] “接收连接请求”<br>注意：上面说的”接收连接请求“并不是服务器端调用了 accept 函数，而是服务器端把连接请求信息记录到等待队列。因此 connect 函数返回后并不立即进行数据交换。</p>
</blockquote>
<h2 id="基于TCP的服务器端-客户端函数调用关系"><a href="#基于TCP的服务器端-客户端函数调用关系" class="headerlink" title="基于TCP的服务器端&#x2F;客户端函数调用关系"></a>基于TCP的服务器端&#x2F;客户端函数调用关系</h2><p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/l5xm/556X483/function_call_order.png" alt="556X483&#x2F;function_call_order.png"><br>客户端只有等到服务器端调用 listen 函数后才能调用 connect 函数，否则会连接失败。</p>
<p>客户端调用 connect 函数和服务器端调用 accept 函数的顺序不确定，先调用的要等待另一方。</p>
<h1 id="实现迭代服务器端-客户端"><a href="#实现迭代服务器端-客户端" class="headerlink" title="实现迭代服务器端&#x2F;客户端"></a>实现迭代服务器端&#x2F;客户端</h1><p>回声服务器端：它会将客户端传输的字符串数据原封不动地传回客户端，像回声一样。</p>
<h2 id="实现迭代服务器端"><a href="#实现迭代服务器端" class="headerlink" title="实现迭代服务器端"></a>实现迭代服务器端</h2><p>调用一次 accept 函数只会受理一个连接请求，如果想要继续受理请求，最简单的方法就是循环反复调用 accept 函数，在前一个连接 close 之后，重新 accept。</p>
<p>在不使用多进程&#x2F;多线程情况下，同一时间只能服务于一个客户端。</p>
<h2 id="迭代回声服务器端-客户端"><a href="#迭代回声服务器端-客户端" class="headerlink" title="迭代回声服务器端&#x2F;客户端"></a>迭代回声服务器端&#x2F;客户端</h2><p>迭代回声服务器端与回声客户端的基本运行方式：</p>
<ol>
<li>服务器端同一时刻只与一个客户端相连接，并提供回声服务。</li>
<li>服务器端依次向 5 个客户端提供服务，然后退出。</li>
<li>客户端接收用户输入的字符串并发送到服务器端。</li>
<li>服务器端将接收到的字符串数据传回客户端，即”回声“。</li>
<li>服务器端与客户端之间的字符串回声一直执行到客户端输入 Q 为止。</li>
</ol>
<p>具体实现见最后本章的程序实例</p>
<h2 id="回声客户端的问题"><a href="#回声客户端的问题" class="headerlink" title="回声客户端的问题"></a>回声客户端的问题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(sock, message, <span class="built_in">strlen</span>(message)); </span><br><span class="line">str_len = <span class="built_in">read</span>(sock, message, BUF_SIZE - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在本章的回声客户端的实现中有上面这段代码，它有一个错误假设：每次调用 read、write 函数时都会执行实际的 I&#x2F;O 操作。</p>
<p>但是注意：TCP 是面向连接的字节流传输，不存在数据边界。所以多次 write 的内容可能一直存放在发送缓存中，某个时刻再一次性全都传递到服务器端，这样的话客户端前几次 read 都不会读取到内容，最后才会一次性收到前面多次 write 的内容。还有一种情况是服务器端收到的数据太大，只能将其分成多个数据包发送给客户端，然后客户端可能在尚未收到全部数据包时旧调用 read 函数。</p>
<p>理解：问题的核心在于 write 函数实际上是把数据写到了发送缓存中，而 read 函数是从接收缓存读取数据。并不是直接对 TCP 连接的另一方进行数据读写。</p>
<h1 id="4-4-基于Windows的实现"><a href="#4-4-基于Windows的实现" class="headerlink" title="4.4 基于Windows的实现"></a>4.4 基于Windows的实现</h1><p>将 Linux 平台下的实例转化为 Windows 下的实例，记住以下四点：</p>
<ol>
<li>通过 WSAStartup、WSACleanup 函数初始化并清除套接字相关库。</li>
<li>把数据类型和变量名切换为 Windows 风格。</li>
<li>数据传输中用 recv、send 函数而非 read、write 函数。</li>
<li>关闭套接字时用 closesocket 函数而非 close 函数。</li>
</ol>
<h1 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h1><h2 id="echo-server-c"><a href="#echo-server-c" class="headerlink" title="echo_server.c"></a>echo_server.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock; <span class="comment">// 这个 clnt_sock 将用来表示服务器端上真正与客户端相连接的那个套接字</span></span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, clnt_adr; <span class="comment">// 这个 clnt_adr 将用来存储连接的客户端的地址信息，注意和 clnt_sock 表示的对象的不同</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz = <span class="built_in">sizeof</span>(clnt_adr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">error_handling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connected client %d \n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(clnt_sock, message, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">write</span>(clnt_sock, message, str_len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="echo-client-c"><a href="#echo-client-c" class="headerlink" title="echo_client.c"></a>echo_client.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(message, BUF_SIZE, stdin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        str_len = <span class="built_in">read</span>(sock, message, BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++ 网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于TCP的服务器端和客户端-1</title>
    <url>/2024/06/08/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF-2/</url>
    <content><![CDATA[<h1 id="回声客户端的完美实现"><a href="#回声客户端的完美实现" class="headerlink" title="回声客户端的完美实现"></a>回声客户端的完美实现</h1><p>服务端没有问题</p>
<p>回声客户端的问题实际上就是没有考虑拆包和粘包的情况。</p>
<h2 id="回声客户端问题的解决方法"><a href="#回声客户端问题的解决方法" class="headerlink" title="回声客户端问题的解决方法"></a>回声客户端问题的解决方法</h2><p>解决方法的核心：提前确定接收数据的大小。</p>
<p>客户端上一次使用 write 从套接字发送了多少字节，紧接着就使用 read 从套接字读取多少字节。</p>
<p>程序示例见 echo_client2.c</p>
<h2 id="定义应用层协议"><a href="#定义应用层协议" class="headerlink" title="定义应用层协议"></a>定义应用层协议</h2><p>上面的回声客户端中，提前就知道要接收的数据长度，但是一般是不知道的。这种情况下，要解决拆包和粘包的问题，就要定义应用层协议。</p>
<p>应用层协议实际就是在服务器端&#x2F;客户端的实现过程中逐步定义的规则的集合。</p>
<p>在应用层协议中可以定好数据边界的表示方法、数据的长度范围等。</p>
<h1 id="计算器服务器端-客户端示例"><a href="#计算器服务器端-客户端示例" class="headerlink" title="计算器服务器端&#x2F;客户端示例"></a>计算器服务器端&#x2F;客户端示例</h1><p>程序内容见 op_client.c 和 op_server.c。</p>
<h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h2><p>服务器从客户端获得操作数和运算符信息，完成计算后把结果传回客户端。</p>
<p>客户端运行方式及运行结果如图所示：<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/bMlH/456X158/run_op-client.png" alt="456X158&#x2F;run_op-client.png"></p>
<h2 id="程序实现方法"><a href="#程序实现方法" class="headerlink" title="程序实现方法"></a>程序实现方法</h2><p>为了实现以上功能，定义了一个简单的应用层协议，用来约定在服务器端和客户端之间传输数据的规则。</p>
<p>协议内容包括：</p>
<ol>
<li>客户端用 1 个字节整数形式传递操作数的个数。</li>
<li>客户端向服务器端传送的每个操作数占用 4 字节。</li>
<li>传递完操作数后紧跟着传递一个占用 1 字节的运算符。</li>
<li>服务器端以 4 字节整数向客户端传回运算结果。</li>
<li>客户端得到运算结果后终止与服务器端的连接。</li>
</ol>
<h1 id="TCP原理"><a href="#TCP原理" class="headerlink" title="TCP原理"></a>TCP原理</h1><h2 id="TCP套接字中的IO缓冲"><a href="#TCP套接字中的IO缓冲" class="headerlink" title="TCP套接字中的IO缓冲"></a>TCP套接字中的IO缓冲</h2><p>在使用 read&#x2F;write 函数对套接字进行读写数据时，实际上读写的是套接字输入&#x2F;输出缓冲中的内容。</p>
<p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/fPlt/741X292/true_IO_in_TCP.png" alt="741X292&#x2F;true_IO_in_TCP.png"><br>套接字 I&#x2F;O 缓冲的特性：</p>
<ol>
<li>I&#x2F;O 缓冲在每个套接字中单独存在。</li>
<li>I&#x2F;O 缓冲在创建套接字时自动生成。</li>
<li>即使关闭套接字也会继续传递输出缓冲中遗留的数据。</li>
<li>关闭套接字将丢失输入缓冲中的数据</li>
</ol>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><h2 id="echo-client2-c"><a href="#echo-client2-c" class="headerlink" title="echo_client2.c"></a>echo_client2.c</h2><p>此程序是回声客户端的完美实现，它记录了发送给服务器端的数据的长度，然后从套接字读取相同长度的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, recv_len, recv_cnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, stdout);</span><br><span class="line">        <span class="built_in">fgets</span>(message, BUF_SIZE, stdin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        str_len = <span class="built_in">write</span>(sock, message, <span class="built_in">strlen</span>(message));  <span class="comment">// 发送了 str_len 个字节</span></span><br><span class="line">        recv_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (recv_len &lt; str_len)</span><br><span class="line">        &#123;</span><br><span class="line">            recv_cnt = <span class="built_in">read</span>(sock, &amp;message[recv_len], BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (recv_cnt == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">error_handling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">            recv_len += recv_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="op-client-c"><a href="#op-client-c" class="headerlink" title="op_client.c"></a>op_client.c</h2><p>这是计算器客户端的实现。</p>
<p>注意两个地方：</p>
<ol>
<li>应用层协议的定义和实现。</li>
<li>在同一个数组中保存并传输多种数据类型的方式：将数组声明为 char 类型，在向数组读写内容时转换指针的类型。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPSZ 4 <span class="comment">// 定义每个操作数在 TCP 报文中占用的字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> opmsg[BUF_SIZE]; <span class="comment">// opmsg 用来存储要发送的数据，注意是 char 类型数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="type">int</span> operand_count, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)))</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connecting..........\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operand count: &quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;operand_count);</span><br><span class="line">    opmsg[<span class="number">0</span>] = (<span class="type">char</span>)operand_count; <span class="comment">// 数据的第一个字节存储操作数的数量，注意要将变量类型转换为 char。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; operand_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Operand %d: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="type">int</span> *)&amp;opmsg[i * OPSZ + <span class="number">1</span>]); <span class="comment">// 从第二个字节开始每四个字节存储一个操作数，向数组存数据时先取地址再转换类型。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fgetc</span>(stdin);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operator: &quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;opmsg[operand_count * OPSZ + <span class="number">1</span>]); <span class="comment">// 再用一个字节存储运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(sock, opmsg, operand_count * OPSZ + <span class="number">2</span>); <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="built_in">read</span>(sock, &amp;result, OPSZ);                    <span class="comment">// 接收运算结果：运算结果是一个 4 字节的操作数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Operation result: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="op-server-c"><a href="#op-server-c" class="headerlink" title="op_server.c"></a>op_server.c</h2><p>这是计算器服务器端的实现。</p>
<p>原书中这里有一个问题，如果决定要用一个字节来接收客户端发送的操作数个数，那么就应该用 char 类型的变量来接收，而不是 int 类型。</p>
<p>因为int类型的变量在某些平台上可能占用4个字节，而char类型的变量只占用1个字节，这样会导致接收的数据不正确。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPSZ 4</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> operand_count, <span class="type">int</span> operands[], <span class="type">char</span> <span class="keyword">operator</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">int</span> clnt_addr_sz;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_addr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_addr, &amp;clnt_addr_sz)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">error_handling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> op_cnt_char;</span><br><span class="line">        <span class="type">int</span> operand_count;</span><br><span class="line">        <span class="built_in">read</span>(clnt_sock, &amp;op_cnt_char, <span class="number">1</span>); <span class="comment">// 读取1个字节到 char 变量中</span></span><br><span class="line">        operand_count = (<span class="type">int</span>)op_cnt_char; <span class="comment">// 然后再转换为 int</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> operands[BUF_SIZE];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; operand_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(clnt_sock, &amp;operands[i * OPSZ], OPSZ); <span class="comment">// 根据操作数数量，依次读取操作数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="keyword">operator</span>;</span><br><span class="line">        <span class="built_in">read</span>(clnt_sock, &amp;<span class="keyword">operator</span>, <span class="number">1</span>); <span class="comment">// 读取运算符</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">calculate</span>(operand_count, (<span class="type">int</span> *)operands, <span class="keyword">operator</span>);</span><br><span class="line">        <span class="built_in">write</span>(clnt_sock, (<span class="type">char</span> *)&amp;result, <span class="built_in">sizeof</span>(result)); <span class="comment">// 发送计算结果</span></span><br><span class="line">        <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> operand_count, <span class="type">int</span> operands[], <span class="type">char</span> <span class="keyword">operator</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = operands[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">operator</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; operand_count; i++)</span><br><span class="line">            result += operands[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; operand_count; i++)</span><br><span class="line">            result -= operands[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; operand_count; i++)</span><br><span class="line">            result *= operands[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++ 网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈协程</title>
    <url>/2024/06/30/%E6%B5%85%E8%B0%88%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>探讨协程的底层实现，剖析开源库 libco 的实现，并在此基础之上实现一个简单的协程</p>
<span id="more"></span>
<h1 id="浅谈协程"><a href="#浅谈协程" class="headerlink" title="浅谈协程"></a>浅谈协程</h1><h2 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h2><p>协程就是用户态的线程，但是上下文切换的时机是靠调用方（写代码的开发人员）自身去控制的。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  <span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单线程中，上述函数的输出为：<code>1 2 3 x y z</code></p>
<p>如果我们用 libco 库将上面程序改造一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   co_yield_ct();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   co_yield_ct();  <span class="comment">// 切出到主协程</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;z&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...  <span class="comment">// 主协程</span></span><br><span class="line">  co_resume(A);  <span class="comment">// 启动协程 A</span></span><br><span class="line">  co_resume(B);  <span class="comment">// 启动协程 B</span></span><br><span class="line">  co_resume(A);  <span class="comment">// 从协程 A 切出处继续执行</span></span><br><span class="line">  co_resume(B);  <span class="comment">// 从协程 B 切出处继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在单线程中，改造后的程序输出如下：<code>1 2 x 3 y z</code></p>
<p>xxxxxxxxxx23 1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3​4vector<string> vec(25);5​6bool cmp(const string &amp;a, const string &amp;b){7    return a+b &gt; b+a;8}9​10int main(){11    int n;12    cin &gt;&gt; n;13    for(int i &#x3D; 0; i &lt; n; i++){14        cin &gt;&gt; vec[i];15    }16    sort(vec.begin(), vec.begin() + n, cmp);17    string ans;18    for(int i &#x3D; 0; i &lt; n; i++){19        ans +&#x3D; vec[i];20    }21    cout &lt;&lt; ans &lt;&lt; endl;22    return 0;23}cpp</string></p>
<p>函数 A() 和 B() 并不是一个执行完才执行另一个，而是产生了 “交叉执行“ 的效果，这就是通过协程实现的</p>
<h2 id="为什么不用线程而用协程"><a href="#为什么不用线程而用协程" class="headerlink" title="为什么不用线程而用协程"></a>为什么不用线程而用协程</h2><p>有些时候我们在执行一些操作（尤其是IO操作）时，不希望去做“创建一个新的线程”这种重量级的操作来异步处理。而是希望：<strong>在当前线程执行中，暂时切换到其他任务中执行，同时在IO真正准备好了之后，再切换回来继续执行！</strong></p>
<p>相比于多开一个线程来操作，使用协程的好处：</p>
<ul>
<li><strong>减少了线程的重复高频创建；</strong></li>
<li><strong>尽量避免线程的阻塞；</strong></li>
<li><strong>提升代码的可维护与可理解性（毕竟不需要考虑多线程那一套东西了）</strong></li>
</ul>
<p>下面是一些协程的特点：</p>
<ul>
<li><strong>协程可以主动让出 CPU 时间片；（注意：不是当前线程让出 CPU 时间片，而是线程内的某个协程让出时间片供同线程内其他协程运行；）</strong></li>
<li><strong>协程可以恢复 CPU 上下文；当另一个协程继续执行时，其需要恢复 CPU 上下文环境；</strong></li>
<li><strong>协程有个管理者，管理者可以选择一个协程来运行，其他协程要么阻塞，要么ready，或者died；</strong></li>
<li><strong>运行中的协程将占有当前线程的所有计算资源；</strong></li>
<li><strong>协程天生有栈属性，而且是 lock free；</strong></li>
</ul>
<h1 id="协程的类别"><a href="#协程的类别" class="headerlink" title="协程的类别"></a>协程的类别</h1><p>根据是否存在<strong>调用栈</strong>，可以分为以下两类</p>
<ul>
<li>有栈协程：类似于内核态线程，不同协程间切换还是要切换上下文，只是不需要陷入内核。例如goroutine、libco</li>
<li>无栈协程：上下文放在公共内存中，切换时使用状态机来切换，而不切换对应的上下文（因为已经在堆里了），更轻量，例如：C++20、Rust、JavaScript 中的协程</li>
</ul>
<p>根据是否存在明显的调用关系，可以分为</p>
<ul>
<li>非对称协程：协程间有明显的调用关系</li>
<li>对称协程：无明显调用关系</li>
</ul>
<h2 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h2><p>开源库 libco 就是通过汇编语言实现的有栈协程库。</p>
<p>通过分析代码可以看到，无论是<code>co_yield</code>还是<code>co_resume</code>，在协程切出和恢复时，都调用了同一个函数<code>co_swap</code>，在这个函数中调用了 <code>coctx_swap</code> 来实现协程的切换，这一函数的原型是<br><code>void coctx_swap( coctx_t *,coctx_t* ) asm(&quot;coctx_swap&quot;);</code></p>
<p>两个参数都是 <code>coctx_t *</code> 指针类型，其中第一个参数表示要切出的协程，第二个参数表示切出后要进入的协程；</p>
<p>并不会像常规被调用函数一样创立新栈帧。而是通过调整 <code>%rsp</code> 的值来恢复新协程的栈，并利用了 <code>ret</code> 语句来实现修改指令寄存器 <code>%rip</code> 的目的，通过修改 <code>%rip</code> 来实现程序运行逻辑跳转；</p>
<blockquote>
<p>[!NOTE] %rip的修改<br>不能直接修改，只能通过call或ret来修改</p>
</blockquote>
<p><strong>整体上看来，协程的切换其实就是： cpu 寄存器内容特别是 <code>%rip</code> 和 <code>%rsp</code> 的写入和恢复，因为 cpu 的寄存器决定了程序从哪里执行（%rip) 和使用哪个地址作为堆栈 （%rsp）；</strong></p>
<h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>无栈协程本质上是一个状态机，从另一个角度上：<strong>同一协程切换的本质不过是指令指针寄存器的改变</strong></p>
<p>先来看一个使用libco的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">test</span><span class="params">(<span class="type">void</span>* para)</span></span>&#123; </span><br><span class="line">	<span class="built_in">co_enable_hook_sys</span>(); </span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">poll</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.</span> <span class="number">1000</span>); <span class="comment">// 协程切换执行权，1000ms后返回 </span></span><br><span class="line">	i++; </span><br><span class="line">	<span class="built_in">poll</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.</span> <span class="number">1000</span>); <span class="comment">// 协程切换执行权，1000ms后返回 </span></span><br><span class="line">	i--; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	stCoRoutine_t* routine; </span><br><span class="line">	<span class="built_in">co_create</span>(&amp;routine, <span class="literal">NULL</span>, test, <span class="number">0</span>); <span class="comment">// 创建一个协程 </span></span><br><span class="line">	<span class="built_in">co_resume</span>(routine); </span><br><span class="line">	<span class="built_in">co_eventloop</span>(<span class="built_in">co_get_epoll_ct</span>(),<span class="number">0</span>,<span class="number">0</span> ); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是无栈协程，实现相同逻辑的代码是怎么样的呢？</p>
<p>其实就是翻译成类似于以下状态机的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test_coroutine</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="type">int</span> __state = <span class="number">0</span>; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MoveNext</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="keyword">switch</span>(__state) &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">frist</span>(); </span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">second</span>(); </span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">third</span>(); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">frist</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i = <span class="number">0</span>; __state = <span class="number">1</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i++; _state = <span class="number">2</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		i--; </span><br><span class="line">	&#125; </span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p><strong>把整个协程抽象成一个类，以原本需要执行切换的语句处为界限，把函数划分为几个部分，并在某一个部分执行完以后进行状态转移，在下一次调用此函数的时候就会执行下一部分</strong></p>
<p>这样就完全没有必要像有栈协程那样显式的执行上下文切换了，我们只需要一个简易的调度器来调度这些函数即可；</p>
<p>从执行时栈的角度来看：</p>
<p><strong>其实所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值；</strong></p>
<p><strong>而且相比有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈使得CPU cache局部性更好，同时也使得无栈协程的中断和函数返回几乎没有区别，这样也可以凸显出无栈协程的高效；</strong></p>
<h2 id="对称协程与非对称协程"><a href="#对称协程与非对称协程" class="headerlink" title="对称协程与非对称协程"></a>对称协程与非对称协程</h2><ul>
<li><strong>对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移；</strong></li>
<li><strong>非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系；</strong></li>
</ul>
<p>非对称协程就是拥有调用栈，而对称协程则是大家都平等，不需要调用栈，只需要一个数据结构存储未执行完的协程即可</p>
<p>我个人认为非对称协程相比之下更为符合认知，因为对称协程目前我不知道如何选择一个合适的协程来获得CPU执行权，正如上面所说，此协程可能正在等待事件；当然如果调度算法足够优秀的话，对称协程也是可取的；</p>
<h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><h2 id="N-1-N-M-协程"><a href="#N-1-N-M-协程" class="headerlink" title="N:1 &amp; N:M 协程"></a>N:1 &amp; N:M 协程</h2><p>线程绑定的协程只有在对应线程运行的时候才有被执行的可能，如果对应线程中的某一个协程完全占有了当前线程，那么当前线程中的其他所有协程都不会被执行</p>
<p>协程的所有信息都保存在上下文（Contex）对象中，将不同上下文分发给不同的线程就可以实现协程的跨线程执行，如此，协程被阻塞的概率将减小；</p>
<p>借用 <a href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/bthread.md">BRPC</a> 中对 <code>N:M</code> 协程的介绍，来解释下什么是 <code>N:M</code> 协程：</p>
<p>常说的协程是指的N:1协程库，即所有协程运行在一个系统线程中，<strong>计算能力和各类eventloop库等价</strong></p>
<p>由于不跨线程，那么切换也不需要系统调用，受cache一致性的影响也比较小，可以非常快</p>
<p>但是代价是无法高效利用多核，而且代码必须非阻塞，否则所有协程都会卡住</p>
<p><code>bthread</code> 是一个 <code>M:N</code> 线程库，一个<code>bthread</code>被卡住不会影响其他<code>bthread</code>；</p>
<p>其中的关键技术有两点：</p>
<ul>
<li><strong>work stealing 调度；</strong></li>
<li><strong>butex；</strong></li>
</ul>
<p>前者让 bthread 更快地被调度到更多的核心上，后者让 bthread 和 pthread 可以相互等待和唤醒，这两点协程都不需要；</p>
<p>这么看来 貌似 bthread 自己实现了 golang 的 goroutine？</p>
<p>表面看起来的却如此：两者都实现了 M:N 用户态线程；</p>
<p>但是事实上， golang 中的 goroutine 的实现要更为复杂一些：</p>
<p>bthread 的设计比较接近 go 1.0 版本：OS 线程不会动态增加，在有大量的阻塞性 syscall 下，会有影响；</p>
<p>而 go 1.1 之后的设计就是动态增减 OS 线程，而且提供了 LockOSThread，可以让 goroutine 和 OS 线程 1:1；</p>
<h2 id="协程的组成"><a href="#协程的组成" class="headerlink" title="协程的组成"></a>协程的组成</h2><p>N:M模式下的协程其实就是可以由用户来确定调度顺序的用户态线程，对比系统线程可以分为以下几个模块：</p>
<ul>
<li>协程上下文：对应系统中的PCB&#x2F;TCB</li>
<li>保存协程上下文的容器：对应操作系统中保存 PCB&#x2F;TCB 的容器，一般是一个列表（在实际实现时，协程上下文容器可以使用一个也可以使用多个，比如：普通协程队列、定时的协程优先队列等</li>
<li>协程的执行器<ul>
<li>协程的调度器：对应操作系统中的进程、线程调度器</li>
<li>执行协程的worker线程，对应实际进程&#x2F;线程的CPU核心</li>
</ul>
</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>参照进程调度即可</p>
<h2 id="协程相关工具"><a href="#协程相关工具" class="headerlink" title="协程相关工具"></a>协程相关工具</h2><p>系统级线程有锁、条件变量等工具，</p>
<p><strong>系统级线程和协程处于不同的系统层级，所以两者的同步工具不完全通用，如果在协程中使用了线程的锁（例如：<code>std::mutex</code>），则整个线程将会被阻塞，当前线程将不会再调度与执行其他协程；</strong></p>
<h2 id="对CPU-IO的影响"><a href="#对CPU-IO的影响" class="headerlink" title="对CPU&#x2F;IO的影响"></a>对CPU&#x2F;IO的影响</h2><p>目的在于剔除线程的阻塞，提供CPU利用率</p>
<p>很多服务在处理业务时需要请求第三方服务，向第三方服务发起 RPC 调用；RPC 调用的网络耗时一般耗时在毫秒级别，RPC 服务的处理耗时也可能在毫秒级别，如果当前服务使用同步调用，即 RPC 返回后才进行后续逻辑，那么一条线程每秒处理的业务数量是可以估算的；</p>
<p>假设每次业务处理花费在 RPC 调用上的耗时是 20ms，那么一条线程一秒最多处理 50 次请求！</p>
<p>如果在等待 RPC 返回时当前线程没有被系统调度转换为 Ready 状态，那当前 CPU 核心就会空转，浪费了 CPU 资源！通过增加线程数量提高系统吞吐量的效果非常有限，而且创建大量线程也会造成其他问题！</p>
<p>协程虽然不一定能减少一次业务请求的耗时，但一定可以提升系统的吞吐量：</p>
<ul>
<li>当前业务只有一次第三方 RPC 的调用，那么协程不会减少业务处理的耗时，但可以提升 QPS；</li>
<li>当前业务需要多个第三方 RPC 调用，<strong>同时创建多个协程可以让多个 RPC 调用一起执行，则当前业务的 RPC 耗时由耗时最长的 RPC 调用决定；</strong></li>
</ul>
]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>理解网络编程和套接字</title>
    <url>/2024/06/03/%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<p>对《TCP&#x2F;IP网络编程》第一章的简单总结</p>
<span id="more"></span>
<h1 id="理解网络编程和套接字"><a href="#理解网络编程和套接字" class="headerlink" title="理解网络编程和套接字"></a>理解网络编程和套接字</h1><h2 id="服务端套接字"><a href="#服务端套接字" class="headerlink" title="服务端套接字"></a>服务端套接字</h2><p>套接字编程所用的各函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domin, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">	<span class="comment">//功能：创建套接字</span></span><br><span class="line">	<span class="comment">// 参数：domin:一般为 PF_INET；type:数据传输方式，一般为 SOCK_STREAM；protocol:一般设为 0 即可</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回文件描述符，失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">	<span class="comment">// 功能：为套接字分配地址信息</span></span><br><span class="line">	<span class="comment">// 参数：sockfd:要分配地址信息的套接字文件描述符；myaddr:存有地址信息的结构体变量指针；addrlen：第二个参数的长度</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(itn sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line">	<span class="comment">// 功能：将套接字转换为可接收连接的状态</span></span><br><span class="line">	<span class="comment">// 参数：sockfd:希望进入等待连接请求状态的套接字文件描述符；backlog:连接请求等待队列的长度，最多使 backlog 个连接请求进入队列</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回0，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">	<span class="comment">// 功能：受理连接请求等待队列中待处理的连接请求。</span></span><br><span class="line">	<span class="comment">// 参数：sock：服务器套接字的文件描述符；addr：用于保存发起连接请求的客户端地址信息；addrlen：第二个参数的长度</span></span><br><span class="line">	<span class="comment">// 返回值：成功时返回创建的套接字文件描述符，失败时返回 -1</span></span><br></pre></td></tr></table></figure>

<p>接受连接请求的服务器端套接字编程流程：</p>
<ol>
<li>调用socket函数创建套接字</li>
<li>调用bind函数为套接字分配IP地址和端口号</li>
<li>调用listen函数将套接字转换为可接收状态</li>
<li>调用 accept 函数受理连接请求。accept 会阻塞，直到有连接请求才会返回；</li>
<li>调用 read&#x2F;write 函数进行数据交换；</li>
<li>调用 close 函数断开连接；</li>
</ol>
<h2 id="客户端套接字"><a href="#客户端套接字" class="headerlink" title="客户端套接字"></a>客户端套接字</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>; </span><br><span class="line">			<span class="comment">// 功能：请求连接。 </span></span><br><span class="line">			<span class="comment">// 参数：sock：客户端套接字的文件描述符；serv_addr：保存目标服务器端地址信息的结构体指针；addrlen：第二个参数的长度（单位是字节） </span></span><br><span class="line">			<span class="comment">// 返回值：成功时返回 0，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>客户端请求连接步骤：</p>
<ol>
<li>调用socket函数创建套接字</li>
<li>调用connect函数请求连接</li>
<li>调用read&#x2F;write函数进行数据交换</li>
<li>调用close函数断开连接</li>
</ol>
<p>客户端的 IP 地址和端口在调用 connect 函数时自动分配，无需调用 bind 函数。</p>
<h1 id="基于Linux的文件操作符"><a href="#基于Linux的文件操作符" class="headerlink" title="基于Linux的文件操作符"></a>基于Linux的文件操作符</h1><p>Linux 中套接字描述符也是文件，因此通过套接字发送、接收数据就和读写文件一样，通过 read、write 这些函数来接收、发送数据。</p>
<p>文件描述符是系统分配给文件或套接字的整数。</p>
<p>0、1、2 分别由系统分配给了标准输入、标准输出和标准错误。</p>
<p>文件和套接字创建时才会被分配文件描述符。它们的文件描述符会从 3 开始按序递增。</p>
<p>下面是一些文件描述符的操作函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span> <span class="comment">// fcntl.h 和 unistd.h 包含的内容有些相似，包括 open 函数等。总之使用文件函数时将 fcntl.h 和 unistd.h 都 include 就可以了 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flag)</span></span>;</span><br><span class="line">		<span class="comment">// 功能：按照flag指定的模式打开文件</span></span><br><span class="line">		<span class="comment">// 参数：path：文件名的地址；flag：文件打开的模式</span></span><br><span class="line">		<span class="comment">// 成功时返回文件描述符，失败时返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>; </span><br><span class="line">		<span class="comment">// 功能：关闭 fd 对应的文件或套接字。当关闭一个套接字时会向对方发送 EOF。 </span></span><br><span class="line">		<span class="comment">// 参数：fd：文件或套接字的文件描述符。 </span></span><br><span class="line">		<span class="comment">// 返回值：成功时返回 0，失败时返回 -1</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br><span class="line">		<span class="comment">// 功能：从文件 fd 读取数据。read 函数会阻塞，直到读取到数据或 EOF 才返回。 </span></span><br><span class="line">		<span class="comment">// 参数：fd：文件描述符；buf：保存要接收的数据；nbytes：要接收的最大字节数。 </span></span><br><span class="line">		<span class="comment">// 返回值：成功时返回接收的字节数（遇到文件尾则返回 0），失败时返回 -1</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>; </span><br><span class="line">		<span class="comment">// 功能：向文件 fd 输出数据。 </span></span><br><span class="line">		<span class="comment">// 参数：fd：文件描述符；buf：要传输的数据；nbytes：要传输的字节数。 </span></span><br><span class="line">		<span class="comment">// 返回值：成功时返回写入的字节数，失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<p>size_t 的类型是 unsigned int，ssize_t 的类型是 signed int。<br><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/l3mm/906X266/file_open_mode.png" alt="906X266&#x2F;file_open_mode.png"></p>
<h1 id="基于Windows平台的视线"><a href="#基于Windows平台的视线" class="headerlink" title="基于Windows平台的视线"></a>基于Windows平台的视线</h1><p>Windows 套接字（简称 winsock）大部分是参考 UNIX 套接字设计的，与 Linux 套接字很相似但不完全相同。</p>
<p>大多数项目都是在 Linux 系统下开发服务器端，在 Windows 平台下开发客户端。</p>
<h3 id="为-Windows-套接字编程设置头文件和库"><a href="#为-Windows-套接字编程设置头文件和库" class="headerlink" title="为 Windows 套接字编程设置头文件和库"></a>为 Windows 套接字编程设置头文件和库</h3><p>要在 Windows 上进行套接字编程，需要：</p>
<ol>
<li>链接 ws2_32.lib 库。在 VS 中通过：项目&#x3D;&gt;属性&#x3D;&gt;配置属性&#x3D;&gt;链接器&#x3D;&gt;输入&#x3D;&gt;附加依赖项，添加 ws2_32.lib 库即可</li>
<li>导入头文件 WinSock2.h。Windows 中有一个 winsock.h 和一个 WinSock2.h。其中 WinSock2.h 是较新版本，用来代替前者的</li>
</ol>
<p>实际上在 windows 上还需要通过：项目&#x3D;&gt;属性&#x3D;&gt;配置属性&#x3D;&gt;C++ 将 SDL 检查设为否，否则运行会出错</p>
<h3 id="Winsock的初始化"><a href="#Winsock的初始化" class="headerlink" title="Winsock的初始化"></a>Winsock的初始化</h3><p>进行 Winsock 编程时，必须首先调用 WSAStartup 函数，设置程序中用到的 Winsock 版本，并初始化相应版本的库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested, LPWSADATA lpWSAData)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：初始化 Winsock 库</span></span><br><span class="line">    <span class="comment">// 参数：wVersionRequested：请求使用的 Winsock 版本；lpWSAData：指向 WSADATA 结构体变量的指针</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回错误代码</span></span><br></pre></td></tr></table></figure>
<p>两个参数的详细介绍：</p>
<ul>
<li>WORD wVersionRequested：WORD 类型是通过 typedef 定义的 unsigned short 类型。Winsock 中存在多个套接字版本，要选择需要的版本，0x0202 表示 2.2 版本。可以用 MAKEWORD(2, 2) 来构造版本号，它构造了 2.2 版本的表示值，即返回 0x0202。</li>
<li>LPWSADATA lpWSAData：LPWSADATA 是 WSADATA 类型的指针类型。没有特殊含义，只是为了调用函数，必须传递 WSADATA 类型变量的地址。</li>
</ul>
<h3 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h3><p>下面这段代码几乎是 Winsock 编程的公式。在进行 Winsock 编程时直接按下述方式编写即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123; </span><br><span class="line">	WSADATA wsaData; </span><br><span class="line">	... </span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD9</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error&quot;</span>);</span><br><span class="line">	... </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>注销：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSACleanup</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 调用此函数，Winsock 相关库将还给操作系统，无法再调用 Winsock 相关函数。</span></span><br><span class="line">                <span class="comment">// 成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br></pre></td></tr></table></figure>

<h1 id="基于-Windows-的套接字相关函数"><a href="#基于-Windows-的套接字相关函数" class="headerlink" title="基于 Windows 的套接字相关函数"></a>基于 Windows 的套接字相关函数</h1><p>SOCKET 是 typedef 定义的整型类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：创建套接字</span></span><br><span class="line">    <span class="comment">// 参数：af：一般为 AF_INET；type：数据传输方式，一般为 SOCK_STREAM；protocol：一般设为 0 即可</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回套接字描述符，失败返回 INVALID_SOCKET</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">int</span> addrlen)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：为套接字分配地址信息</span></span><br><span class="line">    <span class="comment">// 参数：s：要分配地址信息的套接字描述符；myaddr：存有地址信息的结构体变量指针；addrlen：第二个参数的长度</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(SOCKET s, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：将套接字转换为可接收连接的状态</span></span><br><span class="line">    <span class="comment">// 参数：s：希望进入等待连接请求状态的套接字描述符；backlog：连接请求等待队列的长度，最多使 backlog 个连接请求进入队列</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：受理连接请求等待队列中待处理的连接请求。</span></span><br><span class="line">    <span class="comment">// 参数：s：服务器套接字的描述符；addr：用于保存发起连接请求的客户端地址信息；addrlen：第二个参数的长度</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回创建的套接字描述符，失败时返回 INVALID_SOCKET</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(SOCKET s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：请求连接。</span></span><br><span class="line">    <span class="comment">// 参数：s：客户端套接字的描述符；serv_addr：保存目标服务器端地址信息的结构体指针；addrlen：第二个参数的长度（单位是字节）</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closesocket</span><span class="params">(SOCKET s)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：关闭 s 对应的套接字。当关闭一个套接字时会向对方发送 EOF。</span></span><br><span class="line">    <span class="comment">// 参数：s：套接字的描述符。</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回 0，失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv</span><span class="params">(SOCKET s, <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：从套接字 s 读取数据。recv 函数会阻塞，直到读取到数据或 EOF 才返回。</span></span><br><span class="line">    <span class="comment">// 参数：s：套接字描述符；buf：保存要接收的数据；len：要接收的最大字节数；flags：一般设为 0 即可</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回接收的字节数（遇到文件尾则返回 0），失败时返回 SOCKET_ERROR</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send</span><span class="params">(SOCKET s, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line">    <span class="comment">// 功能：向套接字 s 输出数据。</span></span><br><span class="line">    <span class="comment">// 参数：s：套接字描述符；buf：要传输的数据；len：要传输的字节数；flags：一般设为 0 即可</span></span><br><span class="line">    <span class="comment">// 返回值：成功时返回写入的字节数，失败时返回 SOCKET_ERROR</span></span><br></pre></td></tr></table></figure>
<h1 id="本章代码示例"><a href="#本章代码示例" class="headerlink" title="本章代码示例"></a>本章代码示例</h1><h2 id="hello-server-c"><a href="#hello-server-c" class="headerlink" title="hello_server.c"></a>hello_server.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock;<span class="comment">// 服务器套接字</span></span><br><span class="line">    <span class="type">int</span> clnt_sock;<span class="comment">// 客户端套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_adr; <span class="comment">// 客户端地址信息</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz; <span class="comment">// 客户端地址信息长度</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数：可执行文件名、端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建了一个 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充,主要是为了将 serv_addr 的 sin_zero 成员设为 0</span></span><br><span class="line">    <span class="comment">// 服务器地址信息</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//htonl 将long型数据从主机字节序转换为网络字节序。INADDR_ANY表示接受任意地址</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])); <span class="comment">// htons 将 short 型数据从主机字节序转换为网络字节序。atoi 将字符串转换为整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>) <span class="comment">// 将套接字和服务器IP地址信息绑定</span></span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>)==<span class="number">-1</span>) <span class="comment">// 将套接字转换为可接收连接状态，连接请求等待队列长度为 5</span></span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz=<span class="built_in">sizeof</span>(clnt_adr); <span class="comment">// 接收连接请求时需要传递地址信息的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接受连接请求。accept 会阻塞，直到有连接请求才会返回</span></span><br><span class="line">    <span class="comment">// 并将 clnt_sock 套接字与其相连接</span></span><br><span class="line">    clnt_sock=<span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected client %d \n&quot;</span>, clnt_sock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, message, <span class="built_in">sizeof</span>(message)); <span class="comment">// 向客户端发送数据</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock); <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock); <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成可执行文件后的运行方式"><a href="#生成可执行文件后的运行方式" class="headerlink" title="生成可执行文件后的运行方式"></a>生成可执行文件后的运行方式</h3><p>在命令行中执行类似如下代码：</p>
<p><code>hello_server 5000 # 在端口 5000 处接收连接请求</code></p>
<h2 id="hello-client-c"><a href="#hello-client-c" class="headerlink" title="hello_client.c"></a>hello_client.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock; <span class="comment">// 套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>]; <span class="comment">// 保存接收数据的数组</span></span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个参数：可执行文件名、服务器IP地址</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.S_un.S_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]); <span class="comment">// 将点分十进制字符串转换为网络地址结构体</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>) <span class="comment">// 请求连接</span></span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len=<span class="built_in">read</span>(sock, message, <span class="built_in">sizeof</span>(message)<span class="number">-1</span>); <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="keyword">if</span>(str_len==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    message[str_len]=<span class="number">0</span>; <span class="comment">// 在字符串结尾添加 NULL 字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s \n&quot;</span>, message); <span class="comment">// 显示接收到的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock); <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成可执行文件后的运行方式-1"><a href="#生成可执行文件后的运行方式-1" class="headerlink" title="生成可执行文件后的运行方式"></a>生成可执行文件后的运行方式</h3><p>在命令行中执行类似如下代码：</p>
<p><code>hello_client 127.0.0.1 5000 # 向 127.0.0.1 5000 请求连接</code></p>
<h2 id="fd-seri-c"><a href="#fd-seri-c" class="headerlink" title="fd_seri.c"></a>fd_seri.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2, fd3;</span><br><span class="line">    fd1 = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">&quot;test.data&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC); <span class="comment">// 创建文件</span></span><br><span class="line">    fd3 = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d \n&quot;</span>, fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2: %d \n&quot;</span>, fd2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd3: %d \n&quot;</span>, fd3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="built_in">close</span>(fd3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预计输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fd1: 3</span><br><span class="line">fd2: 4</span><br><span class="line">fd3: 5</span><br></pre></td></tr></table></figure>

<h2 id="hello-server-win-c"><a href="#hello-server-win-c" class="headerlink" title="hello_server_win.c"></a>hello_server_win.c</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wsaData; <span class="comment">// 保存 Windows 套接字初始化信息的结构体变量</span></span><br><span class="line">    SOCKET serv_sock; <span class="comment">// 服务器套接字</span></span><br><span class="line">    SOCKET clnt_sock; <span class="comment">// 客户端套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_adr; <span class="comment">// 客户端地址信息</span></span><br><span class="line">    <span class="type">int</span> clnt_adr_sz; <span class="comment">// 客户端地址信息长度</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) <span class="comment">// 初始化 Winsock 库</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(serv_sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 接受任意地址</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>])); <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==SOCKET_ERROR) <span class="comment">// 将套接字和服务器IP地址信息绑定</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>)==SOCKET_ERROR) <span class="comment">// 将套接字转换为可接收状态，连接请求等待队列长度为 5</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz=<span class="built_in">sizeof</span>(clnt_adr); <span class="comment">// 接收连接请求时需要传递地址信息的长度</span></span><br><span class="line"></span><br><span class="line">    clnt_sock=<span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_adr, &amp;clnt_adr_sz); <span class="comment">// 接受连接请求。accept 会阻塞，直到有连接请求才会返回</span></span><br><span class="line">    <span class="keyword">if</span>(clnt_sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected client: %d \n&quot;</span>, clnt_sock);</span><br><span class="line">    <span class="built_in">send</span>(clnt_sock, message, <span class="built_in">sizeof</span>(message), <span class="number">0</span>); <span class="comment">// 向客户端发送数据</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clnt_sock); <span class="comment">// 断开连接</span></span><br><span class="line">    <span class="built_in">closesocket</span>(serv_sock); <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>(); <span class="comment">// 释放 Winsock 库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hello-client-win-c"><a href="#hello-client-win-c" class="headerlink" title="hello_client_win.c"></a>hello_client_win.c</h2><p>书中源代码编译会报错，根据报错提示对第 33 行进行了修改。并且还要将项目&#x3D;》属性&#x3D;》配置属性&#x3D;》C&#x2F;C++ &#x3D;》常规&#x3D;》SDL检查 修改为”否“。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wsaData; <span class="comment">// 保存 Windows 套接字初始化信息的结构体变量</span></span><br><span class="line">    SOCKET sock; <span class="comment">// 套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr; <span class="comment">// 服务器地址信息</span></span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>]; <span class="comment">// 保存接收数据的数组</span></span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) <span class="comment">// 初始化 Winsock 库</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr)); <span class="comment">// 每个字节都用 0 填充</span></span><br><span class="line">    serv_adr.sin_family=AF_INET; <span class="comment">// IPv4地址</span></span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]); <span class="comment">// 将点分十进制字符串转换为网络地址结构体</span></span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==SOCKET_ERROR) <span class="comment">// 请求连接</span></span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len=<span class="built_in">recv</span>(sock, message, <span class="built_in">sizeof</span>(message)<span class="number">-1</span>, <span class="number">0</span>); <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="keyword">if</span>(str_len==SOCKET_ERROR)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    message[str_len]=<span class="number">0</span>; <span class="comment">// 在字符串结尾添加 NULL 字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s \n&quot;</span>, message); <span class="comment">// 显示接收到的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock); <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>(); <span class="comment">// 释放 Winsock 库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个运行方式和之前一样</p>
<h1 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h1><h2 id="Linux-POSIX-和-Windows-对-sockaddr-in-结构体内部成员的定义方式不同"><a href="#Linux-POSIX-和-Windows-对-sockaddr-in-结构体内部成员的定义方式不同" class="headerlink" title="Linux&#x2F;POSIX 和 Windows 对 sockaddr_in 结构体内部成员的定义方式不同"></a>Linux&#x2F;POSIX 和 Windows 对 sockaddr_in 结构体内部成员的定义方式不同</h2><ul>
<li>在 Linux 和其他 POSIX 系统中，IP地址成员的访问方式是 sin_addr.s_addr。</li>
<li>在 Windows 中，底层的实际访问方式是 sin_addr.S_un.S_addr。</li>
</ul>
<ol>
<li><p>结构体定义的差异<br> 在 Linux&#x2F;POSIX (netinet&#x2F;in.h)sockaddr_in 结构体中的 in_addr 通常被定义为：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">// 32位的IPv4地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">// IP地址结构体</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 在这里，s_addr 是 in_addr 结构体的一个直接成员，所以你可以通过 serv_adr.sin_addr.s_addr 来访问它。</p>
<p> 在 Windows (WinSock2.h)<br> Windows 的定义要复杂一些，它使用了一个联合（union）来提供多种访问同一块内存的方式：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">uint32_t</span> S_addr;</span><br><span class="line">    &#125; S_un;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 在这个定义中，要访问32位的长整型地址，正确的路径是serv_adr.sin_addr.S_un.S_addr。</p>
</li>
<li><p>为什么 s_addr 有时也能在 Windows 上工作？<br> 为了让开发者能够编写跨平台的代码，Windows 的 WinSock2.h 头文件中通常包含了这样一个宏定义：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> s_addr S_un.S_addr</span></span><br></pre></td></tr></table></figure>
<p> 这个 #define 预处理指令告诉编译器：在代码中任何出现 s_addr 的地方，都将其替换为 S_un.S_addr。</p>
</li>
</ol>
<h2 id="IP地址的不同转换方式"><a href="#IP地址的不同转换方式" class="headerlink" title="IP地址的不同转换方式"></a>IP地址的不同转换方式</h2><p>一个IPv4地址本质上是一个32位的无符号整数（long 或 uint32_t）。为了方便记忆和书写，我们使用“点分十进制”表示法，例如 192.168.1.1。</p>
<p>程序处理: 在程序中，这个点分十进制的字符串必须被转换成32位的整数才能被网络协议栈使用。</p>
<ul>
<li>在服务器端代码 hello_server.c 中，使用了 INADDR_ANY。这是一个特殊的宏，代表一个 long 型整数 0，告诉操作系统绑定到本机所有可用的IP地址上。它本身就是一个 long 整型，所以直接用 htonl 转换。</li>
<li>在客户端代码 hello_client.c 中，使用了 inet_addr(argv[1])。这个函数的作用就是将点分十进制的字符串（如 “127.0.0.1”）转换成一个网络字节序的 long 整型。</li>
</ul>
]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++ 网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>理解网络编程和套接字</title>
    <url>/2024/06/04/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="套接字协议及其数据传输特性"><a href="#套接字协议及其数据传输特性" class="headerlink" title="套接字协议及其数据传输特性"></a>套接字协议及其数据传输特性</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>; </span><br><span class="line"><span class="comment">// domain：采取的协议族，一般为 PF_INET；type：数据传输方式，一般为 SOCK_STREAM；protocol：使用的协议，一般设为 0 即可。 </span></span><br><span class="line"><span class="comment">//成功时返回文件描述符，失败时返回 -1</span></span><br></pre></td></tr></table></figure>

<p>创建套接字的函数 socket 的三个参数的含义：</p>
<ol>
<li>domain：使用的协议族。一般只会用到 PF_INET，即 IPv4 协议族。</li>
<li>type：套接字类型，即套接字的数据传输方式。主要是两种：SOCK_STREAM（即 TCP）和 SOCK_（即 UDP）。</li>
<li>protocol：选择的协议。一般情况前两个参数确定后，protocol 也就确定了，所以设为 0 即可。</li>
</ol>
<p><img src="https://edgeone.51shazhu.com/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251011/G6aT/899X237/protocol_Family.png" alt="899X237&#x2F;protocol_Family.png"></p>
<h2 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h2><p>同一个协议族可能有多种数据传输方式，因此在指定了 socket 的第一个参数后，还要指定第二个参数 type。</p>
<p>SOCK_STREAM 代表的是 TCP 协议，会创建面向连接的套接字</p>
<p>SOCK_DGRAM 代表的是 UDP 协议，会创建面向消息的套接字</p>
<h2 id="协议的最终选择"><a href="#协议的最终选择" class="headerlink" title="协议的最终选择"></a>协议的最终选择</h2><p>因为有这种情况：同一协议族中存在多个数据传输方式相同的协议，所以还需要第三个参数 protocol 来指定具体协议。</p>
<p>但是 PF_INET（IPv4 协议族）下的 SOCK_STREAM 传输方式只对应 IPPROTO_TCP 一种协议，SOCK_DGRAM 传输方式也只对应 IPPROTO_UDP 一种协议，所以参数 protocol 只要设为 0 即可。</p>
<h1 id="WIN平台下的实现和验证"><a href="#WIN平台下的实现和验证" class="headerlink" title="WIN平台下的实现和验证"></a>WIN平台下的实现和验证</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span> </span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>; </span><br><span class="line"><span class="comment">//参数种类与含义同 Linux 的 socket 函数完全相同 </span></span><br><span class="line"><span class="comment">//成功时返回 socket 句柄，失败时返回 INVALID_SOCKET。</span></span><br></pre></td></tr></table></figure>

<p>返回值类型 SOCKET 实际上就是 int 类型，而 INVALID_SOCKET 的实际值为 -1。故 winsock 中的 socket 函数的返回值类型与含义实际上和 Linux 中的 socket 函数也是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET sock = <span class="built_in">sock</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">if</span>( sock == INVALID_SOCKET ) <span class="built_in">ErrorHandling</span>(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="本章程序"><a href="#本章程序" class="headerlink" title="本章程序"></a>本章程序</h1><h2 id="tcp-server-c"><a href="#tcp-server-c" class="headerlink" title="tcp_server.c"></a>tcp_server.c</h2><p>与 ch1 中的 hello_server.c 完全相同。</p>
<h2 id="tcp-cilent-c"><a href="#tcp-cilent-c" class="headerlink" title="tcp_cilent.c"></a>tcp_cilent.c</h2><p>基于 ch1 中的 hello_client.c 修改而来，在前者基础上修改了 read 函数的调用方式：每次只读取一个字节，通过多次读取完成对接收到的数据的读取，验证面向连接的套接字没有数据边界这一特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family=AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, read_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read_len = <span class="built_in">read</span>(sock, &amp;message[idx++], <span class="number">1</span>)) <span class="comment">//只有当 read 函数读到了 EOF (即服务器端调用了 close 函数) 才会中止循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(read_len == <span class="number">-1</span>) <span class="built_in">ErrorHandling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">        str_len += read_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function read call count: %d \n&quot;</span>, str_len);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tcp-server-win-c"><a href="#tcp-server-win-c" class="headerlink" title="tcp_server_win.c"></a>tcp_server_win.c</h2><p>与 ch1 中的 hello_server_win.c 完全相同。</p>
<h2 id="tcp-client-win-c"><a href="#tcp-client-win-c" class="headerlink" title="tcp_client_win.c"></a>tcp_client_win.c</h2><p>和 tcp_client.c 类似，基于 ch1 中的 hello_client_win.c 修改而来，在前者基础上修改了 recv 函数的调用方式：每次只读取一个字节，通过多次读取完成对接收到的数据的读取，验证面向连接的套接字没有数据边界这一特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET sock;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sock=<span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line">    <span class="keyword">if</span>(sock==INVALID_SOCKET)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family=AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr=<span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port=<span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr))==SOCKET_ERROR)</span><br><span class="line">        <span class="built_in">ErrorHandling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    str_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, read_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read_len = <span class="built_in">recv</span>(sock, &amp;message[idx++], <span class="number">1</span>, <span class="number">0</span>)) <span class="comment">//只有当 recv 函数读到了 EOF (即服务器端调用了 closesocket 函数) 才会中止循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(read_len == <span class="number">-1</span>) <span class="built_in">ErrorHandling</span>(<span class="string">&quot;read() error!&quot;</span>);</span><br><span class="line">        str_len += read_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function recv call count: %d \n&quot;</span>, str_len);</span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>TCP/IP编程</category>
      </categories>
      <tags>
        <tag>C++ 网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串、向量和数组</title>
    <url>/2024/05/31/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>本文为阅读C++ primer第三章的读书笔记，仅作为查找以及防止遗忘对应知识点作用，不可替代原书。</p>
<span id="more"></span>
<h1 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h1><p>可以对单个名字进行独立的using声明</p>
<p>头文件里不应包含 using 声明。因为头文件的内容会拷贝到所有引用它的文件，一旦头文件有using声明，每个引用它的文件都有该声明，可能冲突</p>
<h1 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h1><p>string 表示可变长的字符序列。</p>
<h2 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h2><p>有以下几种方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1; <span class="comment">//将 s1 默认初始化为一个空的 string </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(s2)</span></span>; <span class="comment">//使用拷贝构造函数进行的拷贝初始化。s1 是 s2 的拷贝。 </span></span><br><span class="line">string s1 = s2; <span class="comment">//使用拷贝赋值运算符进行的拷贝初始化。s1 是 s2 的拷贝。 </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>; <span class="comment">//s1 是字面值 &quot;value&quot; 去除最后一个空字符后的拷贝。 </span></span><br><span class="line">string s1 = <span class="string">&quot;value&quot;</span>; <span class="comment">//同上。 </span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//s1 初始化为 n 个 &#x27;c&#x27;。</span></span><br></pre></td></tr></table></figure>
<p><strong>使用字符串字面值或字符数组初始化 string 对象时，string 对象中是不包含末尾的空字符的，它会将字符数组中末尾的空字符去掉</strong></p>
<h2 id="string的一些操作"><a href="#string的一些操作" class="headerlink" title="string的一些操作"></a>string的一些操作</h2><p><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250725/QdOG/1040X475/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-07-25_163653.png" alt="1040X475&#x2F;屏幕截图_2025-07-25_163653.png"></p>
<h3 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h3><p>可以使用 cin, cout 来读写 string 对象，也可以使用 stringstream 来读写 string 对象。</p>
<h4 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline 函数"></a>getline 函数</h4><p>getline() 定义在头文件 string 中，以一个 istream 对象和一个 string 对象为输入参数。getline() 读取输入流的内容直到遇到换行符停止，然后将读入的数据存入 string 对象。</p>
<p>注意 getline 会将换行符也读入，但是不将换行符存入 string 对象。即触发 getline() 函数返回的那个换行符实际上被丢弃掉了。</p>
<p>getline() 只要一遇到换行符就结束读取操作并返回结果，即使一开始就是换行符也一样，这种情况下会得到一个空 string。</p>
<p>getline() 与 &lt;&lt; 一样，会返回它的流参数。所以可以用 getline 的结果作为条件。</p>
<h3 id="string-size-type-类型"><a href="#string-size-type-类型" class="headerlink" title="string::size_type 类型"></a>string::size_type 类型</h3><p>string 的 size() 成员函数返回一个 string::size_type 类型的值。</p>
<blockquote>
<p>[!NOTE] 配套类型<br>大多数标准库类型都定义了几种配套的类型，这些配套类型体现了标准库与机器无关的特性。</p>
</blockquote>
<p>在具体使用时，通过作用域操作符来表明 size_type 是在类 string 中定义的。</p>
<p>string::size_type 是无符号值，可以确定的是它足够存放任何 string 对象的大小。</p>
<p>C++11 允许通过 auto 和 decltype 来获得此类型。</p>
<p><code>auto len = s.size();// len 的类型是 string::size_type</code></p>
<p>不要在同一个表达式中混用 size_type 和 int 类型。原因一部分在于无符号数和有符号数转换的问题上</p>
<h2 id="string中的字符"><a href="#string中的字符" class="headerlink" title="string中的字符"></a>string中的字符</h2><p>cctype 头文件中有下列标准库函数来处理 string 中的字符。</p>
<p>下面这些函数的输入和返回值实际都是 int 类型的，且输入的值 c 必须满足 -1&lt;&#x3D;c&lt;&#x3D;255，即输入必须是 ASCII 字符<br><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250725/blbx/1019X636/cctype.png" alt="1019X636&#x2F;cctype.png"></p>
<blockquote>
<p>[!tip] 头文件使用建议<br>使用 c++ 版本的标准库头文件</p>
</blockquote>
<h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str) <span class="comment">// 对于str中的每个字符 </span></span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出当前字符，后面紧跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>当要改变 string 对象中的值时，需要把循环变量定义成引用类型。必须通过显示添加 &amp; 符号来声明引用类型。</p>
<p><strong>不能在范围 for 语句中改变所遍历序列的大小。</strong></p>
<p><code>for(auto &amp;c:str) c = toupper(c); // 转换为大写</code></p>
<p>对 string 的最后一个字符进行索引：s[s.size()-1];</p>
<p>索引必须大于等于 0 小于 size，使用索引前最好用 if(!s.empty()) 判断一下字符串是否为空。</p>
<p>任何表达式只要是整型值就可以作为索引。索引是无符号类型 size_type；</p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>变量和基本类型</title>
    <url>/2024/05/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>本文为阅读C++ primer第二章的读书笔记，仅作为查找以及防止遗忘对应知识点作用，不可替代原书。</p>
<span id="more"></span>
<p>C++定义了几种基本内置类型，如字符、整型、浮点数等。</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>基本内置类型包括算数类型和空类型。算术类型包括字符、整数、布尔值和浮点数。void类型没有关联的值，只能在少数情况下使用，最常见的是作为不返回值的函数的返回类型</p>
<h2 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h2><p>算数类型整体分为整型和浮点型两类。字符和布尔值都属于整型。</p>
<p>C++ 定义了各类型的最小尺寸：bool 未定义、char 8位、short 16位、int 16位、long 32位、long long 64位；float 是 32 位 4 字节，包括6位有效数字、double 是 64 位 8 字节，包括10位有效数字。</p>
<blockquote>
<p>[!NOTE] int位数的特别说明<br>int作为一个变长的类型，可能是16位，也可能是32位，取决于编译器。目前多为32位</p>
</blockquote>
<p>int、short、long 都是带符号类型。char 是否有符号由编译器决定。</p>
<p>因为 char 是否有符号并不确定，因此可以使用 signed char 或 unsigned char 来指定是否有符号。</p>
<p>C++ 提供了几种字符类型：</p>
<ol>
<li>char：一个 char 的空间应确保可以存放机器基本字符集中任意字符对于的数字值，即一个 char 的大小和一个机器字节一样。</li>
<li>wchar_t：宽字符，用于扩展字符集，wchar_t 确保可以存放机器最大扩展字符集中的任意一个字符。</li>
<li>char16_t 和 char32_t：为 Unicode 字符集服务。<br>下为书中列出的表格：<br><img src="https://tc.z.wiki/autoupload/f/i9VH93eH4ENDdQHnYXj2PuHhVTZgOgfLijisMn2fRaCyl5f0KlZfm6UsKj-HyTuv/20250719/ilim/1158X563/C%2B%2B_Arithmetic_Types.png" alt="1158X563&#x2F;C++_Arithmetic_Types.png"></li>
</ol>
<blockquote>
<p>[!NOTE] 类型选择技巧<br>明确知晓数值不可能为负时，选用无符号类型。</p>
<p>整数运算用 int，数值太大时用 long long，不用 short 和 long </p>
<p>浮点数运算用 double。float 和 double 的计算代价相差无几</p>
</blockquote>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="几种类型转换的情况："><a href="#几种类型转换的情况：" class="headerlink" title="几种类型转换的情况："></a>几种类型转换的情况：</h3><ul>
<li>把浮点数赋给整型时，结果仅保留小数点前的部分。</li>
<li>赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如 -1 赋给 8 位 unsigned char 的结果是 255（-1&#x3D;256*(-1)+255）</li>
<li>赋给带符号类型超出范围的值时，结果是未定义的。程序可能工作，可能崩溃。</li>
</ul>
<p>程序尽量避免依赖于实现环境的行为。比如 int 的尺寸在不同环境可能不同。</p>
<h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p>一个表达式中既有无符号数又有int值时，int会被转换成无符号数。</p>
<p>无符号减无符号数，结果还是无符号数，如果是负值就等于该符数加上无符号数的模<br><code>unsigned u = 10; int i = -42; u + i = -32 + 2^32 = 4294967264</code></p>
<h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><h3 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h3><p>整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。</p>
<p>整型字面值的具体数据类型由它的值和符号决定。默认情况下十进制字面值是带符号数，类型是 int, long, long long 中能容纳当前值的尺寸最小的那个。</p>
<p>浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识</p>
<h3 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h3><p>单引号括起来的一个字符是 char 型字面值，双引号括起来的 0 个或多个字符则构成字符串型字面值。</p>
<p>字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（’\0’），因此字符串字面值的实际长度要比它的内容多 1。如 “A” 代表了一个长度为 2 的字符数组。</p>
<p><strong>如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string global_str = <span class="string">&quot;A is B&quot;</span>   <span class="string">&quot;and B is A&quot;</span>;</span><br><span class="line">cout &lt;&lt; global_str &lt;&lt; endl; <span class="comment">// 输出: A is Band B is A</span></span><br></pre></td></tr></table></figure>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><p>建议直接网上查表</p>
<h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>可以通过给字面值增加前缀和后缀来改变字面值的默认类型。<br>下为一些常见的字面量类型指定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;整型字面值&#x27;</span> </span><br><span class="line"><span class="number">12</span> <span class="comment">// 默认类型为 int </span></span><br><span class="line"><span class="number">12u</span> <span class="number">12U</span> <span class="comment">// 最小匹配类型 unsigned </span></span><br><span class="line"><span class="number">12l</span> <span class="number">12L</span> <span class="comment">// 最小匹配类型 long </span></span><br><span class="line"><span class="number">12ul</span> <span class="number">12UL</span> <span class="comment">// 最小匹配类型 unsigned long </span></span><br><span class="line"><span class="number">12ll</span> <span class="number">12LL</span> <span class="comment">// 最小匹配类型 long long </span></span><br><span class="line"><span class="number">12ull</span> <span class="number">12ULL</span> <span class="comment">// 最小匹配类型 unsigned long long </span></span><br><span class="line"><span class="string">&#x27;浮点型字面值&#x27;</span> </span><br><span class="line"><span class="number">3.14</span> <span class="comment">// 默认类型为 double </span></span><br><span class="line"><span class="number">3.14f</span> <span class="number">3.14F</span> <span class="comment">// 类型为 float </span></span><br><span class="line"><span class="number">3.14l</span> <span class="number">3.14L</span> <span class="comment">// 类型为 long double </span></span><br><span class="line"><span class="string">&#x27;字符字符串字面值&#x27;</span> </span><br><span class="line"><span class="string">u&#x27;a&#x27;</span> <span class="string">u&quot;abandon&quot;</span> <span class="comment">// Unicode 16 字符，类型为 char16_t </span></span><br><span class="line"><span class="string">U&#x27;a&#x27;</span> <span class="string">U&quot;abandon&quot;</span> <span class="comment">// Unicode 32 字符，类型为 char32_t </span></span><br><span class="line"><span class="string">L&#x27;a&#x27;</span> <span class="string">L&quot;abandon&quot;</span> <span class="comment">// 宽字符，类型为 wchar_t </span></span><br><span class="line"><span class="string">u8&quot;abandon&quot;</span> <span class="comment">// 类型为 char，u8 的含义是 UTF-8，仅用于字符串字面值。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意 12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f</strong></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>对于c++而言，”变量“和”对象“一般可以互换使用。</p>
<p>c++中，对象通常指一块能存储数据并具有某种类型的内存</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>可以一个一个初始化</p>
<p>也可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。<br><code>double price = 109.99, discount = price * 0.6;</code></p>
<p>初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值擦除并用一个新值来替代。</p>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>下面四种初始化方式都是可行的，其中使用花括号的方式叫做列表初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>; <span class="type">int</span> i=&#123;<span class="number">0</span>&#125;; <span class="type">int</span> i&#123;<span class="number">0</span>&#125;; <span class="function"><span class="type">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.1415926536</span>; </span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;, b=&#123;ld&#125;; <span class="comment">//错误，存在信息丢失的风险，转换未执行。 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>, d</span>=ld; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p><strong>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。</strong></p>
<p>定义于任何函数之外的内置类型则被初始化为0；</p>
<p>类的对象如果没有显式地初始化，则其由类确定。string 默认初始化为一个空串。</p>
<p>不能使用未初始化的变量，否则会引发运行时故障。</p>
<p><strong>建议初始化每一个内置类型的变量。</strong></p>
<h2 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h2><p>声明和定义是严格区分的。</p>
<p>要声明一个变量加 extern，声明变量不能赋值。</p>
<p>任何包含了显式初始化的声明即成为定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// 声明 i </span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">// 定义i； </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 定义 i，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure>
<p>变量只能被定义一次，但是可以多次声明。通过这种方式，一个变量可以在多个文件中使用</p>
<p>声明和定义的区分很重要</p>
<p>c++是静态类型语言，其含义是在编译阶段检查类型。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。</p>
<p>用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。这些是为了确保用户自定义的标识符不会和标准库中的重合</p>
<p>变量命名规范：</p>
<ol>
<li>标识符要体现其实际含义。</li>
<li>变量名一般用小写字母。</li>
<li>用户自定义的类型一般以大写字母开头。</li>
<li>包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。</li>
</ol>
<p>对于嵌套作用域，可以在内层作用域中重新定义外层作用域已有的名字，但是最好不要这样做。</p>
<h2 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h2><p>同一个名字在不同的作用域可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在作用域末端结束</p>
<blockquote>
<p>[!NOTE] 第一次使用变量时定义它<br>有助于更容易找到定义，也可以帮助合理给定初值</p>
</blockquote>
<h3 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h3><p>作用域可以互相包含。</p>
<p>被包含的作用域称为内层作用域（inner scope），包含其他作用域的作用域称为外层作用域（outer scope）。</p>
<p>一旦在作用域中声明了名字，嵌套在该作用域内部的作用域就可以使用该名字。在外层作用域中声明的名称也可以在内层作用域中重新定义。取最近的定义作为访问的对象</p>
<blockquote>
<p>[!NOTE] scope operator<br>:: 可以用于在内层访问全局变量</p>
</blockquote>
<p>下面是一个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line">	<span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line">	<span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">	std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">	std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><p>复合类型就是基于其他类型定义的类型，引用和指针是其中两种</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是给对象起的别名。初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。</p>
<p>引用必须初始化。引用的初始值必须是一个对象，不能是字面值。引用只能绑定同类型对象。</p>
<p>对引用的所有操作都是对与之绑定的对象的操作。</p>
<p>引用非对象。因此不能定义对引用的引用</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在块作用域内，指针如果没有被初始化，值将不确定。</p>
<p>指针必须指向指定的类型，不能指向其他类型。<strong>这是严格的，哪怕是long和int都是不能互相指向的</strong></p>
<p>指针与引用的不同：</p>
<ul>
<li>指针是一个对象而引用不是；</li>
<li>指针可以重新赋值，而引用不行</li>
<li>有指向指针的指针，无引用的引用</li>
<li>指针不需要在定义时赋初值，而引用需要<br>不能定义指向引用的指针。可以定义指向指针的引用。</li>
</ul>
<blockquote>
<p>[!NOTE] 根本原因<br>指针是对象，而引用不是、指针指向的是对象，而引用也只能引用对象</p>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种定义空指针的方式。最好用第一种</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">nullptr</span>;  </span><br><span class="line"><span class="type">int</span> *p = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure>

<p>建议初始化所有指针。</p>
<p>非零指针对应的条件值是 ture，零指针对应的条件值是 false。</p>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3><p>void* 指针和空指针不是一回事。</p>
<p>void* 指针是特殊的指针类型，可以存放任意对象的地址。</p>
<p>一般来说，使用 void* 指针将内存作为内存来处理，而不是使用指针来访问存储在内存中的对象</p>
<h1 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h1><p>const 对象必须初始化，因为一旦创建就不能再改变值。</p>
<p>默认情况下，const 对象仅在文件内有效。因此你可以在多个文件中定义多个相同名字的const 对象</p>
<p>如果想在多个文件间共享 const 对象，必须在变量的定义前添加 extern 关键字并在本文件中声明。声明和定义都要加 extern。</p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>常量引用不是说引用是常量，因为引用本来就只能绑定一个对象，而是引用不能改变引用的对象值。</p>
<p>常量引用可以绑定const对象，也可以绑定非常量对象。但是无论哪种，都不能通过引用去修改绑定的对象的值了。</p>
<p><strong>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。</strong></p>
<p>之前我们提到过：引用的类型必须与其所引用对象的类型一致，但是有两个例外。其中一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</p>
<blockquote>
<p>[!NOTE] 原理<br>实际上是创建了一个临时对象让常量引用绑定，也因此不能通过常量引用修改对象的值</p>
</blockquote>
<h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h2><p>指向常量的指针既可以指向常量也可以指向非常量，和常量引用一样，也不能通过指向常量的指针修改对象的值</p>
<p>至于具体作为常量的指针和指向常量的指针，我们在下一小节介绍</p>
<h2 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h2><p>顶层 const 表示指针本身是个常量，底层 const 表示指针所指的对象是一个常量。顶层 const 对任何数据类型通用，底层 const 只用于引用和指针。</p>
<p>顶层 const 的指针表示该指针是 const 对象，因此必须初始化。底层 const 的指针则不用。</p>
<p>实际上只有指针类型既可以是顶层 const 也可以是底层 const，因为引用实际上只能是底层 const，常量引用即为底层 const，不存在顶层 const 的引用。</p>
<p><strong>从右向左读来判断是顶层 const 还是底层 const。</strong></p>
<p>对于指针和引用而言，顶层 const 在右边，底层 const 在左边。对于其他类型，全都是顶层 const</p>
<p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p2 = &amp;c; <span class="comment">// 这是一个底层const，允许改变 p2 的值 </span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">// 这是一个顶层const，不能改变 p1 的值</span></span><br></pre></td></tr></table></figure>

<p>执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。而顶层const会被忽略。</p>
<h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p>字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。</p>
<h3 id="cosntexpr变量"><a href="#cosntexpr变量" class="headerlink" title="cosntexpr变量"></a>cosntexpr变量</h3><p>在实际应用中很难分辨一个初始值是否是常量表达式，通过将变量声明为 constexpr 类型即可由编译器来检查。</p>
<p>由 constexpr 声明的变量必须用常量表达式初始化。</p>
<p>建议：如果认定一个变量是常量表达式，就把它声明为 constexpr 类型。</p>
<p>新标准允许定义 constexpr，这种函数应该足够简单以使得编译时就可以计算其结果。</p>
<p>不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化 constexpr 变量。</p>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>算术类型、引用、指针都属于字面值类型，自定义类则不属于。</p>
<p>cosntexpr 指针的初始值必须是 nullptr 或 0 或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。</p>
<p>注意区分 constexpr 和 const 。constexpr 都是顶层 const，仅对指针本身有效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// p 是一个指向整型常量的指针 </span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q 是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h3 id="const和constexpr区别"><a href="#const和constexpr区别" class="headerlink" title="const和constexpr区别"></a>const和constexpr区别</h3><p>constexpr 限定了变量是编译器常量，即变量的值在编译器就可以得到。</p>
<p>const 则并未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只是初始化后就不能再改变了。</p>
<p><strong>constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。</strong></p>
<h1 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>有以下两种方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">// 使用 typedef 关键字 </span></span><br><span class="line"><span class="keyword">using</span> wages = <span class="type">double</span>; <span class="comment">// 使用 using 关键字进行别名声明</span></span><br></pre></td></tr></table></figure>
<p>和其他声明语句一样，typedef 的声明语句中也可以包含类型修饰符，从而构造复合类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 是 double 的别名，p 是 double* 的别名。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 带有指针的别名<br><code>typedef char* pstring; const pstring cstr = 0;</code><br> 注意：cstr是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr &#x3D; 0，按后者的话，cstr是一个指向常量的指针。这是错误的。</p>
</blockquote>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto 说明符让编译器根据初始值来分析表达式所属的类型。</p>
<p>auto 可以在一条语句中声明多个变量，但是多个变量将会是同一个基本数据类型</p>
<p><strong>编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：</strong></p>
<ol>
<li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li>
<li>auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。</li>
<li>auto 会保留底层 const。</li>
</ol>
<p>下面给出一些例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>, &amp;cr = ci; </span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b 是一个普通的 int。 </span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c 是一个普通的 int。 </span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> d = ci; <span class="comment">// d 是一个 const int </span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">// e 是一个指向常量的引用（常量引用是底层 const）。注意这个微妙的地方。 </span></span><br><span class="line"><span class="keyword">auto</span> f = &amp;ci; <span class="comment">// f 是一个 const int*（位于左边的 const 是底层 const）</span></span><br></pre></td></tr></table></figure>

<p><strong>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用</strong></p>
<h2 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h2><p>当希望获得表达式的类型但是不要计算值的时候，可以使用类型说明符 decltype。</p>
<p>如果 decltype 使用的表达式是一个变量，则它返回该变量的类型（包括顶层 const 和引用在内）。</p>
<p>decltype 与 auto 的不同：decltype 不会忽略引用和顶层 const。</p>
<p>注意当获得的类型是引用时，必须初始化。</p>
<h3 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h3><p>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。可以使用这种方式来保证不获取引用类型。</p>
<p>注意解引用指针的结果是一个引用类型。给变量加括号的结果也是引用类型。赋值操作的结果也是引用类型。</p>
<p><strong>decltype((var)) 的结果永远是引用，而 decltype(var) 的结果只有当 var 本身就是引用时才是引用。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, &amp;r = i, *p; </span><br><span class="line"><span class="keyword">decltype</span>(r<span class="number">+0</span>) b; <span class="comment">// b 的类型是 int，因为 r+0 的结果类型是 int。 </span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i; <span class="comment">// c 的类型是 int&amp;。 </span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = i; <span class="comment">// d 的类型是 int&amp;。</span></span><br><span class="line"><span class="keyword">decltype</span>(j = r<span class="number">+0</span>) b = i; <span class="comment">// d 的类型是 int&amp;。</span></span><br></pre></td></tr></table></figure>
<h1 id="自定义数据结构和引用"><a href="#自定义数据结构和引用" class="headerlink" title="自定义数据结构和引用"></a>自定义数据结构和引用</h1><h2 id="定义struct类型"><a href="#定义struct类型" class="headerlink" title="定义struct类型"></a>定义struct类型</h2><p>struct+类名+类体+分号。类体可以为空。</p>
<p><code>struct Sales_data&#123;&#125;; // 注意：结尾加分号</code></p>
<p>定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。</p>
<p>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</p>
<h2 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h2><p>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</p>
<p>头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。</p>
<p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
<h3 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h3><p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p>
<p>预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。</p>
<p>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</p>
<p>c++ 中包含三个头文件保护符：</p>
<ol>
<li>#define：把一个名字设定为预处理变量</li>
<li>#ifndef：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #endif 为止</li>
<li>#endif</li>
</ol>
<p>预处理变量无视作用域的规则，作用范围是文件内</p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>语句</title>
    <url>/2024/06/07/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h1><h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>一个表达式加一个分号就是一个表达式语句，其执行表达式并丢弃掉求值结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ival + <span class="number">3</span>;<span class="comment">//一条没有实际用处的表达式语句 </span></span><br><span class="line">cout &lt;&lt; ival;<span class="comment">//一条有用的表达式语句</span></span><br></pre></td></tr></table></figure>
<h2 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h2><p>空语句是最简单的语句，只有一个分号</p>
<p>用在语法上需要一条语句，但是逻辑上不需要的地方。</p>
<p>使用空语句块最好加注释</p>
<h2 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h2><p>用花括号括起来的语句和声明序列都是复合语句（块），一个复合语句（块）就是一个作用域</p>
<p>空块的作用等价于一个空语句</p>
<h1 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h1><p>可以在 if、switch、while、for 语句的控制结构内定义变量。</p>
<p>这些定义的变量只能在这些语句的复合语句中使用</p>
<p>常见的语句有条件语句、循环语句、跳转语句三种。</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if 语句有两种形式，一种有 else 分支，另一种没有。</p>
<p>c++ 规定 else 与离他<strong>最近的在同一作用域的尚未匹配的</strong> if 匹配</p>
<p>使用 if 语句最好在所有的 if 和 else 之后都用花括号</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch 语句计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。如果没有任何一个 case 标签匹配 switch 表达式的值，就执行 default 分支。</p>
<p>case 关键字和它对应的值一起被称为 case 标签，case 标签必须为<strong>整型常量表达式</strong>。</p>
<p>default 也是一种特殊的 case 标签。</p>
<p>注意：如果switch条件值在某个case标签满足后，程序将从该case标签一直执行到switch末尾或者遇到第一个break。因此一般在每个 case标签后都有一条 break 语句。如果需要两个或多个值共享同一组操作，可以故意省略掉 break 语句</p>
<p>一条switch语句后可以跟多条语句，而不需要花括号</p>
<blockquote>
<p>[!NOTE] 为了代码的可阅读性，一般有以下规范<br>一般不要省略 case 分支最后的 break 语句。如果没有 break 语句，最好注释一下。</p>
<p>即使不准备在 default 下做任何工作，最好也定义一个 default 标签。</p>
<p>如果要在 case 分支定义并初始化变量，应该定义在块内以约束其作用域</p>
</blockquote>
<h1 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h1><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>其条件不能为空，可以是一个表达式或者带初始化的变量声明</p>
<p>定义在条件部分或者循环体内的变量每次迭代都会重新创建和销毁</p>
<p>一般使用于不知道多少次的循环</p>
<h2 id="传统for语句"><a href="#传统for语句" class="headerlink" title="传统for语句"></a>传统for语句</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement; condition; expression) </span><br><span class="line">	statement;</span><br></pre></td></tr></table></figure>
<p>init-statement 可以是声明语句、表达式语句或空语句。init-statement 可以定义多个对象，但是只能有一条声明语句。</p>
<p>expression 在每次循环之后执行。</p>
<p>for 语句头能省略掉三者中的任意一个或全部。</p>
<p>如果省略 condition ，条件恒为 true。</p>
<h2 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h2><p>用来遍历<strong>容器或其他序列</strong>的所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : expression) </span><br><span class="line">	statement;</span><br></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列（可以是用花括号括起来的初始值列表）。共同特点的是都可以返回迭代器的 begin 和 end 成员</p>
<p>declaration定义一个能从序列中元素转换而来的变量（<strong>不是迭代器</strong>），最简单的方法为用auto</p>
<p>如果需要执行写操作，必须将循环变量声明成引用类型。不需要写时最好都声明为常量引用</p>
<p>每次迭代都会重新定义循环控制变量，并将其初始化为序列的下一个值。</p>
<p><strong>绝对不要在范围 for 语句改变序列的元素数量</strong>。因为其预存了 end() 的值，改变元素数量后 end() 的值就可能失效了</p>
<h2 id="dowhile语句"><a href="#dowhile语句" class="headerlink" title="dowhile语句"></a>dowhile语句</h2><p>do while 语句与 while 语句的唯一区别就是它先执行循环体后检查条件。即至少执行一次循环。</p>
<p>注意：do while 后不要忘了加分号。</p>
<p>因为 condition 在循环体后面，所以 condition 使用的变量应该定义在循环体外面。</p>
<h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h1><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>终止离它最近的 while、do while、for 或 switch 语句，并从这些语句之后的第一条语句开始执行。</p>
<p>break 语句只能出现在迭代语句或 switch 内部</p>
<h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>终止最近的循环中的当前迭代并开始下一次迭代。</p>
<p>continue 只能出现在迭代语句内部</p>
<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>作用是从 goto 语句无条件跳转到同一函数内的另一条语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">label: <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>
<p>label 是用于标识一条语句的标示符</p>
<p>标签标示符独立于变量或其他标示符的名字，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</p>
<p>如果 goto 语句跳回了一条变量的定义之前意味着系统将会销毁该变量，然后重新创建它。</p>
<p><strong>不要使用 goto，它会令程序又难理解又难修改</strong></p>
<h1 id="try和异常处理"><a href="#try和异常处理" class="headerlink" title="try和异常处理"></a>try和异常处理</h1><p>异常是指存在于运行时的反常行为，典型的有失去数据库连接和意外输入等等。</p>
<p><strong>处理异常可能是最难的部分</strong></p>
<p>当程序检测到一个无法处理的问题时，就需要异常处理，此时检测到问题的部分应该发出检测信号。</p>
<p>如果程序里有可能引发异常的代码，也应该有专门的代码处理问题</p>
<p>C++的异常处理机制为异常检测和异常处理提供支持。包括：</p>
<ol>
<li>throw表达式：异常检测部分使用throw表达式来表示遇到了无法处理的问题</li>
<li>try语句块：异常处理部分使用try语句块处理异常，以关键字try开始，一个或多个catch结束</li>
<li>一套异常类：用于在 throw 表达式和相关的 catch 子句间传递异常的具体信息</li>
</ol>
<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><p>throw 表达式包含关键字 throw 和紧随其后的一个表达式，表达式的类型就是抛出的异常类型</p>
<p>即 throw 后面跟一个异常类型的对象（必须同时使用 string 或 C 风格字符串对其初始化）</p>
<p><code>throw runtime_error(&quot;Data must be same as size&quot;);//使用 throw 表达式抛出一个运行时错误。</code></p>
<h2 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h2><p>跟在 try 块后面的是一个或多个 catch 子句。catch子句包括三部分：关键字catch、括号内一个异常类型的对象的声明（即异常声明）、一个块</p>
<p>当try语句中抛出了一个异常，如果该异常类型与catch子句中的异常类型相同，就会执行该catch子句</p>
<p>catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句执行</p>
<p>在catch后的括号中使用省略号…可以让catch捕获所有异常</p>
<p>每个标准库异常类都有一个 what 成员函数，它没有参数，返回初始化该对象时所用的 C 风格字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must be same as size&quot;</span>);<span class="comment">//try 语句块抛出了一个异常 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">catch</span>(runtime_error err)<span class="comment">//在 catch 后面的括号中声明了一个“runtime_error”类型的对象，与 try 抛出的异常类型相同，接下来执行此子句。 </span></span><br><span class="line">	&#123; </span><br><span class="line">		cout &lt;&lt; err.<span class="built_in">what</span>();<span class="comment">//输出 &quot;Data must be same as size&quot; </span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 函数在寻找处理代码的过程中退出<br>throw 语句可能出现在嵌套的 try 语句块中或在 try 语句块中调用的某个函数内。</p>
<p>当异常抛出的时候，会从内到外一层层寻找相应类型的catch子句。如果最后还是没找到，会调用terminate函数调用来终止程序</p>
<p>如果 throw 语句外就没有 try 语句块，也会执行 terminate 函数</p>
<p>异常中断了程序的正常流程。当发生异常，程序执行到一半就中断了，可能会存在如资源没有正常释放，对象没有处理完成等情况。异常安全的代码要求在异常发生时能正确执行清理工作。这个非常困难</p>
</blockquote>
<h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++ 标准库定义了一组异常类，用于报告标准库函数遇到的问题。他们定义在 4 个头文件中</p>
<p>定义在stdexcept头文件中的类型必须使用string对象或者C风格字符串来初始化，其他的3个头文件中的类型则只能默认初始化，</p>
<p>异常类型只有一个 what 成员函数，该函数没有参数，返回是一个 C 风格字符串的指针，目的是提供关于异常的文本信息</p>
<p>对于无初始值的异常类型，what 返回的内容由编译器决定，有初始值的返回初始值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exception头文件 </span></span><br><span class="line">exception           <span class="comment">// 异常类 exception 是最通用的异常类。它只报告异常的发生，不提供额外信息。 </span></span><br><span class="line"><span class="comment">//new头文件</span></span><br><span class="line">bad_alloc           <span class="comment">// 异常类 bad_alloc。在使用 new 分配动态内存失败时抛出 </span></span><br><span class="line"><span class="comment">//type_info头文件 </span></span><br><span class="line">bad_cast            <span class="comment">// 异常类型 bad_cast。经常发生在使用 dynamic_cast 时发生。 //stdexcept头文件 </span></span><br><span class="line">exception runtime_error       <span class="comment">// 只有在运行时才能检测出的问题 </span></span><br><span class="line">range_error         <span class="comment">// 运行时错误：生成的结果超出了有意义的值域范围 overflow_error      // 运行时错误：计算上溢 </span></span><br><span class="line">underflow_error     <span class="comment">// 运行时错误：计算下溢 </span></span><br><span class="line">logic_error         <span class="comment">// 程序逻辑错误 </span></span><br><span class="line">domain_error        <span class="comment">// 逻辑错误：参数对象的结果值不存在 </span></span><br><span class="line">invalid_argument    <span class="comment">// 逻辑错误：无效参数 </span></span><br><span class="line">length_error        <span class="comment">// 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range        // 逻辑错误：使用一个超出有效范围的值</span></span><br></pre></td></tr></table></figure>
<p>上述几个类的具体继承关系如下图<br><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250904/pYAn/656X562/exception_inherit.png" alt="656X562&#x2F;exception_inherit.png"></p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
  <entry>
    <title>线程模块-代码</title>
    <url>/2024/07/04/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97-%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="pthread的封装"><a href="#pthread的封装" class="headerlink" title="pthread的封装"></a>pthread的封装</h1><h2 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h2><p>首先我们主要是面向对象编程。面向对象编程有三个特点：【封装】、【继承】、【多态】。</p>
<p>这里封装pthread是为了使用上更方便，因为虽然pthread提供了以下的一些功能：【Thread】,【Semaphore】,【Mutex】,【RWMutex】,【Spinlock】等</p>
<p>但是都是最基本的功能，而我们开发中往往是多个功能相互结合相互配合着来使用的。</p>
<p>这里封装是为了提供一些新的功能接口供方便使用</p>
<h2 id="thread-h"><a href="#thread-h" class="headerlink" title="thread.h"></a>thread.h</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Thread</span>(std::function&lt;<span class="built_in">void</span>()&gt; cb, <span class="type">const</span> std::string&amp; name);</span><br><span class="line">	~<span class="built_in">Thread</span>();</span><br><span class="line">	<span class="function"><span class="type">pid_t</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;<span class="comment">// 线程ID</span></span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span>;<span class="comment">//线程结合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 获取系统分配的线程id</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">pid_t</span> <span class="title">GetThreadId</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取当前所在线程	</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Thread* <span class="title">GetThis</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 获取当前线程的名字</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 设置当前线程的名字</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 线程函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">run</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">pid_t</span> m_id = <span class="number">-1</span>;<span class="comment">//进程的id</span></span><br><span class="line">	<span class="type">pthread_t</span> m_thread = <span class="number">0</span>;<span class="comment">//线程</span></span><br><span class="line">	<span class="comment">// 线程需要运行的函数</span></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; m_cb;</span><br><span class="line">	std::string m_name;<span class="comment">//线程的name</span></span><br><span class="line">	Semaphore m_semaphore;<span class="comment">//引入信号量的类来完成线程的同步创建。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里涉及到的信号量封装会在后面介绍</p>
<h2 id="thread-cpp"><a href="#thread-cpp" class="headerlink" title="thread.cpp"></a>thread.cpp</h2><p>初始化时通过pthread_create()绑定run函数为线程的入口函数。</p>
<p>在这里run方法负责初始化线程和真正调用线程需要运行任务(函数对象cb)，</p>
<p>使用Semaphore类控制线程初始化的同步，保证所有的线程都能初始化，防止未初始化的线程出现，</p>
<p>GetThreadId()主要是使用系统调用获取真实的线程id，和getpid()返回的线程ID是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mycoroutine &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程信息</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> Thread* t_thread          = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> std::string t_thread_name = <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Thread::GetThreadId</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">syscall</span>(SYS_gettid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Thread* <span class="title">Thread::GetThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">Thread::GetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_thread_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::SetName</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_thread) &#123;</span><br><span class="line">        t_thread-&gt;m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    t_thread_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread::<span class="built_in">Thread</span>(std::function&lt;<span class="built_in">void</span>()&gt; cb, <span class="type">const</span> std::string &amp;name): </span><br><span class="line"><span class="built_in">m_cb</span>(cb), <span class="built_in">m_name</span>(name) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将新创建线程的入口函数绑定到run</span></span><br><span class="line">    <span class="type">int</span> rt = <span class="built_in">pthread_create</span>(&amp;m_thread, <span class="literal">nullptr</span>, &amp;Thread::run, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (rt) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;pthread_create thread fail, rt=&quot;</span> &lt;&lt; rt &lt;&lt; <span class="string">&quot; name=&quot;</span> &lt;&lt; name;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程函数完成初始化</span></span><br><span class="line">    m_semaphore.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构时对线程分离以确定会自动销毁</span></span><br><span class="line">Thread::~<span class="built_in">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_thread) &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_thread);</span><br><span class="line">        m_thread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_thread) &#123;</span><br><span class="line">	    <span class="comment">// 因为不关心返回值去哪，所以直接设置为nullptr</span></span><br><span class="line">        <span class="type">int</span> rt = <span class="built_in">pthread_join</span>(m_thread, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;pthread_join failed, rt = &quot;</span> &lt;&lt; rt &lt;&lt; <span class="string">&quot;, name = &quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;pthread_join error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止后续再次被join</span></span><br><span class="line">        m_thread = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Thread::run</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    Thread* thread = (Thread*)arg;</span><br><span class="line"></span><br><span class="line">    t_thread       = thread;</span><br><span class="line">    t_thread_name  = thread-&gt;m_name;</span><br><span class="line">    thread-&gt;m_id   = <span class="built_in">GetThreadId</span>();</span><br><span class="line">    <span class="comment">//pthread_self()获取当前线程的ID，设置m_name是前15个字节取，因为linux设置最多15</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(<span class="built_in">pthread_self</span>(), thread-&gt;m_name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">15</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; cb;</span><br><span class="line">    cb.<span class="built_in">swap</span>(thread-&gt;m_cb); <span class="comment">// swap -&gt; 可以减少m_cb中只能指针的引用计数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化完成</span></span><br><span class="line">    thread-&gt;m_semaphore.<span class="built_in">signal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="static-thread-local又是什么意思？"><a href="#static-thread-local又是什么意思？" class="headerlink" title="static thread_local又是什么意思？"></a>static thread_local又是什么意思？</h2><p>static代表生命周期知道程序运行结束时候销毁，<strong>被 <code>thread_local</code> 修饰的变量，在每个线程中都有一个独立的副本</strong>。</p>
<h2 id="对pthread-create、pthread-detch、pthread-join的详解"><a href="#对pthread-create、pthread-detch、pthread-join的详解" class="headerlink" title="对pthread_create、pthread_detch、pthread_join的详解"></a>对pthread_create、pthread_detch、pthread_join的详解</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><p>&#96;int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (<em>start_rtn)(void</em>),void *restrict arg);</p>
<ul>
<li>输入参数： tidp:填入pthread_t类型参数。  </li>
<li>attr:通常设置为NULL，用于定制各种不同的线程属性。  </li>
<li>start_rtn:新创建线程的入口函数由此绑定。无参数把arg设置为NULL即可  </li>
<li>返回值：成功返回0，否则返回错误码。</li>
</ul>
<p>线程的入口函数最开始都要先获取传入的参数:&#96;比如pthread_create(&amp;m_thread, nullptr, &amp;Thread::run, this);</p>
<p>在run函数里先执行&#96;Thread* thread &#x3D; (Thread*)arg;</p>
<h3 id="pthread-detch"><a href="#pthread-detch" class="headerlink" title="pthread_detch"></a>pthread_detch</h3><p>目的是为了确保线程在结束后能够正确的释放资源，而不需要主线程或其他线程进行join操作。一般适用的场景是在子线程要脱离主线程的管理，并且主线程不需要担心其资源的释放，简化了使用的复杂性。  </p>
<p>避免了内存泄漏防止忘记调用join导致的内存泄露  </p>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>pthread_Join是POSIX线程库的一个函数，用于等待一个线程的终止并回收它的资源  </p>
<p>值得说的一点就是一般都可以写nullptr。如果你需要接受某个实际的值，那就写一个实际的指针去接受它。</p>
<h1 id="信号量的封装"><a href="#信号量的封装" class="headerlink" title="信号量的封装"></a>信号量的封装</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;                </span><br><span class="line">    std::condition_variable cv;    </span><br><span class="line">    <span class="type">int</span> count;                   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 信号量初始化为0</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Semaphore</span><span class="params">(<span class="type">int</span> count_ = <span class="number">0</span>)</span> : count(count_) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// P操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123; </span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// wait for signals</span></span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// V操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();  <span class="comment">// signal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>线程模块-知识储备</title>
    <url>/2024/07/01/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97-%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
    <content><![CDATA[<p>先做一点基础的线程知识介绍（也算刚考完试做个总结）</p>
<span id="more"></span>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20251005/ULgi/1536X1024/memory_level.png" alt="1536X1024&#x2F;memory_level.png"></p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>假设CPU要读取某个内存地址的数据：</p>
<h3 id="寄存器检查"><a href="#寄存器检查" class="headerlink" title="寄存器检查"></a>寄存器检查</h3><ul>
<li>CPU首先查看这个数据是不是已经在<strong>寄存器</strong>里（最快的存储单元）。</li>
<li>若在寄存器中，直接读取，延迟极低（几个时钟周期内）。</li>
</ul>
<h3 id="L1-Cache（一级缓存）"><a href="#L1-Cache（一级缓存）" class="headerlink" title="L1 Cache（一级缓存）"></a>L1 Cache（一级缓存）</h3><ul>
<li>若寄存器没有，CPU从<strong>L1 Cache</strong>中查找。</li>
<li>L1分为两部分：<strong>L1D（数据）</strong> 和 <strong>L1I（指令）</strong></li>
<li>命中（Hit）：直接读取。</li>
<li>未命中（Miss）：进入下一级。</li>
</ul>
<h3 id="L2-Cache（二级缓存）"><a href="#L2-Cache（二级缓存）" class="headerlink" title="L2 Cache（二级缓存）"></a>L2 Cache（二级缓存）</h3><ul>
<li>查找L2 Cache（比L1大、速度稍慢）。</li>
<li>若命中，则把数据传回CPU，并且通常也更新L1。</li>
</ul>
<h3 id="L3-Cache（三级缓存）"><a href="#L3-Cache（三级缓存）" class="headerlink" title="L3 Cache（三级缓存）"></a>L3 Cache（三级缓存）</h3><ul>
<li>若L2未命中，CPU访问共享的<strong>L3 Cache</strong>（多核共享，容量更大）。</li>
<li>命中：把数据拷回L2和L1供CPU使用</li>
</ul>
<h3 id="主存（DRAM）"><a href="#主存（DRAM）" class="headerlink" title="主存（DRAM）"></a>主存（DRAM）</h3><ul>
<li>如果三级缓存都未命中（称为“三次Cache Miss”），CPU才会：<ul>
<li>通过**内存控制器（Memory Controller）**访问主存（DRAM）。</li>
<li>主存的访问延迟可达几百个时钟周期（相对Cache非常慢）。</li>
<li>数据取回后，会先填充到各级Cache，再给CPU使用。</li>
</ul>
</li>
</ul>
<h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>如果内存中也没有，即涉及到键盘等输入或者就是需要从磁盘读取，则需要继续访问SSD</p>
<h3 id="表格所示"><a href="#表格所示" class="headerlink" title="表格所示"></a>表格所示</h3><table>
<thead>
<tr>
<th>层级</th>
<th>访问延迟（时钟周期）</th>
<th>容量</th>
<th>速度</th>
<th>成本</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1</td>
<td>极小</td>
<td>极快</td>
<td>极高</td>
</tr>
<tr>
<td>L1 Cache</td>
<td>2–4</td>
<td>数十 KB</td>
<td>很快</td>
<td>高</td>
</tr>
<tr>
<td>L2 Cache</td>
<td>10–20</td>
<td>数百 KB</td>
<td>快</td>
<td>中高</td>
</tr>
<tr>
<td>L3 Cache</td>
<td>30–60</td>
<td>数 MB</td>
<td>较慢</td>
<td>中</td>
</tr>
<tr>
<td>主存 (DRAM)</td>
<td>100–300</td>
<td>GB级</td>
<td>慢</td>
<td>低</td>
</tr>
<tr>
<td>SSD&#x2F;HDD</td>
<td>10⁵–10⁷</td>
<td>TB级</td>
<td>极慢</td>
<td>极低</td>
</tr>
</tbody></table>
<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><p>CPU时间片是指操作系统调度程序为每个可运行进程分配的一段<strong>固定长度的CPU时间</strong>。</p>
<ul>
<li>当进程在这段时间内<strong>未执行完</strong>，操作系统会<strong>剥夺其CPU使用权</strong>，将其放回就绪队列；</li>
<li>然后CPU切换到下一个进程；</li>
<li>如果进程在时间片内<strong>执行完毕</strong>，则主动释放CPU</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，</p>
<p>然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。<br>这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<h1 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h1><p>只是稍微介绍一下概念以及几种锁的种类，深入了解请移步并发编程的部分</p>
<h2 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h2><p>进程是操作系统分配资源的基本单位，每个进程独享属于自己的文件描述符、存储器资源等等。</p>
<p>线程是操作系统进行调度的基本单位，一个进程可以有多个线程，线程之间是共享所属进程的资源的。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥是进程(线程)之间的间接制约关系。</p>
<p>当一个进程(线程)进入临界区使用临界资源时，另一个进程(线程)必须等待。 只有当使用临界资源的进程(线程)退出临界区后，这个进程(线程)才会解除阻塞状态。</p>
<blockquote>
<p>[!NOTE] 临界资源<br>对于某些资源来说，其在同一时间只能被一个进程所占用。 这些一次只能被一个进程所占用的资源就是所谓的临界资源。</p>
</blockquote>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步是进程(线程)之间的直接制约关系。 </p>
<p>是指多个相互合作的进程(线程)之间互相通信、互相等待，这种相互制约的现象称为进程(线程)的同步</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>我觉得在并发管理中应该认为<code>mutex</code>是互斥量，当上锁后才是互斥锁</p>
<p>这是最基础的锁。<code>std::mutex</code> 保证在任何时刻，只有一个线程能够获得锁，从而进入由它保护的临界区（Critical Section）。</p>
<p><strong>特点</strong>:</p>
<ul>
<li>独占式：一个线程获取锁之后，其他线程必须等待它释放锁。</li>
<li>非递归：同一个线程不能在释放之前再次获取同一个 <code>std::mutex</code>，否则会造成死锁。</li>
</ul>
<p><strong>使用方法</strong>: 直接调用 <code>lock()</code> 和 <code>unlock()</code> 方法。但这种方式很危险，如果在 <code>lock()</code> 和 <code>unlock()</code>  之间发生异常，<code>unlock()</code> 将不会被调用，导致锁无法释放，所有等待该锁的线程都会被永久阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; // 创建一个互斥锁实例</span><br><span class="line">int shared_counter = 0;</span><br><span class="line"></span><br><span class="line">void increment() &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">        mtx.lock(); // 获取锁</span><br><span class="line"></span><br><span class="line">        // --- 临界区开始 ---</span><br><span class="line"></span><br><span class="line">        shared_counter++;</span><br><span class="line"></span><br><span class="line">        // --- 临界区结束 ---</span><br><span class="line"></span><br><span class="line">        mtx.unlock(); // 释放锁</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t1(increment);</span><br><span class="line">    std::thread t2(increment);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Shared counter: &quot; &lt;&lt; shared_counter &lt;&lt; std::endl; // 输出应该是 20000</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><strong>条件变量（Condition Variable）</strong> 是一种<strong>线程间通信机制</strong>，允许一个线程在某个条件不满足时<strong>进入等待状态（阻塞）</strong>，直到另一个线程<strong>通知它条件已满足</strong>。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cv.wait(lock)</code></td>
<td>线程阻塞，并释放锁</td>
</tr>
<tr>
<td><code>cv.notify_one()</code></td>
<td>唤醒一个等待线程</td>
</tr>
<tr>
<td><code>cv.notify_all()</code></td>
<td>唤醒所有等待线程</td>
</tr>
<tr>
<td>必须持有锁</td>
<td>修改条件变量所依赖的共享状态时，必须先加锁</td>
</tr>
<tr>
<td>防止伪唤醒</td>
<td>使用 <code>cv.wait(lock, predicate)</code> 版本更安全</td>
</tr>
<tr>
<td>典型用途</td>
<td>生产者-消费者模型、线程池任务队列等</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件成立</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;条件满足，开始执行任务\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>C++ 标准库<strong>早期（C++11、C++14、C++17）没有内置信号量</strong>，但从 <strong>C++20</strong> 开始，标准库正式引入了 <strong>信号量（<code>std::counting_semaphore</code> 和 <code>std::binary_semaphore</code>）</strong>。</p>
<hr>
<h3 id="标准信号量"><a href="#标准信号量" class="headerlink" title="标准信号量"></a>标准信号量</h3><p>头文件：<code>#include &lt;semaphore&gt;</code></p>
<h4 id="1-std-counting-semaphore"><a href="#1-std-counting-semaphore" class="headerlink" title="1. std::counting_semaphore"></a>1. <code>std::counting_semaphore</code></h4><ul>
<li>是通用的<strong>计数信号量</strong>。</li>
<li>内部有一个整型计数器，控制可用资源数。<br>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span>  </span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;3&gt; <span class="title">sem</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 最大资源数3，初始值3  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;     </span><br><span class="line">	sem.<span class="built_in">acquire</span>(); <span class="comment">// P操作，尝试获取资源    </span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; working\n&quot;</span>;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));     </span><br><span class="line">	sem.<span class="built_in">release</span>(); <span class="comment">// V操作，释放资源 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(task, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(task, <span class="number">2</span>)</span>, <span class="title">t3</span><span class="params">(task, <span class="number">3</span>)</span>, <span class="title">t4</span><span class="params">(task, <span class="number">4</span>)</span></span>;     </span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>(); t<span class="number">3.</span><span class="built_in">join</span>(); t<span class="number">4.</span><span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最多同时有3个线程能执行“工作”，第4个线程会阻塞直到有资源释放。</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-std-binary-semaphore"><a href="#2-std-binary-semaphore" class="headerlink" title="2. std::binary_semaphore"></a>2. <code>std::binary_semaphore</code></h4><ul>
<li>相当于最大计数为 1 的信号量，也就是“二元信号量”（互斥信号量）。</li>
<li>类似于互斥锁，但可以手动 release，而不需要RAII封装。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="function">std::binary_semaphore <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;     </span><br><span class="line">	sem.<span class="built_in">acquire</span>();     </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; in critical section\n&quot;</span>;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); </span><br><span class="line">	sem.<span class="built_in">release</span>(); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(work, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(work, <span class="number">2</span>)</span></span>;     </span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁是一对互斥锁，分为读锁和写锁。 </p>
<p>读锁和写锁互斥，让一个线程在进行读操作时，不允许其他线程的写操作，但是不影响其他线程的读操作。 当一个线程在进行写操作时，不允许任何线程进行读操作或者写操作。</p>
<blockquote>
<p>[!NOTE] 使用<br>考虑到RAII，虽然读写锁本身提供了对应的加锁和解锁方式，但是还是用提供的RAII锁类，帮助<br>自动管理锁的获取与释放</p>
</blockquote>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>对应操作</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::unique_lock&lt;std::shared_mutex&gt;</code></td>
<td>写锁</td>
<td>独占修改数据</td>
</tr>
<tr>
<td><code>std::shared_lock&lt;std::shared_mutex&gt;</code></td>
<td>读锁</td>
<td>并发只读访问</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁是一种<strong>忙等待锁（busy waiting lock）</strong>：</p>
<ul>
<li>当线程尝试获取锁时，如果锁已被占用，它<strong>不会挂起（不睡眠）</strong>，<br>  而是一直<strong>在循环中检查锁是否可用</strong>。</li>
<li>直到锁可用时立即获取，从而<strong>避免线程上下文切换</strong>的开销。</li>
</ul>
<p>适合场景：</p>
<ul>
<li>锁持有时间极短；</li>
<li>线程数量少；</li>
<li>临界区工作量小；</li>
<li>不希望发生线程切换。<br>不适合：</li>
<li>临界区耗时较长；</li>
<li>核心数量较少（容易浪费CPU）。</li>
</ul>
<p>没有提供标准库实现，但是可以通过<code>atomic_flag</code>实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果锁被其他线程持有，则等待（自旋）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in the critical section.\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.<span class="built_in">clear</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(critical_section)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>协程库</category>
      </categories>
  </entry>
  <entry>
    <title>分层结构</title>
    <url>/2025/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>计算机网络的模型主要有OSI模型和TCP&#x2F;IP模型两种，本文将分别介绍对应模型中每一层的功能与最终的对比。</p>
<span id="more"></span>
<h1 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h1><ul>
<li>协议数据单元（PDU）：对等层之间传送的数据单位。第n层的记为n-PDU。各层PDU都分为服务数据单元和协议控制信息</li>
<li>服务数据单元（SDU）：层与层之间交换的数据单位，第n层的SDU记为n-SDU</li>
<li>协议控制信息（PCI）：控制协议操作的信息。第n层的PCI记为n-PCI<br>每层的协议数据单元都有额外名称，如物理层的称为比特流，链路层的称为帧，网络层的称为分组，传输层的称为报文段</li>
</ul>
<p>在各层间传输数据时满足：n-SDU + n-PCI &#x3D; n-PDU &#x3D; (n-1)-SDU</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>为了在网络中进行数据交换而建立的规则、标准或约定称为网络协议，是控制在对等实体间进行通信的规则的集合，是水平的，不对等实体间没有协议。</p>
<p>由以下三部分组成：</p>
<ul>
<li>语法：数据与控制信息的格式</li>
<li>语义：即需要发出何种控制信息、完成何种动作以及做出何种应答</li>
<li>同步：执行各种操作的条件、时序关系等，即事件实现顺序的详细说明</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>同一节点内相邻两层的实体交换信息的逻辑接口称为服务访问点（SAP），每层只能在紧邻的层间定义接口，而不能跨层定义。</p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>指下层为紧邻的上层提供的功能调用，是垂直的。对等实体在协议的控制下，使本层能为上层提供服务。</p>
<p>可以分为以下三种：</p>
<ul>
<li>面向连接和无连接服务：<ul>
<li>面向连接服务中，通信双方必须先建立连接，分配相应的资源，以保证通信正常进行，传输结束后释放连接和占用的资源。</li>
<li>无连接服务中，通信双方不需要提前建立连接，发送数据时直接发送。</li>
</ul>
</li>
<li>可靠服务和不可靠服务<ul>
<li>可靠服务：指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</li>
<li>不可靠服务：指网络只是尽量让数据正确、可靠地传送到目的地</li>
</ul>
</li>
<li>有应答服务和无应答服务<ul>
<li>有应答服务：指接收方在收到数据后向发送方给出相应的应答，由传输系统内部自动实现</li>
<li>无应答服务：接收方收到数据后不自动给出应答。如果需要，由高层实现</li>
</ul>
</li>
</ul>
<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>有七层，分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>传输单位是比特，功能是在物理介质上为数据端设备透明地传输原始比特流。但是注意传输信息所用的物理介质（如光缆、无线信道等等）不在物理层协议内</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>传输单位是帧，功能是将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，同时实现节点间的差错控制和流量控制的功能</p>
<p>广播式网络还要处理如何控制对共享信道的访问</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>传输单位是数据报。主要任务是将网络层的协议数据单元（分组）从源主机传输到目的主机。关键在于对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>负责两个进程间的通信，提供端到端的流量控制、差错控制、连接建立和释放、可靠传输管理等服务。</p>
<p>数据链路层提供点对点通信，可以理解为主机与主机的通信（主机通过硬件地址或IP地址标识）</p>
<p>端到端的通信指运行在不同主机内两个进程间的通信，每个进程都由一个端口来标识</p>
<p>因为一台主机可以运行多个进程，因此传输层具有复用和分用的功能。复用指多个进程可以同时使用传输层的服务，分用指传输层将收到的信息分别交付给上层的对应进程</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>允许不同主机上各个进程进行会话，为进程建立连接，并在连接上有序传输数据，这就是会话。</p>
<p>负责管理主机间的会话进程，包括建立、管理和终止进程间的会话。</p>
<p>包含一种称为检查点的机制来维持可靠会话，使通信会话在通信失效时从检查点继续恢复通信。</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>主要处理不同主机间交换信息的方式，此外数据压缩、加密和解密也是表示层的功能</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>是用户与网络的接口</p>
<h1 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h1><p>分为五层：物理层、链路层、网络层、传输层、应用层</p>
<p>主要内容上面已经有对应的了，只不过应用层整合了会话层、表示层、应用层三层的功能</p>
<h1 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h1><ul>
<li>OSI模型精确定义了服务、协议与接口。但是TCP&#x2F;IP模型没有明确区分</li>
<li>OSI模型先有模型，后有协议规范，通用性好。TCP&#x2F;IP模型先有协议栈后建立模型，不适合其他非TCP&#x2F;IP的网络</li>
<li>OSI模型在网络层支持无连接和面向连接的服务，但是在传输层仅有面向连接的服务。而TCP&#x2F;IP模型认为可靠性是端到端的问题，因此在网络层仅有一种无连接通信模式，但是在传输层支持无连接和面向连接两种模式</li>
<li>OSI模型有七层，而TCP&#x2F;IP模型分为五层。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络复习</category>
      </categories>
  </entry>
  <entry>
    <title>绪论</title>
    <url>/2025/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>本文将介绍计算机网络的概念以及进行信息交换的方式</p>
<span id="more"></span>
<h1 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h1><ul>
<li>当前全球最大的、开放的、由众多网络和路由器互连而成的特定计算机网络，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET</li>
</ul>
<h1 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h1><ul>
<li>组成部分：<ul>
<li>硬件：主要有主机（也被称作端系统）、通信链路（如光纤）、交换设备（如路由器、交换机）和通信处理机（如网卡）等组成</li>
<li>软件：主要包括各种实现资源共享的软件和方便用户使用的各种工具软件</li>
<li>协议：是计算机网络的核心，规定了网络传输数据时所遵循的规范</li>
</ul>
</li>
<li>工作方式：可以分为边缘部分和核心部分<ul>
<li>边缘部分：所有连接到互联网上的供用户直接使用的主机组成，用来进行通信（如传输数据、音频和视频）和资源共享</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务</li>
</ul>
</li>
<li>功能组成<ul>
<li>通信子网：由各种传输介质、通信设备和相应的网络协议组成，使网络具有数据传输、交换、控制和存储的能力，实现联网计算机间的数据通信</li>
<li>资源子网：实现资源共享功能的设备及软件的集合，向网络用户提供共享其他计算机的硬件资源、软件资源和数据资源的服务</li>
</ul>
</li>
</ul>
<h1 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h1><ul>
<li>数据通信：是最基本和最重要的功能，用来实现联网计算机间各种信息的传输。</li>
<li>资源共享：既可以是软件或数据的共享，也可以是硬件的共享。使计算机中的资源互通有无、分工协作，极大提高了硬件资源、软件资源和数据资源的利用率</li>
<li>分布式处理：当某个计算机系统负荷过重时，可将其处理的复杂任务分配给网络中其他计算机系统，从而利用空闲计算机资源提高整个系统的利用率</li>
<li>提高可靠性：计算机网络中各台计算机可以通过网络互为替代机</li>
<li>负载均衡：将工作任务均衡分配给计算机网络中各台计算机</li>
</ul>
<h1 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h1><p>分为三步：</p>
<ul>
<li>建立连接：进行数据传输前，两个用户必须先建立一条专用的物理通信路径，由通信双方之间的交换设备和链路逐段连接而成</li>
<li>传输数据：在数据传输过程中，这一物理通信路径始终被两用户独占</li>
<li>释放连接：通信结束后释放通信资源<br>整个通信阶段，比特流连续地从源节点直达目的节点，好像在一个管道中传送，不存在存储转发所耗费的时间</li>
</ul>
<p>优点：</p>
<ul>
<li>通信时延小：通信线路为通信双方专用，数据直达，传输速率高</li>
<li>有序传输：通信时按发送顺序传输数据，不存在失序问题</li>
<li>没有冲突：不同的通信双方有不同的信道</li>
<li>实时性强：一旦建立连接，可以随时通信<br>缺点：</li>
<li>建立连接时间长</li>
<li>线路利用率低：线路被独占，即使空闲也不能供其他用户使用</li>
<li>灵活性差：物理通路中任何一点出现故障，必须重新建立连接</li>
<li>难以实现差错控制：中间节点不具备存储和检验数据的能力，无法发现并纠正错误<br>计算机间的数据传送往往是突发（高频、少量）的，使用电路交换来传送数据时，被用户占用的通信资源在绝大部分时间是空闲的，利用率往往不到10%乃至1%</li>
</ul>
<h1 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h1><p>数据交换的单位是报文，用户数据+原地址+目的地址等信息封装为报文。</p>
<p>采用存储转发的技术，整个报文先传送到相邻的节点，全部存储后查找转发表，转发到下一个节点，如此重复直到目的节点。每个报文可以单独选择到达目的端的路径</p>
<p>优点：</p>
<ul>
<li>无建立连接时延：通信前无需建立连接，用户可以随时发生报文</li>
<li>灵活分配线路：交换节点存储整个报文后，选择一条合适的空闲线路，转发报文。若某条路径故障，可重新选择另一条路径传输</li>
<li>线路利用率高：报文在一段链路上传送时才占用这段链路的通信资源</li>
<li>支持差错控制：交换节点可以对缓存下来的报文进行差错检验<br>缺点：</li>
<li>转发时延高：交换节点要收到所有报文后，才查找转发表进行转发</li>
<li>缓存开销大：报文大小没有限制，要求交换节点有较大的缓存空间</li>
<li>错误处理低效：报文较长时，发生错误概率相对更高，重传整个报文的代价也很大</li>
</ul>
<h1 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h1><p>也采用存储转发技术，但是解决了报文过长的问题</p>
<p>源主机在发送之前，先把较长的报文划分为若干较小的等长数据段，每个数据段前添加一些必要的控制信息（如源地址、目的地址和编号信息）组成的首部，构成分组</p>
<p>源主机将分组发送到分组交换网中，分组交换网的分组交换机收到一个分组后，先缓存，再从首部中提取目的地址，据此查找自己的转发表，再将分组转发给下一个分组交换机。经过多个分组交换机的存储转发后，分组到达目的主机</p>
<p>除了继承报文交换的优点外，还有如下优点：</p>
<ul>
<li>方便存储管理，存储转发开销小。</li>
<li>传输效率高</li>
<li>减少了出错概率和重传代价<br>缺点：</li>
<li>存在存储转发时延</li>
<li>需要额外的信息量</li>
<li>当采用数据报服务时，可能出现失序、丢失或重复分组的情况。如果采用虚电路服务，则没有失序问题，但是有呼叫建立、数据传输和虚电路释放三个过程</li>
</ul>
<h1 id="三种交换方式总结"><a href="#三种交换方式总结" class="headerlink" title="三种交换方式总结"></a>三种交换方式总结</h1><p>当要连续传送大量的数据，且传送时间远大于建立连接时间时，采用电路交换比较合适；从提高整个网络的信道利用率来看，报文交换和分组交换优于电路交换，其中分组交换的时延更小，更为灵活，尤其适合突发式数据传送</p>
<h1 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h1><h2 id="按分布范围"><a href="#按分布范围" class="headerlink" title="按分布范围"></a>按分布范围</h2><ul>
<li>广域网（WAN）：提供长距离通信，运送主机发送的数据，覆盖范围通常是直径几十米到几千千米的区域。是互联网核心部分，连接广域网各节点交换机的链路一般是高速链路，具有较大的通信容量。一般使用交换技术</li>
<li>城域网（MAN）：覆盖范围可以跨越几个街区甚至几个城市，直径为5-50km。多采用以太网技术</li>
<li>局域网（LAN）：一般用主机通过高速线路相连，覆盖范围较小，通常是直径为几十米到几千米的区域。一般使用广播技术</li>
<li>个人区域网（PAN）：指在个人工作的地方将电子设备用无线技术连接起来的网络，也叫无线个人区域网</li>
</ul>
<h2 id="按传输技术"><a href="#按传输技术" class="headerlink" title="按传输技术"></a>按传输技术</h2><ul>
<li>广播式网络：共享一个公共通信信道。当一个计算机发送报文分组时，其他所有计算机都会“收听”到，通过检查目的地址来决定是否接收</li>
<li>点对点网络：每条物理线路连接一对计算机。若通信的两台主机间没有直接相连的线路，则要通过中间节点进行存储转发</li>
</ul>
<h2 id="按拓扑结构"><a href="#按拓扑结构" class="headerlink" title="按拓扑结构"></a>按拓扑结构</h2><p>网络拓扑结构是指由网中节点与通信线路间的几何关系表示的网络结构</p>
<ul>
<li>总线型：单根传输线连接计算机。优点是建网容易、增删节点方便、节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感</li>
<li>星型网络：每个终端或计算机以单独线路与中央设备（一般是路由器或交换机）相连。优点是便于集中控制和管理。缺点是成本高，中央设备对故障敏感</li>
<li>环形网络：所有计算机接口设备连成一个环。最典型的例子是令牌环局域网，既可以是单环也可以是双环。环中信号单向传输</li>
<li>网状网络：每个节点至少有两条路径与其他节点相连，多用在广域网中。有规则型和非规则型两种。优点是可靠性高，缺点是控制复杂、线路成本高</li>
</ul>
<h2 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h2><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="按传输介质"><a href="#按传输介质" class="headerlink" title="按传输介质"></a>按传输介质</h2><p>可以分为有线无线两大类。有线网络可以再分为双绞线网络、同轴电缆网络等。无线网络可以分为蓝牙、微波、无线电等类型</p>
<h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><ul>
<li>速率：指连接到网络上的节点在数字信道上传送数据的速率。单位为b&#x2F;s。较高时可用kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s</li>
<li>带宽：原本表示通信线路允许通过的信号频率范围，单位是Hz。但是在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“最高数据传输速率”的同义语。单位为b&#x2F;s</li>
<li>吞吐量：单位时间内通过某个网络（或信道、接口）的实际数据量。</li>
<li>时延：指数据从网络的一端传送到另一端所需的总时间。由四部分组成：<ul>
<li>发送时延：从发送第一个比特开始到最后一个比特从本地发送到线路结束。发送时延&#x3D;分组长度&#x2F;发送速率</li>
<li>传播时延：一个比特从链路一端到另一端的时间。传播时延&#x3D;信道长度&#x2F;传播速率</li>
<li>处理时延：分组在交换节点为存储转发而进行的处理所花的时间。</li>
<li>排队时延：分组在路由器的输入或输出队列排队等待的时间</li>
</ul>
</li>
<li>时延带宽积：指发送的第一个比特到达终点时发送端发出了多少比特。时延带宽积&#x3D;传播时延 * 信道带宽</li>
<li>往返时延（RTT）：从发送端发出一个短分组，到发送端收到来自接收端的确认总共经历的时间。包括各中间节点的处理时延、排队时延及转发数据时的发送时延</li>
<li>信道利用率：某个信道有百分之多少的时间有数据通过。太低会浪费网络资源。太高会产生较大的时延，导致网络拥塞。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络复习</category>
      </categories>
  </entry>
  <entry>
    <title>表达式</title>
    <url>/2025/06/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>一般二元运算符都要求两个运算对象的类型相同或者可以转换为相同类型</p>
<p>运算符作用于类类型的对象时，用户可以自行定义含义，即重载运算符。</p>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>C++表达式要么是左值，要么是右值</p>
<ul>
<li>左值：当一个对象被用作左值时，用的是对象的身份（即内存中的位置）</li>
<li>右值：当一个对象被用作右值时，用的是对象的值</li>
</ul>
<p>右值可以用左值来代替，但是反过来不行</p>
<p>使用关键字 decltype 时，如果表达式的求值结果是左值，decltype 作用于该表达式（不是变量）得到一个引用类型</p>
<h2 id="优先级和结合律"><a href="#优先级和结合律" class="headerlink" title="优先级和结合律"></a>优先级和结合律</h2><p>左结合律：如果运算符优先级相同，按照从左到右的方式组合运算对象</p>
<p><strong>赋值运算符满足的是右结合律</strong></p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>在一个复合表达式中，各个运算对象的求值顺序是不固定的。</p>
<p><code>cout &lt;&lt; i &lt;&lt; ++i &lt;&lt; end;//错误！未定义的行为，不知道先求 i 还是先求 ++i</code></p>
<p>4种运算符明确规定了运算对象的求值顺序：逻辑与(&amp;&amp;)、逻辑或(||)、条件(?:)、逗号(,)</p>
<p>处理复合表达式的两个建议：</p>
<ol>
<li>不确定优先级与结合律时使用括号</li>
<li>如果改变了某个运算对象的值，在同一表达式中不要再使用该运算对象。</li>
</ol>
<h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>算术运算符有 3 组，按优先级从高到低依次是</p>
<ol>
<li>+、- ：一元正号与一元负号</li>
<li><ul>
<li>、&#x2F;、% ：乘法、除法、求余</li>
</ul>
</li>
<li>+、- ：加法、减法<br>注意一元正负号的优先级最高，求余也是一种算术运算。</li>
</ol>
<p>整数除法的结果是向零舍入。</p>
<p>求余运算符的运算对象必须是整数，运算结果始终与被除数符号相同</p>
<h1 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h1><ul>
<li>逻辑运算符：！、&amp;&amp;、||。逻辑运算符的作用对象必须是能转换成布尔值的类型</li>
<li>关系运算符：&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, !&#x3D;, &#x3D;&#x3D; ：大于小于的优先级高于等于和不等于</li>
</ul>
<p><strong>&amp;&amp;、||都是短路求值，即先求左值，若无法判定整体布尔值，再求右值</strong></p>
<h2 id="布尔字面值"><a href="#布尔字面值" class="headerlink" title="布尔字面值"></a>布尔字面值</h2><p>使用算术值做条件时直接用，不要与布尔值做比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a);<span class="comment">//正确 </span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="literal">true</span>);<span class="comment">//错误：会将 true 先转换为 int 再比较，比较结果是不相等</span></span><br></pre></td></tr></table></figure>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>赋值运算符的左侧对象必须是一个可修改的左值</p>
<p>C++ 11 允许使用花括号括起来的初始值列表作为右侧运算对象。初始化列表可以为空，此时将进行值初始化。</p>
<p>赋值运算符满足右结合律。同时优先级较低</p>
<p>复合赋值运算符只求值一次，而普通运算符需要两次。(a&#x3D;a+1 要先求一次 a+1，再将结果赋值给 a)</p>
<p><code>+=; -=; *=; /=; %=; &lt;&lt;=; &gt;&gt;=; &amp;=; ^=; |=;</code></p>
<h1 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h1><h2 id="前置版本"><a href="#前置版本" class="headerlink" title="前置版本"></a>前置版本</h2><p>首先将运算对象加1，再将改变后的对象作为求值结果</p>
<h2 id="后置版本"><a href="#后置版本" class="headerlink" title="后置版本"></a>后置版本</h2><p>也是将运算对象加 1，但是求值结果是运算对象改变之前那个值的副本</p>
<blockquote>
<p>[!NOTE] 关键区别<br>前置版本将对象本身作为左值返回，后置版本将对象的原始值的副本返回。</p>
<p>前置版本直接返回改变了的运算对象，后置版本需要将原始值保存下来以便于返回，是一种浪费。</p>
<p>整体而言，后置版本对于整数和指针来说影响不大，但是对于迭代器而言消耗巨大</p>
</blockquote>
<h2 id="在一条语句中混用解引用和递增运算符"><a href="#在一条语句中混用解引用和递增运算符" class="headerlink" title="在一条语句中混用解引用和递增运算符"></a>在一条语句中混用解引用和递增运算符</h2><p><code>*p++</code> ：p++将 p 的值加一，然后返回 p 的初始值的副本作为求值结果用于解引用。(递增运算符优先级高于解引用)</p>
<p>这是一种提倡的写法，更加简洁，应该习惯于这种写法。</p>
<h1 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h1><p>对于一个指针而言，点运算符和箭头运算符都可以用来访问成员。</p>
<p><code>ptr-&gt;mem 等价于 (*ptr)-&gt;mem</code></p>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><p>cond ? expr1 : expr2。</p>
<p>可以嵌套使用<br><code>finalgrade = (grade&gt;90) ? &quot;high pass&quot; : (grade&lt;60) ? &quot;fail&quot; : &quot;pass&quot;;</code></p>
<p>条件运算符优先级非常低，一般都要加括号</p>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算符作用于整数类型的对象。</p>
<p>位运算符有六种：位求反、位与、位或、位异或、左移、右移</p>
<p><code>~a; a&amp;b; a|b; a^b; a&lt;&lt;2; a&gt;&gt;2</code></p>
<p>如果运算对象是个小整型，会被自动提升为较大的整型类型</p>
<p>可以带符号，也可以不带。如果不带，那么运算结果是固定的，否则要看机器</p>
<p><strong>左移操作处理带符号值是未定义行为</strong></p>
<p>在 C++ 中，建议仅用位运算符来处理无符号类型。</p>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>使用移位运算符，移动的位数必须严格小于结果的位数，否则会产生未定义的行为</p>
<p><code>&lt;&lt;</code>运算符在右侧插入 0，左侧移动超出边界的值舍弃掉。</p>
<p><code>&gt;&gt;</code>运算符处理无符号数时在左侧插入 0，右侧移动超出边界的值舍弃掉。</p>
<p><code>&gt;&gt;</code>运算符处理有符号数时可能在左侧插入 0 也可能插入符号位的副本，由机器决定使用哪种方式</p>
<p>标注IO库里重载了这两个运算符，使得可以接受输入输出流。</p>
<p>重载后满足左结合律</p>
<h2 id="位求反、位与、位或、位异或"><a href="#位求反、位与、位或、位异或" class="headerlink" title="位求反、位与、位或、位异或"></a>位求反、位与、位或、位异或</h2><p>这几种运算符处理 char 时，都会把 char 类型的运算对象首先零扩展提升成 int 类型再进行位运算。</p>
<h1 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h1><p>sizeof返回一个表达式或者一个类型名字所占的字节数，值为size_t类型</p>
<p>对数组执行sizeof运算将得到数组所占的空间，这里不会把数组转换为指针进行处理</p>
<p>对指针执行sizeof运算将得到指针类型的大小，8</p>
<p>如果对string或者vector执行sizeof只返回该类型固定部分的大小，不会计算对象中的元素占多少空间</p>
<blockquote>
<p>[!Hint] 可以用 sizeof 获得数组中元素的个数<br><code>sizeof(arr)/sizeof(*arr);//返回的是数组 arr 的元素数量</code></p>
</blockquote>
<h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><p>在 for 循环中可以用逗号分隔两个不同的条件，或者定义多个值（类型完全相同）<br><code>for(int i=0,j = 0; i!=n; i++,j++)</code></p>
<p><strong>注意，如果在条件判断的部分用逗号分割了若干部分，则只会返回最后一个条件判定的布尔值</strong></p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>c++ 不会直接将两个不同类型的值相加，会先通过类型转换把运算对象的类型统一后再求值</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><ul>
<li>比int类型小的整型值转换为int类型或者更大的整数类型</li>
<li>在条件里，把非布尔值转换成布尔值</li>
<li>初始化过程中，初始值转换为变量的类型</li>
<li>赋值时，右侧运算对象转换成左侧类型</li>
<li>算数运算或关系运算的运算对象有多种类型，转换成一种（一般取最宽的那种）</li>
</ul>
<h2 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h2><p>整型提升把小整数类型（包括 char、bool等）转换成较大的整数类型。如果 int 可以就转换成 int，否则提升成 unsigned int 类型</p>
<p>如果一个是无符号一个带符号。如果无符号类型不小于带符号类型（比如都是 4 字节），则带符号转换为无符号</p>
<p>如果无符号类型小于带符号，转换结果依赖机器。尽量避免这种操作。</p>
<h2 id="其他隐式转换"><a href="#其他隐式转换" class="headerlink" title="其他隐式转换"></a>其他隐式转换</h2><ol>
<li>数组转换为指针：大多数情况下数组自动转换成指向数组首元素的指针。（decltype关键字参数、取地址符(&amp;)、sizeof、typeid都不会发生这种转换）</li>
<li>指针的转换：0 或 nullptr 都能转换成任意指针类型。指向非常量的指针能转换成 void*。指向所有对象的指针都能转换成 const void*</li>
<li>转换成常量：指向非常量的指针转换成指向相应常量类型的指针</li>
<li>类类型的转换：<ol>
<li><code>while(cin&gt;&gt;s);//将 cin 转换为 bool 值</code></li>
<li><code>string s = &quot;value&quot;;//将 c 风格字符串转换为 string</code></li>
</ol>
</li>
</ol>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p>使用强制类型转换，非常危险，一般考虑能否用其他方式避免</p>
<p><code>castname&lt;type&gt;(expression);</code></p>
<p>有以下四种：</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static cast"></a>static cast</h3><p>任何类型转换，只要不包含底层const，都可以用static cast</p>
<p><code>double slope = static_cast&lt;double&gt;(j)/i; //将 j 转换成 double 以便执行浮点数除法</code></p>
<p>当把较大的类型转换为较小的类型时，static_cast 很有用。这时它告诉读者和编译器：我们知道且不在乎精度损失。平时编译器会给警告，显式转换后就不警告了</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const cast"></a>const cast</h3><p>只能改变对象的底层const，可以去掉或增加const性质</p>
<p>只有const cast可以改变表达式的常量属性，其他均不可以</p>
<p>cosnt_cast 常用于有函数重载的上下文中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; s; </span><br><span class="line"><span class="keyword">const_cast</span> &lt;<span class="type">const</span> string&amp;&gt; (s);<span class="comment">// 将 s 转换为常量引用 </span></span><br><span class="line"><span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);<span class="comment">// 将 s 转换回非常量引用</span></span><br></pre></td></tr></table></figure>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>依赖于机器，门槛高而且危险，不要用</p>
<h3 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h3><p>本质上采用 const_cast、static_cast 或 reinterpret_cast 中的一种。</p>
<p>旧式与新式相比没那么清晰明了，如果出现问题，追踪困难</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(a);<span class="comment">// 函数形式的强制类型转换 </span></span><br><span class="line">(<span class="type">int</span>)a;<span class="comment">// c 语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure>
<h1 id="附录：优先级表"><a href="#附录：优先级表" class="headerlink" title="附录：优先级表"></a>附录：优先级表</h1><p><img src="https://tc.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250903/ZzOK/627X605/priority_level_1.png" alt="627X605&#x2F;priority_level_1.png"></p>
<p><img src="https://tc-new.z.wiki/autoupload/f/RuvdRZQ0l1ljDPQRlKtxANiO_OyvX7mIgxFBfDMDErs/20250903/N7CE/631X880/priority_level_2.png" alt="631X880&#x2F;priority_level_2.png"></p>
]]></content>
      <categories>
        <category>C++ primer</category>
      </categories>
  </entry>
</search>
